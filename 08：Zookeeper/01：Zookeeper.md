### Zookeeper

------

[TOC]

##### 01：Zookeeper（动物园） 【四大特性】

- ZooKeeper是一种**为分布式应用所设计的高可用、高性能且一致的开源分布式协调服务**，它提供了一项基本服务：**分布式锁服务**。由于ZooKeeper的开源特性，后来我们的开发者在分布式锁的基础上，摸索了出了其他的使用方法：**配置维护、组服务、分布式消息队列**、**分布式通知/协调**等。

###### 简单的数据模型

- ZK 使得分布式程序能够通过一个共享的树结型构的名字空间来进行相互协调。
- 树型结构的名字空间：是指**ZK服务器内存中的一个数据模型**，其由一系列被称为ZNode的数据节点组成；

###### 可以构键集群

- 组成ZooKeeper集群的每台机器都会在内存中维护当前服务器的状态，并且每台机器之间都互相保持着通信。值得一提的是，**只要集群中存在超过一半的机器能够正常工作，那么整个集群就能够正常对外服务**。

###### 顺序访问

- 对于来自**客户端的每个更新请求，ZK都会分配一个全局唯一的递增编号**，这个编号反映了所有事务操作的先后顺序，应用程序可以使用ZK的这个特性来实现更高层次的同步原语。

###### 高性能

- 由于ZK将**全量数据存储在内存中**，并直接服务于客户端的所有非事务请求，因此它尤其适用于**以读操作为主的应用场景**。
- 三台机器的集群，100% 的读事务，QPS可达12W左右；

##### 02：Zookeeper 从何而来

- 很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在**分布式单点问题**。所以雅虎的开发人员就试图开发**一个通用的无单点问题的分布式协调框架**，以便让开发人员将精力集中在处理业务逻辑上。

##### 03：Zookeeper  的基本概念

###### 集群角色

- ZK集群中的有所机器通过一个**Leader选举**过程来选定一台被称为“Leader”的机器，**Leader服务器客为户端提供读和写服务**。除Leader外，其机他器包括Follower和Observer。**Follower和Observer都能够提供读服务**，唯一的区别在于，**Observer机器不参与Leader选举过程，也不参与写操作的“过半写成功”策略**，因此Observer可以在不影响写性能的情况提下升集群的读性能。

###### 会话

- Session：是客指户端会话。在ZK中，**一个客户端连接是指客户端和服务器之间的一个TCP长连接**。ZooKeeper对外服务的端口默认是2181，客户端启动的时候，首先会与服器务建立一个TCP连接，**从第一次连接建立开始**，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过**心跳检测**与服务器保持有效的会话，也能够向ZK服务器**发送请求并接受响应**，同时还能够通过该连接接收**来自服务器的Watch事件通知**。
- Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服器务压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，**只要在sessionTimeout规定的时间内，能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效**。

###### 数据节点（ZNode）

- 在ZK中，“节点”分为两类；
  - 第一类同样是指构成集群的机器，我们称之为机器节点；
  - 第二类则是指数据模型中的数据单元，我们称之数为据节点——ZNode。

###### 版本

- ZK的每个ZNode上都会存储数据，对应于**每个ZNode，ZooKeeper都会为其维护一个叫作Stat的数据结构**，Stat中记录了这个ZNode的三个数据版本，
  - version：当前ZNode的版本；
  - cversion：当前ZNode子节点的版本；
  - aversion：当前ZNode的ACL版本；

###### Watcher

- 事件监听器：ZK允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去。

###### ACL

- ZK 采用 ACL (Access Control Lists) 的策略来进行权限控制，ZooKeeper定义了如下5种权限
- CREATE：创建子节点的权限。
- READ：获取节点数据和子节点列表的权限。
- WRITE：更新节点数据的权限。
- DELETE：删除子节点的权限。
- ADMIN：设置节点ACL的权限。

##### 04：Zookeeper 的 ZAB协议（Zookeeper Atomic Broadcast）

- ZAB协议：是为分布式协调服务ZK专门设计的一种支持崩溃恢复的原子广播协议。
- 在ZooKeeper中，主要依赖ZAB协议来实现分布式数据一致性，基于该协议，ZooKeeper实现了**一种主备模式的系统架构来保持集群中各副本之间数据的一致性**。
- ZK 使用一个**单一的主进程来接收并处理客户端的所有事务请求**，并采用ZAB的原子广播协议，将服务器数据状态的变更以事务Proposal的形式广播到所有的副本进程上去。
- ZAB协议这的个主备模型架构保证了同一时刻集群中只能够有一个主进程来广播服器务的状态变更，因此能够很好地处理客户端大量的并发请求。另一方面，考虑到在分布式环境中，顺序执行的一些状态变更其前后会存在一定的依赖关系，有些状态变更必须依赖于比它早生成的那些状态变更。考虑到主进程在任何时候都有可能出现崩溃退出或重启现象，因此，ZAB协议还需要做到在当前主进程出现上述异常情况的时候，依旧能够正常工作。

###### ZAB协议

- ZAB协议包括两种基本的模式，分别是崩溃恢复和消息广播。
- 当整个服务框架在启动过程中，或是**当Leader服务器出现网络中断、崩溃退出与重启**等异常情况时，ZAB协议就会**进入恢复模式**并选举产生新的Leader服务器。当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协就会议**退出恢复模式**。所谓的**状态同步指是数据同步**，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进入**消息广播模式**了。
- 当一台同样遵守ZAB协议的**服务器启动后加入到集群中时**，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式，找到Leader所在的服务器并与其进行数据同步，然后一参起与到消息广播流程中。
- 当Leader服务器在接收到客户端的事务请求后，会生成**对应的事务提案发起一轮广播协议**，而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器首会先这将个事务请求转发给Leader服务器。
- 一个机器要成为新的Leader，必须获得过半进程的支持，同时由于每个进程都有可能会崩溃，因此**在ZAB协议运行过程中，前后会出现多个Leader，并且每个进程也有可能会多次成为Leader**。进入崩溃恢复模式后，只要集群中存在过半的服务器能够彼此进行正常通信，那么就可以产生一个新的Leader并再次进入消息广播模式。

###### 消息广播

- ZAB协议的消息广播过程使用的是一个**原子广播协议**，类似于一个**二阶段提交**。过程针对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal，并将其发送给集群中其余所有的机器然后分别再收集各自的选票，最进后行事务提交。
- 消息广播过程
  - 在ZAB协议的二阶段提交过程中，移除了中断逻辑，**所有的Follower服务器要么正常反馈Leader提出的事务Proposal，要么就抛弃Leader服务器**。同时，ZAB协议将二阶段提交中的判断逻辑移除意味着我们可以**在过半的Follower服务器已经反馈Ack之后就开始提交事务Proposal了**，而不需要等待集群中所有的Follower服务器都反馈响应。另外，整个消息广播协议是基于具有了FIFO特性的TCP协议来进行网络通信的，因此能够很容易地保证消息广播过程中消息接收与发送的顺序性。
  - 在整个消息广播过程中，Leader服务器会为每个事务请求生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个**事务Proposal分配一个全局单调递增的唯一ID，我们称之为事务ID(即ZXID)**。
- 具体流程
  - 在消息广播过程中，**Leader服务器会为每一个Follower服务器都各自分配一个单独的队列**，然后将需要广播的事务Proposal依次放到这些队列中去，并且根据FIFO策略进行消息发送，每一个Follower服务器在接收到这个事务Proposal之后，首先都会将其**以事务日志的形式写人到本地磁盘中去，并且在成功写入后反馈给Leader服务器一个Ack响应。当Leader服务器接收到超过半数的Follower Ack响应后，就会广播一个Commit消息给所有的Follower服务器通知以进行其事务提交，同时Leader自身也会完成对事务的提交**，而每一个Follower服务器接在收到Commit消息后，也会完成对事务的提交。

###### 崩溃恢复

- 

























##### 03：Zookeeper 的数据结构Znode【HFS】

- ![](https://github.com/likang315/Middleware/blob/master/08%EF%BC%9AZookeeper/photos/Zonde.png?raw=true)
- ZooKeeper树中的每个节点被称为：Znode
- **引用方式**
  - Zonde通过**路径引用**，路径必须是绝对的，因此他们必须由斜杠字符来**开头**。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串"/zookeeper"用以保存管理信息，比如关键配额信息。
- **Znode结构**
  - ZooKeeper命名空间中的Znode，兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。图中的每个节点称为一个Znode。 每个Znode由3部分组成:
    - stat：此为状态信息, 描述该Znode的版本, 权限等信息
    - data：与该Znode关联的数据
    - children：该Znode下的子节点
  - ZooKeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来**管理调度数据**，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。ZooKeeper的服务器和客户端都被设计为**严格检查并限制每个Znode的数据大小至多1M**，但常规使用中应该远小于此值。
- **数据访问**
  - ZooKeeper中的每个节点存储的数据要被**原子性的操作**。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。
- **节点类型**
  - 节点有两种，分别为**临时节点**和**永久节点**。节点的类型在创建时即被确定，并且不能改变。
  - **临时节点：**该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，**ZooKeeper的临时节点不允许拥有子节点**。
  - **永久节点：**该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。
- **顺序节点**：
  - 当创建Znode的时候，用户可以请求在ZooKeeper的路径结尾添加一个**递增的计数**。这个计数**对于此节点的父节点来说**是唯一的，它的格式为"%10d"(10位数字，没有数值的数位用0补充，例如"0000000001")。当计数值大于232-1时，计数器将溢出。
- **观察**
  - 客户端可以在节点上设置watch，我们称之为**监视器**。当节点状态发生改变时(Znode的增、删、改)将会**触发watch所对应的操作**。当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次，这样可以减少网络流量。

##### 04：Zookeeper 中的时间【多种记录时间的格式】

- Zxid
  - 使ZooKeeper**节点状态改变的每一个操作都将使节点接收到一个Zxid格式的时间戳**，并且这个**时间戳全局有序**，也就是说，每个对节点的改变都将产生一个唯一的Zxid。如果Zxid1的值小于Zxid2的值，那么Zxid1所对应的事件发生在Zxid2所对应的事件之前。
  - 实际上，ZooKeeper的每个节点维护者三个Zxid值，为别为：cZxid、mZxid、pZxid。
  - **cZxid**： 是节点的创建时间所对应的Zxid格式时间戳。
  - **mZxid**：是节点的修改时间所对应的Zxid格式时间戳。
  - 实现中Zxid是**一个64位的数字**，它**高32位是epoch用来标识leader关系是否改变**，每次一个leader被选出来，它都会有一个 新的epoch。低32位是个**递增计数**。
- 版本号
  - 对节点的每一个操作都将致使这个节点的版本号增加。每个节点维护着三个版本号，他们分别为：
  - version：节点数据版本号
  - cversion：子节点版本号
  - aversion：节点所拥有的ACL版本号

##### 05：Zookeeper 的节点属性

|      属性      | 描述                                                         |
| :------------: | :----------------------------------------------------------- |
|     cZxid      | 创建节点时的事务ID                                           |
|     mZxid      | 最后修改节点时的事务ID                                       |
|     pZxid      | 表示该节点的子节点列表最后一次修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响该ID**（注意，只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响pzxid）** |
|     mtime      | 最后修改节点时的时间                                         |
|     ctime      | 创建节点时的时间                                             |
|    cversion    | 子节点版本号，子节点每次修改版本号加1                        |
|  dataversion   | 数据版本号，数据每次修改该版本号加1                          |
|   aclversion   | 权限版本号，权限每次修改该版本号加1                          |
| ephemeralOwner | 创建该临时节点的会话的sessionID。**（如果该节点是持久节点，那么这个属性值为0）** |
|   dataLength   | 该节点的数据长度                                             |
|  numChildren   | 该节点拥有子节点的数量**（只统计直接子节点的数量）**         |

##### 06：Zookeeper 服务中的操作

| 操作            | 描述                                |
| --------------- | ----------------------------------- |
| create          | 创建Znode（父Zode必须存在）         |
| delete          | 删除Znode（Znode没有子节点）        |
| exists          | 测试Znode是否存在，并获取他的元数据 |
| getACL/setACL   | 为Znode获取设置ACL                  |
| getChildren     | 获取Znode所有子节点的列表           |
| getData/setData | 获取设置Znode的相关数据             |
| sync            | 使客户端的Znode视图与Zookeeper同步  |

- 更新ZooKeeper操作是**有限制的**；
  - delete或setData必须**明确要更新的Znode的版本号**，我们可以调用exists找到。如果版本号不匹配，更新将会失败。
- 更新ZooKeeper操作是**非阻塞式的**；
  - 因此客户端如果失去了一个更新(由于另一个进程在同时更新这个Znode)，他可以在不阻塞其他进程执行的情况下，选择重新尝试或进行其他操作。 

##### 07：watch 触发器

###### watch概述

- ZooKeeper 可以为**所有的读操作**设置watch，这些读操作包括：exists()、getChildren()及getData()。
- watch 事件是**一次性的触发器**，当watch的对象状态发生改变时，将会触发此对象上watch所对应的事件。该事件将被**异步**地发送给客户端，并且ZooKeeper为watch机制提供了有序的**一致性保证**。理论上，客户端接收watch事件的时间要快于其看到watch对象状态变化的时间。

###### watch类型

- ZooKeeper所管理的watch可以分为两类：
  - 数据watch(data  watches)：**getData**和**exists**负责设置数据watch；
  - 孩子watch(child watches)：**getChildren**负责设置孩子watch；

###### watch的注册和触发

![](https://github.com/likang315/Middleware/blob/master/08%EF%BC%9AZookeeper/photos/watch.png?raw=true)

###### watch 处理的两类事件【重载的process(Event event)】

- 连接状态事件(type=None, path=null)
  - 这类事件不需要注册，也不需要我们连续触发，我们只要处理就行了。
- 节点事件
  - 节点的建立，删除，数据的修改。它是one time trigger，我们需要不停的注册触发，还可能发生事件丢失的情况。

##### 08：Zookeeper 应用举例【分布式锁】

###### 场景介绍：

- 在分布式锁服务中，有一种最典型应用场景，就是通过对集群进行**Master选举**，来解决分布式系统中的**单点故障**。
- **分布式系统中的单点故障**：通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就都瘫痪了，那么我们把这种故障叫作单点故障。

###### 传统解决方案

1. 传统方式是**采用一个备用节点**，这个备用节点定期给当前主节点发送ping包，主节点收到ping包以后向备用节点发送回复Ack，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务；
2. 当主节点挂了，这时候备用节点收不到回复了，然后他就认为主节点挂了接替他成为主节点；
3. **网络分区（脑裂）**
   - 主节点的并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，这样我们的分布式系统当中就有了两个主节点也就是—**双Master**，出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就乱套啦；

###### Zookeeper

1. 引入Zookeeper以后我们启动了两个主节点，"主节点-A"和"主节点-B"他们启动以后，都向ZooKeeper去注册一个节点。我们假设"主节点-A"锁注册地节点是"master-00001"，"主节点-B"注册的节点是"master-00002"，注册完以后进行选举，**编号最小的节点将在选举中获胜获得锁成为主节点**，也就是我们的"主节点-A"将会获得锁成为主节点，然后"主节点-B"将被阻塞成为一个备用节点。那么，通过这种方式就完成了对两个Master进程的调度。
2. 如果"主节点-A"挂了，这时候他所注册的节点将被自动删除，**ZooKeeper会自动感知节点的变化**，然后再次发出选举，这时候"主节点-B"将在选举中获胜，替代"主节点-A"成为主节点。
3. Master 恢复
   - 如果主节点恢复了，他会再次向ZooKeeper注册一个节点，这时候他注册的节点将会是"master-00003"，ZooKeeper会感知节点的变化再次发动选举，这时候"主节点-B"在选举中会再次获胜继续担任"主节点"，"主节点-A"会担任备用节点。

![](https://github.com/likang315/Middleware/blob/master/08%EF%BC%9AZookeeper/photos/master-%E9%80%89%E4%B8%BE.png?raw=true)





