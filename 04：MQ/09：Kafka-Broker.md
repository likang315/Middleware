### Kafka-Broker

------

[TOC]

##### 01：集群成员关系

- Kafka 使用 Zookeeper 来维护集群成员的信息。每个broker 都有一个**唯一标识符(brokerID)**，这个标识符可以在配置文件里指定，也可以自动生成。在 broker 启动的时候，它通过**创建临时节点把自己的ID 注册到Zookeeper**。Kafka 组件订阅 **Zookeeper 的/brokers/ids 路径**（broker 在 Zookeeper 上的注册路径），当有 broker 加入集群或退出集群时，这些组件就可以获得通知。
- 在 **broker 宕机、出现网络分区或长时间垃圾回收停顿**时，broker 会从 Zookeeper 上断开连接，此时**broker 在启动时创建的临时节点会自动从 Zookeeper 上移除**。监听 broker 列表的 Kafka 组件会被告知该 broker 已移除。
- 在关闭 broker 时，它对应的节点也会消失，不过**它的 ID 会继续存在于其他数据结构中**。例如，主题的副本列表里就可能包含这些ID。在完全关闭一个 broker 之后，如果**使用相同的ID 启动另一个全新的broker**，它会立即加入集群，并**拥有与旧broker相同的分区和主题**。

##### 02：集群控制器

- 集群控制器其实就是一个broker，只不过它**除了具有一般  broker 的功能之外，还负责分区首领的选举**。集群里第一个启动的 broker 通过在 Zookeeper 里**创建一个临时节点/controller 让自己成为控制器**。其他 broker 在启动时也会尝试创建这个节点，不过它们会收到一个**“节点已存在”的异常**，然后“意识”到控制器节点已存在，也就是说集群里已经有一个控制器了。**其他 broker 在控制器节点上创建Zookeeper watch 对象（观察者模式）**，这样它们就可以**收到这个节点的变更通知**。

###### 集群控制器选举

- Kafka 通过 Zookeeper 的临时节点来选举控制器，并在节点加入集群或退出集群时通知控制器。
- 如果**控制器被关闭或者与Zookeeper 断开连接**，Zookeeper 上的临时节点就会消失。集群里的**其他broker 通过 watch 对象得到控制器节点消失的通知**，它们会尝试让自己成为新的控制器。**第一个在Zookeeper 里成功创建控制器节点的broker 就会成为新的控制器，其他节点会收到“节点已存在”的异常，然后在新的控制器节点上再次创建watch 对象。**每个新选出的控制器**通过 Zookeeper 的条件递增操作获得一个全新的、数值更大的controller epoch**。其他 broker 在收到当前 controller epoch 后，如果收到由控制器发出的包含较旧epoch 的消息，就会**忽略旧的**；
- 控制器**使用epoch 来避免“脑裂”**。“脑裂”是指两个节点同时认为自己是当前的控制器。

###### 分区首领选举

- 当控制器发现一个broker 已经离开集群（通过观察相关的Zookeeper 路径），它就知道，那些**失去首领的分区需要一个新首领**（这些分区的首领刚好是在这个 broker 上）。控制器遍历失去首领的分区，并确定谁应该成为新首领（简单来说就是**分区副本列表里的下一个 同步的 副本**），然后向所有包含新首领或现有跟随者的broker 发送请求。该请求消息包含了**谁是新首领以及谁是分区跟随者的信息**。随后，新**首领开始处理来自生产者和消费者的请求，而跟随者开始从新首领那里复制消息**。

###### 群主选举

- 第一个加入群组的消费者将成为”群主”，选举时选出第一个HashMap对应的成员，基本是随机选取的；

##### 03：同步（复制）

- 它可以在个别节点失效时，保证 Kafka 的可用性和持久性。
- Kafka 使用主题来组织数据，**每个主题被分为若干个分区，每个分区有多个副本**。那些副本被保存在broker 上，**每个broker 可以保存成百上千个属于不同主题和分区的副本**；

###### 首领副本（Leader）

- 每个分区都有一个首领副本。为了保证一致性，**所有生产者请求和消费者请求都会经过这个副本**。

###### 跟随者副本（Follower）

- 首领以外的副本都是跟随者副本。**跟随者副本不处理来自客户端的请求，它们唯一的任务就是从首领那里同步消息，保持与首领一致的状态**。如果首领发生崩溃，其中的一个跟随者会被提升为新首领。
- 首领的另一个任务是弄清楚**哪个跟随者的状态与自己是一致的**。跟随者为了保持与首领的状态一致，在有新消息到达时尝试从首领那里复制（同步）消息，不过有各种原因会导致同步失败，但是最终会保持一致；首领通过查看每个跟随者请求的最新偏移量，首领就会知道每个跟随者复制的进度。如果跟随者在10s 内没有请求任何消息，或者虽然在请求消息，但在10s 内**没有请求最新的数据，那么它被认为是不同步的**。如果一个副本无法与首领保持一致，在首领发生失效时，它就**不可能成为新首领**—毕竟它没有包含全部的消息。相反，**持续请求得到的最新消息副本被称为同步的副本**。在首领发生失效时，只有同步副本才有可能被选为新首领。

###### 首选首领

- 除了当前首领之外，每个分区都有一个首选首领——**创建主题分区时选定的首领就是分区的首选首领**。之所以把它叫作首选首领，是因为**在创建分区时，需要在broker 之间均衡首领**，因此，我们希望首选首领在成为真正的首领时，broker 间的负载最终会得到均衡。
- 默认情况下，Kafka 的 auto.leader.rebalance.enable 被设为true，它会检**查首选首领是不是当前首领**，如果不是，并且该副本是同步的，那么就会**触发首领选举**，让首选首领成为当前首领。
- 分区的副本清单里的第一个副本一般就是首选首领；

##### 04：处理请求

- broker 的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求，按照请求到达的顺序来处理它们，这种顺序保证**保存的消息是有序的**。

###### Kafka 处理请求的流程

1. broker 会在它所监听的每一个端口上运行一个 **Acceptor 线程**，这个线程会创建一个连接，并把它交给**Processor 线程**去处理；
2. Processor 线程（也被叫作“网络线程”）的数量是可配置的。网络线程负责从客户端获取请求消息，把它们放进请求队列；
3. **IO 线程**负责处理他们，然后从响应队列获取响应消息，把它们发送给客户端；
4. ![kafka-process-req](/Users/likang/Code/Git/Middleware/05：MQ/photos/kafka-process-req.png)

###### 元数据请求

- 客户端如何知道把请求发送给分区的首领副本？
  - 客户端使用了另一种请求类型，也就是**元数据请求**。这种请求包含了**客户端订阅的主题列表**。服务器端的响应消息里指明了这些**主题所包含的分区、每个分区都有哪些副本，以及哪个副本是首领**。元数据请求可以发送给任意一个broker，因为**所有broker 都缓存了这些信息**。
  - 一般情况下，**客户端会缓存这些信息**，并直接往目标 broker 上发送生产请求和获取请求。它们需要时不时地通过**发送元数据请求来刷新这些信息**（刷新的时间间隔通过 metadata.max.age.ms 参数来配置），从而知道元数据是否发生了变更；

###### 生产请求

- **生产者发送的请求**，它包含客户端要写入broker 的消息。
- 参数acks 用于指定需要多少个broker确认才可以认为一个消息写入是成功的，如果 acks 配置的值是 `all`，那么这些请求会被保存在**炼狱（Purgatory）的缓冲区**中，直到领导者副本发现跟随者副本都复制了消息，响应才会发送给客户端；

###### 获取请求

- 在消费者和跟随者副本需要**从broker 读取消息时发送的请求**。
- 客户端发送请求，向broker 请求**主题分区里具有特定偏移量的消息**，Kafka 使用**零复制技术**向客户端发送消息，Kafka 直接把消息从文件（或者更确切地说是Linux 文件系统缓存）里发送到网络通道，而不需要经过任何中间缓冲区（MySQL 会经过缓冲池）。
- 客户端除了可以设置 broker 返回数据的上限，也可以设置下限，**上限用于控制消息数量，防止撑爆内存，下限用于减少网络开销**。当然消费者也不会一直等待，有超时时间限制；
- ![](/Users/likang/Code/Git/Middleware/05：MQ/photos/kafka-reqest.png)

###### 注意

- **并不是所有保存在分区首领上的数据都可以被客户端读取**，因为还没有被足够多副本复制的消息被认为是“不安全”的，**如果首领发生崩溃**，另一个副本成为新首领，那么这些消息就丢失了。如果我们允许消费者读取这些消息，可能就会破坏一致性；
- **高水位线：**只有处于高水位先之上的消息，才可以被消费者们感知到；

###### 其他请求

- **LeaderAndIsr请求**
  - 它们之间的请求发生在**Kafka 内部**，客户端不应该使用这些请求。当一个新首领被选举出来，控制器会发送**LeaderAndIsr 请求给新首领**（这样它就可以开始接收来自客户端的请求）**和跟随者**（这样它们就知道要开始跟随新首领）。

##### 05：物理存储

- Kafka 的基本存储单元是分区。分区无法在多个 broker 间进行再细分，也无法**在同一个broker 的多个磁盘上进行再细分**。所以，分区的大小受到**单个挂载点可用空间的限制**；
- 在配置Kafka 的时候，指定了一个用于存储分区的目录清单，**log.dirs 参数**，该参数一般会包含每个挂载点的目录。

###### 分区分配

- 为分区和副本选好合适的broker 
  - 假设你有6 个broker，打算创建一个包含10 个分区的主题，并且复制系数为3。那么Kafka 就会有30 个分区副本，它们可以被分配给6 个broker。在进行分区分配时：
    - 在broker 间平均地分布分区副本。对于我们的例子来说，就是要保证每个broker 可以分到5 个副本。
    - 确保每个分区的每个副本分布在不同的broker 上。
    - 如果为broker 指定了机架信息（机房），那么尽可能把每个分区的副本分配到不同机架的broker上。这样做是为了**保证一个机房的不可用不会导致整体的分区不可用**；
- 决定分区应该使用哪个目录
  - 计算每个目录里的分区数量，新的分区总是**被添加到数量最小**的那个目录里；

###### 文件管理

- 

##### 06：LSR 机制，AR

##### 07：缓存（操作系统的页缓存）和持久化（磁盘）

##### 08：零拷贝





