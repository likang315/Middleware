### Kafka

------

[TOC]

##### 01：设计目标

- 为**数据管道**应用而生，提供一个高性能的消息系统，可以处理多种数据类型，并能够**实时提供纯净且结构化**的用户活动数据和系统度量指标。

###### Kafka 版本

|      版本       | 发布时间 | 特性                                                         |
| :-------------: | :------: | :----------------------------------------------------------- |
|   Kafka 1.0.0   | 2017.11  | Kafka 的第一个稳定版                                         |
|   Kafka 2.3.0   | 2019.07  | 新增 Partition reassignment API                              |
|   Kafka 2.7.0   | 2020.12  | KRaft 模式引入的测试版，可以不需要 ZK                        |
| **Kafka 3.0.0** | 2021.09  | Kafka 服务端不支持 Java8 使用，客户端支持，**KRaft 生成就绪** |
|   Kafka 3.3.1   | 2022.10  |                                                              |

##### 02：发布与订阅消息系统

- 直连（点对点模式）：生产者与消费者直连，消息发到 topic；
- 多个直连：导致系统服务非常乱，这时单独建立一个服务接受来源于其他服务的消息，此时就拆解为发布订阅模式；

##### 03：Kafka 关键概念

###### 消息和批次

- 消息由字节数组组成，所以对于Kafka 来说，消息里的数据没有特别的格式或含义；
- 消息可以有一个**可选的元数据，也就是键**。键也是一个字节数组，与消息一样，对于 Kafka 来说也没有特殊的含义，不过当消息需要以一种**可控的方式写入不同的分区时，会用到键，保证相同的 key 写入到同一个分区**；
- 为了提高效率消息被分批写入kafka，**批次就是一组消息，且这些消息属于同一个主题和分区**， 主要是在时间延迟和吞吐量之间作出权衡;

###### 消息模式（schema）

- 定义消息内容，有许多可用的选项，**像 Json** 和xml，但是该属性缺乏强类型处理能力。
- 数据格式的一致性对 Kafka 来说非常重要，它消除了读写操作之间的耦合性。

###### 主题和分区

- Kafka 的消息通过**主题进行分类**。
- 消息以追加的方式写入分区，然后以先入先出的顺序读取。
- 由于一个主题一般包含几个分区，因此**无法在整个主题范围内保证消息的顺序，但可以保证消息在单个分区内的顺序。**
- 通常我们把一个主题的数据看成流，流式处理；
- <img src="https://github.com/likang315/Middleware/blob/master/04%EF%BC%9AMQ/photos/partition.png?raw=true" alt="partition" style="zoom:70%;" />

###### 生产者与消费者

- 生产者在默认情况下把**消息均衡**地分布到主题的所有分区上，而并不关心特定消息会被写到哪个分区。不过，在某些情况下，生产者会**把消息直接写到指定的分区**。这通常是通过**消息键和分区器**来实现的，分区器为键成一个散列值，并将其映射到指定的分区上。这样可以**保证包含相同键的消息会被写到同一个分区上**;
- 消费者订阅一个或多个主题，并按照消息生成的顺序读取它们。消费者**通过检查消息的偏移量来区分已经读取过的消息**。**偏移量是另一种元数据，它是一个不断递增的整数值，在创建消息时，Kafka 会把它添加到消息里。**在指定的分区里，每个消息的偏移量都是唯一的。**消费者把每个分区最后读取的消息偏移量保存 ZK 或Kafka 上，如果消费者关闭或重启，它的读取状态不会丢失**。
- 消费者是消费者群组的一部分，会有一个或多个消费者共同读取一个主题。**群组保证每个分区只能被特定的消费者使用。**
- <img src="https://github.com/likang315/Middleware/blob/master/04%EF%BC%9AMQ/photos/Consumer-group-partition.png?raw=true" style="zoom:67%;" />
  - 该图的群组中，有 3 个消费者同时读取一个主题。其中的两个消费者各自读取一个分区，另外一个消费者读取其他两个分区。**消费者与分区之间的映射通常被称为消费者对分区的所有权。**

###### Broker 和集群

- broker 接收来自生产者的消息，为消息设置偏移量，并将消息持久化到磁盘。broker 为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。
- 每个集群**都有一个broker 同时充当了集群控制器（Controller）的角色**（第一个加入到集群中的 Broker）。Controller 负责集群管理工作，包括**将分区分配给 broker 和监控 broker**。
- **一个分区可以分配给多个broker，这个时候会发生分区复制**。这种复制机制为分区提供了消息冗余，如果有一个broker 失效，其他 broker 升级为分区首领；
- **保留消息：**Kafka Broker 默认的消息保留策略是这样的：要么保留一段时间（比如7 天），要么保留到消息达到一定大小的字节数（比如1GB）。

##### 04：Kafka的优势

1. 高可用：当 Broker 宕机时，重新选举分区首领处理消息；
2. 高性能：横向扩展生产者，消费者和Broker；
3. 持久化消息：基于磁盘的数据存储，可以容忍消费者离线一小段时间；
4. 伸缩性：方便扩展到多个broker；

##### 05：数据生态系统

- 活动跟踪；
- 传递消息（系统度量指标）；
- 日志收集；
- 流处理（实时，离线）；

