### Kafka

------

[TOC]

##### 01：发布与订阅消息系统

- 直连（点对点模式）：生产者与消费者直连；
- 多个直连：导致系统服务非常乱，这时单独建立一个服务接受来源于其他服务的消息，此时就拆解为发布订阅模式；

##### 02：Kafka 概述

###### 消息和批次

- 消息有字节数组组成，，所以对于Kafka 来说，消息里的数据没有特别的格式或含义；
- 消息可以有一个**可选的元数据，也就是键**。键也是一个字节数组，与消息一样，对于 Kafka 来说也没有特殊的含义，不过当消息以一种**可控的方式写入不同的分区时**，会用到键，保证相同的key写入到同一个分区；
- 为了提高效率消息被分批写入kafka，批次就是**一组消息**，且这些消息属于同一个主题和分区， 主要是在时间延迟和吞吐量之间作出权衡;

###### 消息模式(schema)

- 定义消息内容，有许多可用的选项，像Json和xml，但是该属性缺乏强类型处理能力。
- 数据格式的一致性对Kafka来说非常重要，它消除了读写操作之间的耦合性。

###### 主题和分区

- Kafka 的消息通过**主题进行分类**。主题就好比数据库的表。主题可以被分为若干个分区，一个分区就是一个提交日志。
- 消息以追加的方式写入分区，然后以先入先出的顺序读取。
- 由于一个主题一般包含几个分区，因此**无法在整个主题范围内保证消息的顺序，但可以保证消息在单个分区内的顺序。**
- 通常我们把一个主题的数据看成流，流式处理；
- ![partition](/Users/likang/Code/Git/Middleware/MQ/photos/partition.png)

###### 生产者与消费者

- 生产者在默认情况下把**消息均衡**地分布到主题的所有分区上，而并不关心特定消息会被写到哪个分区。不过，在某些情况下，生产者会**把消息直接写到指定的分区**。这通常是通过**消息键和分区器**来实现的，分区器为键成一个散列值，并将其映射到指定的分区上。这样可以**保证包含同一个键的消息会被写到同一个分区上**;
- 消费者订阅一个或多个主题，并按照消息生成的顺序读取它们。消费者**通过检查消息的偏移量来区分已经读取过的消息**。**偏移量是另一种元数据，它是一个不断递增的整数值，在创建消息时，Kafka 会把它添加到消息里。**在给定的分区里，每个消息的偏移量都是唯一的。**消费者把每个分区最后读取的消息偏移量保存ZK 或Kafka 上，如果消费者关闭或重启，它的读取状态不会丢失**。
- 消费者是消费者群组的一部分，也就是说，会有一个或多个消费者共同读取一个主题。**群组保证每个分区只能被特定的消费者使用。**
- ![Consumer-group-partition](/Users/likang/Code/Git/Middleware/MQ/photos/Consumer-group-partition.png)
  - 该图的群组中，有3 个消费者同时读取一个主题。其中的两个消费者各自读取一个分区，另外一个消费者读取其他两个分区。**消费者与分区之间的映射通常被称为消费者对分区的所有权关系。**

###### broker 和 集群

- broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。broker 为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。
- 每个集群**都有一个broker 同时充当了集群控制器的角色**（自动从集群的活跃成员中选举出来）。控制器负责管理工作，包括**将分区分配给 broker 和监控broker**。
- **一个分区可以分配给多个broker，这个时候会发生分区复制**。这种复制机制为分区提供了消息冗余，如果有一个broker 失效，其他 broker 可以接管领导权；
- **保留消息：**Kafka broker 默认的消息保留策略是这样的：要么保留一段时间（比如7 天），要么保留到消息达到一定大小的字节数（比如1GB）。

##### 03：Kafka的优势

1. 多个生产者；
2. 多个消费者；
3. 基于磁盘的数据存储：可以容忍消费者离线一小段时间；
4. 伸缩性：轻松扩展到多个broker；
5. **高性能**：横向扩展生产者，消费者和Broker；

##### 04：数据生态系统

- 活动跟踪；
- 传递消息；
- 度量指标和日志记录；
- 提交日志；
- 流处理（实时，离线）；

##### 05：设计目的

- 为**数据管道**应用而生，提供一个高性能的消息系统，可以处理多种数据类型，并能够**实时提供纯净且结构化**的用户活动数据和系统度量指标。











