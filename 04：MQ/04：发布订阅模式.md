### 发布/订阅模式

------

[TOC]

##### 01：发布/订阅模式

- 类似于：出版社-邮局-消费者

- 为什么要使用发布订阅模式？

  - 注册用户成功后发一封激活邮件，用户收到邮件后点击激活链接后才能使用该网站。一般的做法是在注册用户业务逻辑中调用发送邮件的逻辑。这样**用户业务就依赖于邮件业务**。如果以后改为短信激活，注册用户业务逻辑就必须修改为调用发送短信的逻辑。如果要注册后给用户加点积分，再加一段逻辑。经过多次修改，我们发现很**简单的注册用户业务已经越来越复杂，越来越难以维护**。这时候就需要**解耦**，将注册成功后的业务逻辑从用户业务中剥离出来，谁需要消费我的消息，谁订阅就行，这样Producer和Consumer互不知道对方的情况下完成了功能；

- 原理图

  ![publisher-Subscriber](https://github.com/likang315/Middleware/blob/master/MQ/photos/Publisher-Subscriber.png?raw=true)

##### 02：Demo

- ###### Producer

```java
/**
 * 发布订阅模式
 * 订阅topic，Producer 往指定信道上发送消息，订阅该信道的 Consumer 会自动收信道 push 的消息
 *
 * @author kangkang.li@qunar.com
 * @date 2020-08-22 11:33
 */
public class Producer {

    private static void producer() throws Exception {
        Connection connection = null;
        Session session = null;

        try {
            // 默认localhost
            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
            connection = connectionFactory.createConnection();
            connection.start();
            // session第一个参数是否是事务
            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);
            Destination destination = session.createTopic("topicName");
            MessageProducer producer = session.createProducer(destination);

            for (int i = 0; i < 5; i++) {
                TextMessage message = session.createTextMessage();
                message.setText(Long.toString(System.currentTimeMillis()));
                producer.send(message);
            }
            // 非事务方式不用提交
            session.commit();
        } catch (JMSException e) {
            e.printStackTrace();

        } finally {
            if (Objects.nonNull(session)) {
                session.close();
            }
            if (Objects.nonNull(connection)) {
                connection.close();
            }
        }
    }

    public static void main(String[] args) throws Exception {
        producer();
    }
}

```

- ###### Consumer

```java
public class Consumer1 {
    static void consumer() {
        Connection connection;
        Session session;
        try {
            ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
            connection = connectionFactory.createConnection();
            connection.start();
            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);
          	// 发布模式中 订阅topic
            MessageConsumer messageConsumer = session.createConsumer(
              session.createTopic("topicName"));

            messageConsumer.setMessageListener(new MQListener());
            session.commit();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 暂时让其处于监听状态，不关闭
        }

    }
  
  	static class MQListener implements MessageListener {
        @Override
        public void onMessage(Message message) {
            try {
                TextMessage textMessage = (TextMessage) message;
                System.out.println("Customer1 消费消息:" + textMessage.getText());
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }

    public static void main(String[] args) {
        consumer();
    }
}
```

