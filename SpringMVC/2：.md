### Spring-MVC-Annotation

------

##### 1：@RequestMapping：

​	用在控制器的类及方法的定义处，定义在方法的是在类的URL下的下一层URL，不旦支持标准的 URL，还支持 Ant 风格（？、*和**字符）

###### 原理：

​	DispacherServlet 截获请求后，通过控制器上@RequestMapping 提供的映射信息确定请求所对应的处理方法
将请求映射到控制器处理方法的工作包含一系列映射规则，具体包括请求 URL、请求参数、请求方法、请求头

- Path 和 value 设置路径：@RequestMapping(value = {"/page","page*", "view/*,**/msg"})
- Method 请求方法：@RequestMapping(method = RequestMethod.GET)
- Headers 报头过滤：@RequestMapping(headers = {"content-type=text/plain"}) 
- params 参数过滤 ：@RequestMapping(params = {"personId=10"}) ，可以是数组

##### 2：获取请求携带的参数

- @PathVariable：用来获得请求url中的动态参数的
- @RequestParam和@PathVariable：Spring能够根据名字自动赋值对应的函数参数值
- @RequestHeader ：按请求报头绑定
- @CookieValue   ：将参数名帮定了对像属性
- @MatrixVariable：用矩阵变量绑定参数

```java
@RequestMapping("/pets/{petId}")															  
public void findPet(@PathVariable String ownerId, @PathVariable String petId)

@RequestMapping(value = "/handle2")
public ModelAndView handle2(@CookieValue("JSESSIONID")String sessionId,
                            @RequestHeader("User-Agent") String agent )

// 请求参数按名称匹配的方式绑定到 user 的属性中、方法返回对应的字符串代表逻辑视图名
@RequestMapping(value = "/handle3")
public String handle3(User user) {
  return "hello"
}

// GET 传参
http://localhost:8080/handle1?userName=zhangsan&password=123&realName=jack
```

##### 3：乱码问题（过滤器）

```xml
<filter>
  <filter-name>characterEncodingFilter</filter-name>
  <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
  <init-param>
    <param-name>encoding</param-name>
    <param-value>UTF-8</param-value>
  </init-param>
  <init-param>
    <param-name>forceEncoding</param-name>
    <param-value>true</param-value>
  </init-param>
</filter>
<filter-mapping>
  <filter-name>characterEncodingFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
```

##### 4：Spring mvc 支持的方法参数

使用 Servlet API 传入参数时，Spring mvc 将 web 层的 Servlet 对象传递给处理方法，参数顺序没有特殊要求

-  HttpServletRequest request，HttpservletResponse response
- HttpSession session
- InputStream/Reader： 对应 request.getInputStream()
- OutputStream/Writer：对应 response.getOutputStram()

```JAVA
@RequestMapping(value = "/handle1")
public void handle1(HttpServletRequest request,HttpServletResponse response) {
    String userName = request.getParameter("userName");
    response.addCookie(new Cookie("userName", userName))
}
```

###### 5：HttpMessageConverter<T>：

Spring 的接口，它负责将请求信息转换为一个对象（类型为 T）,将对象（类型为 T）输出为响应信息

org.springframework.http.converter

DispatcherServlet 默认安装了 RequestMappingHandlerAdpter 作为 HandlerAdapter 的组件实现类，
HttpMessageConverter 通过使用 RequestMappingHandlerAdapter 使用，将请求信息转换为对象，或将对象转换为响应信息

 method：

Boolean canRead(Class<?> clazz,MediaType mediaType)
	指定转换器可以读取的对象类型，同时指定支持 MIME 类型
Boolean canWriter(Class<?> clazz,MediaTypemediaType)
	指定转换器可以将 clazz 类型的对象写到响应流中，响应流支持类型在 mediaType 中定义
List<MediaType> getSupportMediaTypes()
	返回该转换器支持的媒体类型

T read(class<? extends T> clazz , HttpInputMessage inputMessage)
	将请求信息流转换成 T 类型的对象
void write(T t , MediaType contentType,HttpOutputMessageoutputMessage)
	将 T 类型的对象写到响应流中，同时指定响应媒体类型为 contentType

   实现类：
    AnnotationMethodHandlerAdapter默认安装了以下实现类

StringHttpMessageConverter：请求信息转为字符串，可读取所有媒体类型(*/*),通过 supportedMediaTypes 属性指定媒体类型
FormHttpMessageConverter：将表单数据读取到 mutiValueMap 中
ByteArrayHttpMessageConverter：读写二进制数据，T 为 byte[]类型，可读取*/*，可通过supportedMediaTypes属性指定媒体类型 ，响应信息媒体类型为application/octer-stream
MappingJacksonHttpMessageConverter：利用jackson 的 ObjectMapper读写 Json 数据，T为 Object，可读取application/json响应媒体类型为 application/json

使用 HttpMessageConverter<T>：将请求信息转换并绑定到处理方法的入参中 
SpringMVC 两种方式：
	使用 @RequestBody/@ResposeBody 对处理方法进行标注
	使用 HttpEntity<T>/ResponseEntity<T> 作为处理方法的入参或返回值



### 11：SpringMVC 对 Model ，@ModelAttribute 及@SessionAttributes 和处理流程

###### @ModelAttribute  的用法

1. 运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；
2. 运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；

1:Spring MVC 在调用（controller）处理的方法前，在请求线程中自动创建一个隐含的模型对象(Model)
2:**调用所有标注了@ModelAttribute的方法，将在所有controller的方法调用前，调用此方法，将方法返回值添加到隐含模型中**

3:查看Session中是否存中@SessionAttributes("xx")所指定的xx属性，如果有，则将其添加到隐含模型中，如果隐含模型中已经有xx属性，则该步操作会覆盖模型中已有的属性值

###### 4：对标注@ModelAttribute(“xx”) 处理方法的入参的流程(标注在参数)

1:如果隐含模型拥有名为xx的属性,则将隐含模型中的其属性赋给该入参，再用请求消息填充该入参对象直接返回,否则转到2
2:如果 xx是会话属性，即在处理类定义处标注了@SessionAttributes(“xxx”),则尝试从会话中获取该属性，并将其赋给该
 入参，然后再用请求消息填充该入参对象,如果在会话中找不到对应的属性，则抛出 HttpSessionRequiredException 异常，否则转到3
3:如果隐含模型中不存在 xxx 属性，且 xxx 与不是会话属性，则创建入参的对象实例，然后再用请求消息填充该入参



### 12：Controller 的方法的返回值类型（三种）

###### 1：void

```java
//使用此方式进行跳转
response.sendRedirect("/springmvc-web2/itemEdit.action");
```

###### 2：String

​	返回对应的逻辑视图名称真实url为：prefix+视图名称 + suffix 组成

注意：
		1：如果方法声明了注解@ResponseBody ，则会直接将返回值输出到页面
​		2："redirect:path,重定向
​		3："forward:path  跳转
​		4："/admin/views/hello"   视图解析器会解析路径字符串

###### 3：ModelAndView

###### 通过setViewName()方法跳转到指定的页面，通过addObject()设置需要返回的值，将值设置到一个名为ModelMap的类属性

ModelAndView的实例是由用户手动创建的，这也是和ModelMap的一个区别	

```java
ModelAndView model = new ModelAndView();
model.addObject("itemList", list);
model.setViewName("/WEB-INF/jsp/itemList.jsp");
return model;
```



### 13：Controller 作为参数

###### 1：ModelMap 作为 参数

###### public class ModelMap extends LinkedHashMap<String, Object>

ModelMap 对象主要用于传递控制方法处理数据到结果页面，也就是说我们把结果页面上需要的数据放到ModelMap对象中即可，他的作用类似于request对象的setAttribute方法的作用：用来在一个请求过程中传递处理的数据

```java
public ModelMap addAttribute (String attributeName, Object attributeValue) {...}
```

###### 2：Model

###### public class ExtendedModelMap extends ModelMap implements Model

**返回值 String 直接写跳转页面名**，用addAttribute（）添加们key-value





### 13：@RequestBody 和@ResponseBody 

**@RequestBody：**作用在形参列表上，用于将**前台发送过来固定格式的数据（json）转换为对应的 JavaBean 对象**，封装时使用到的一个对象是**系统默认配置的 HttpMessageConverter进行解析**，然后封装到形参上

**@ResponseBody ：**配置后返回的值直接作为**响应报文的报体返回**，不会被解析成跳转路径

```java
@RequestMapping("/login.do")
@ResponseBody
public ModelAndView login(@RequestBody User loginUuser, HttpSession session) {
    user = userService.checkLogin(loginUser);
    session.setAttribute("user", user);
    ModelAndView model = new ModelAndView();
		model.addObject("Object", new JsonObject.toString(user));
    return model;
}
```



