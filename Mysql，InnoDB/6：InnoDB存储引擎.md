### InnoDB：

​	MySQL 从 5.5 版本之后默认的存储引擎, 是第一个支持完整 ACID 特性的事务型存储引擎

------

##### 1：InnoDB 存储引擎体系架构：

![](https://github.com/likang315/Java-and-Middleware/blob/master/Mysql%EF%BC%8CInnoDB/InnoDB/InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png?raw=true)

###### 后台线程：

- 负责刷新缓存池中的数据，保证缓存池中的内存缓存的是最新的数据
- 将已经修改的数据文件刷新到磁盘文件，同时保证数据库在发生异常的情况下InnoDB能恢复到正常的运行状态

1. Master Thread：将内存数据异步刷新到磁盘，InnoDB 的主要工作都是该线程完成. 该线程具有最高的优先级
2. IO Thread：处理 IO 请求的回调
3. Purge Thread：在事务提交的时候回收 Undo Log
4. Page Clear Thread ：将脏页刷新操作都放入到单独的线程中来完成
   - 脏页：把数据库读出来的数据修改，还没有刷新到磁盘上

###### 缓冲池：innodb_buffer_pool

1. InnoDB 存储引擎是基于磁盘存储的，并将其中所有的记录按照页的方式进行管理. 由于CPU 和磁盘速度的鸿沟, 采用缓冲池技术来提高数据库的性能
2. 缓存池是一块内存区域, 在 DB 读取页的时候, 首先将从磁盘读到的页存放到缓存池中, 这个过程称为将页"FIX"在缓冲池中,下次再读相同页的时候先判断是否在缓冲池中. 对于写操作，**首先修改缓冲池中的页, 再以一定的频率刷新到磁盘上**，而不是每次发生页修改时触发，通过"CheckPoint 机制"，刷新会磁盘
3. 缓冲池的大小默认为 **256KB**， 使用LRU(最近最少使用)算法进行管理，InnoDB 对新读取的页会放在 midpoint  (默认5/8长度处)
4. 重做日志缓冲: InnoDB 首先将 Redo Log 日志放入这个缓冲区, 然后以一定的频率刷新到磁盘的 Redo Log 文件中
5. 缓冲池是通过 **LRU算法 ** 进行管理的，即最频繁使用的页放在LRU列表的前端，而最少使用的页放在LRU列表的尾端，首先应最先释放LRU列表的尾端的页

##### 2：InnoDB 关键特性

###### Insert Buffer：提高性能

​	在 InnoDB 中，主键是唯一的标识,在插入记录的顺序是按照主键递增的顺序进行.因此不需要磁盘的随机读取.在⼀般情况下, 不需要随机读取另⼀个页中的记录, 因此 InnoDB 如果采用**自增主键的方式**去插入速度会非常快.但与此同时，更多情况下表中除了主键以外还存在其他索引，此时的插入顺序依然是按照主键顺序存放, 对于非聚集索引的叶子节点的插入就不再是顺序的，此时就需要离散的访问非聚集索引页, 从而产生大量随机读取导致插入性能下降，因此对于非聚集索引的插入或者更新, 不是一次直接插入到索引页中, 而是先判断插入的非聚集索引页是否在缓冲池中, 如果在，直接插入, 否则先放入⼀个 **Insert Buffer** 对象,作为占位符，然后再以⼀定的频率进行 Insert Buffer 和 索引叶子节点的 merge 操作

###### 二次写（doublewrite）：提高数据页的可靠性

1. 第一部分：double write buffer，大小为 2M
2. 第二部分：物理磁盘上的共享表空间中连续的128个页，即两个区，大小同样为2M
   - 对缓冲池的脏页进行刷新时，并不直接写硬盘，而是通过**memcpy函数将脏页先拷贝到内存中的 double write buffer**，之后通过 **double write buffer 再分两次写**，每次写入1M到共享表空间的物理磁盘上，然后马上调用 fsync 函数，同步磁盘，避免缓冲写带来的问题

###### 自适应性哈希索引

​	哈希表是⼀种非常快的查找方式, 在⼀般情况下可以在 O(1) 复杂度内完成. 而 B+ 树普边需要3-4层,意味着在磁盘上进行3-4次查询，InnoDB 会监控表上各项索引页的查询, 如果**观察到适合建立哈希索引就会行动**, 因此被称为自适应性哈希索引(Adaptive Hash Index, AHI), AHI 通过索引页构造而来, InnoDB 会根据**访问的频率和模式**来自动为某些热点页建立 AHI

##### 3：日志文件

1. 错误日志(ErrorLog) 
   - 错误日志对 MySQL 的启动, 运行, 关闭过程进行了记录, 不仅**记录了所有错误信息，也记录了一些警告信息**，遇到问题是应该首先查看该文件以便定位问题. 当 MySQL 不能正常启动, 或者 MySQL 在运行期间遇到的内存不足等问题都可以在其中找到详细记录
2. 慢查询日志(SlowQueryLog) 
   - 慢查询日志能够定位到可能存在问题的 SQL 语句, 可以**设定一个阈值, 将运行时间超过该值的 SQL 语句都记录到慢查询**日志文件中 另一个可用的参数是 log_queries_not_using_indexes, 如果SQL 语句没有使用索引, 同样会将这条 SQL 语句记录到慢查询日志文件
3. 查询日志(QueryLog) 
   - 查询日志记录了所有对 MySQL 请求的信息（对数据库没有修改的数据）, 不论是否得到了正确的执行. 默认文件名: 主机名.log
4. 二进制日志(BinaryLog) 
   - BinLog **记录了对 MySQL 执行更改的 (不包括SELECT 和 SHOW 等对数据本身没有修改) 的操作.** 不过若⼀个修改操作本身没有导致数据库发生变化也会被写入 Bin Log 中(如修改了一条不存在的记录). 此外, 二进制日志还包括了DB 修改操作的时间以及其他额外信息
   - Bin Log 主要用途有: 
     1. 数据恢复（Recovery）：数据的恢复需要 BinLog
     2. 集群同步（Replication）：通过复制和执行 BinLog, 使一台远程的 MySQL 从库与当前主库进行实时同步
     3. 数据检查（audit）：可以通过BinLog信息，检查是否有对数据库注入的攻击

##### 4：InnoDB 表存储

​	在 InnoDB 中, 表都是根据主键顺序组织存放的, 这种存储方式成为索引组织表. 每张表都有一个主键, 如果没有显式指定, InnoDB 会使用第一个非空的唯一索引, 如果没有唯一索引, InnoDB 会自动创建一个 6 字节大小的指针作为主键

![](https://github.com/likang315/Java-and-Middleware/blob/master/Mysql%EF%BC%8CInnoDB/InnoDB/InnoDB%E5%AD%98%E5%82%A8.png?raw=true)

1. 表空间(TableSpace)：InnoDB 存储引擎逻辑存储的顶层对象,所有数据都存放在表空间. 其中包括数据, 索引, 插入缓冲, 回滚信息, 系统事务信息等
2. 段(Segment)：表空间是由多个段组成的, 常见的段有**数据段, 索引段, 回滚段等**. InnoDB 由于索引组织表的特点, 数据即索引, 索引即数据. 因此数据段是 B+ 树的叶子节点, 索引段是 B+ 树的非叶子节点
3. 区(Extent)：区是由连续页组成的空间, 在任何情况下每个区的大小都为 1MB, 为了保证区中页的连续性, InnoDB 一次从磁盘申请 4-5 个区, **默认情况下 InnoDB 页的大小为 16KB, 一个区中一共有 64 个连续的页** 
4. 页(Page)：InnoDB 最小磁盘单位，默认 16KB，常见的页有: 数据页 / undo log页 / 系统页
5. 行(Row)：InnoDB 中数据按行进行存放, 每页最多允许存放 16KB / 2 - 200 = 7992 行记录

###### InnoDB 数据页由七部分组成：

1. File Header(文件头)：固定 38 字节,用来记录头信息, 以及相邻页的指针 
2. Page Header(页头)： 固定 56 字节, 用来记录数据页的状态信息
3. Infinum 和 Suprenum Records：虚拟的行记录, 用来限定记录的边界
4. User Recodes(用户记录, 即行记录) 
5. Free Space(空闲记录) 
6. Page Directory(页目录)：存放记录的相对位置, 找到 B+ 树叶⼦节点后, 再通过Page Directory 再进行二分查
7. File Trailer(文件结尾信息)：固定 8 字节, 用于检测页是否已经完整地写入磁盘

##### 5：索引：

​	数据库对象之一，是为了提高查询效率，索引其实是就一张表，该表保存了主键与索引字段，并指向数据表中的记录，也是B+树，一页就是一个B+ 树，索引段和数据段

###### 1：聚集索引(主键索引)

- 聚集索引就是按照**每张表的主键构造⼀棵 B+ 树的非叶子结点,** 叶子节点中存放整张表的记录数据(数据页), 聚集索引的特性决定了索引组织表中数据也是索引的一部分, 每个数据都通过一个双向链表来进行连接
- 一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况,并且多数情况下查询优化器都倾向于采用聚集索引, 因为可以直接在其叶子节点上找到数据

###### 2：辅助索引

- 辅助索引：叶子节点不包括行记录的全部数据， **叶子节点除了包含键值以外, 每个叶子节点中还包含了一个指针, 指向聚集索引中的主键,** 然后再通过主键索引来找到一个完整的记录（存储了此索引到主键的一种映射关系）

###### 3：联合索引

- 联合索引也是一棵 B+ 树, 不同的是联合索引的键值数量大于2，此外, 逻辑上和单键值的 B+ 树并没有什么区别, 键值依旧是有序的,只不过这个有序是一个前提的: 遵循最左前缀匹配原则

![](https://github.com/likang315/Java-and-Middleware/blob/master/Mysql%EF%BC%8CInnoDB/InnoDB/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png?raw=true)

- 联合索引的规则：
  - 首先会对复合索引的最左边的，也就是第一个字段的数据进行排序，在第一个字段的有序基础上，然后再对后面第二个的字段进行排序，其实就相当于实现了类似 order by name,cid 这样一种排序规则
  - select * from stu where a=xx and b=xxx;

###### 4：覆盖索引 

- InnoDB 支持**直接从辅助索引中查询记录并返回**(如果有的话), 而不需要查询聚集索引中的记录，使用覆盖索引的好处是辅助索引不包含整行记录的所有信息, 故其大小要远小于聚集索引, 因此可以减少大量的 IO 操作
- 当只需要查询某个字段时

##### 6：索引失效

​	有时候在执行 EXPLAIN 查看SQL执行计划时, 发现优化器并没有选择索引，而是执行全表扫描，这种情况多发生于联合查询 JOIN 连接等场景

1. 联合索引的使用不符合最左前缀匹配原则
2. OR 条件连接的多个条件中有不走索引的字段
3. LIKE 查询前缀模糊匹配
4. InnoDB 出现隐式类型转换(varchar -> bigint)，避免where条件中出现隐式类型转换
5. InnoDB 评估使用全表扫描比走索引更快 
6. 在联合索引中不能有列的值为NULL，如果有，那么这一列对联合索引就是无效的，所以用特殊值代替

##### 7：索引的效率

- 查找效率高：因为索引表按照索引的字段是有序排列的，是一种有序读，而不是随机读
- 插入，删除效率低：当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度，而且索引也是非常消耗内存的
  1. 进行大量插入时，可以先删除索引，再插入，完成后再加索引
  2. 通过Insert Buffer，插入或者更新, 不是一次直接插入到索引页中, 而是**先判断插入的非聚集索引页是否在缓冲池中**, 如果在，直接插入, 否则先放入⼀个 Insert Buffer 对象,作为占位符，然后再以⼀定的频率进行 Insert Buffer 和 索引叶子节点的 merge 操作
  3. 读写分离：牛逼

##### 8：索引的使用策略

1. 什么列要使用索引：
   - 表的主键、外键必须有索引
   - 经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引
   - 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引
2. 什么列不要使用索引：
   - 经常增删改的列不要建立索引
   - 列中有大量的重复值不建立索引
   - 表记录太少不要建立索引

##### 9：索引的类型

- INDEX 普通索引：添加索引的字段，允许出现相同的值
- UNIQUE 唯一索引：不可以出现相同的值，可以有NULL值
- PRIMARY KEY 主键索引：不允许出现相同的值，且不能为NULL值，一个表只能有一个primary_key索引
- fulltext index：全文索引

######   创建索引

- CREATE INDEX：只能对表增加普通索引或UNIQUE索引
- CREATE INDEX index_name ON table_name (column_list)
- CREATE UNIQUE INDEX index_name ON table_name (column_list)

###### 修改索引：

- ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）'索引名'（字段名，字段名）
- ALTER TABLE 'table_name' ADD INDEX 'index_name' ('column_list')；
  -  索引名，可要可不要;如果不要，该字段名就是索引名

######   删除索引：

- ALTER TABLE 'table_name' DROP INDEX 'index_name'
- ALTER TABLE 'table_name' DROP PRIMARY KEY； 删除主键索引,注意主键索引只能用这种方式删除

######   查看索引：

- show index from tablename \G;


###### 强制使用某种索引

- FORCE INDEX （索引字段名）