### 1：数据库 的 基础知识

###### 数据库管理系统（DBMS）：管理数据库的软件

**关系数据库：**描述两个元素之间的关联或对应关系，表与表之间的关系

DB2数据库：关系型数据库 Microsoft SQL Server 数据库 MySQL数据库：小型关系型数据库管理系统，开源的，Oracle 旗下， c/c++编写的，64位系统支持最大的表文件为8TB Oracle数据库：学习的，商用收费，侵权

**数据库(Database)：**物理操作系统文件或其他形式的文件类型的集合

**实例（Instance）：**由后台线程和一个共享内存区组成，是真正用于操作数据库文件的

**数据表（Table）：**是关系数据库的基本存储结构，二维的，由行列组成的一张表格，一个关系型数据库由多个数据表组成

**记录（元组）：**数据表中的一行

**字段(属性)：**数据表中的一列

### 2：表间关系

###### 表与表之间存在关联关系，一对一，一对多，多对多 三种关系

主键（PRIMARY KEY）：其值能唯一地标识表中的每一行，作用是用于其他表的外键关联，以及本记录的修改与删除 外键(FOREIGN KEY) ： 存放另一个表中主键的值的字段来表示关联，它的值必须是其他表中已存在的值 例：FOREIGN KEY (dep_id) REFERENCES dep(id) )

### 3：数据库范式

**范式：建立科学的，规范的的数据库是需要满足一些规范**的来优化数据数据存储方式，在关系型数据库中这些规范就可以称为范式

### 三大范式

**第一范式：当关系模式的所有属性都不能在分解为更基本的数据单位时**，称R是满足第一范式的，简记为**1NF**

```
1：每一列属性都是不可再分的属性值
```

**第二范式：如果关系模式满足第一范式，并且关系模式的所有非主属性都完全依赖于关系模式的每一个候选关键属性**，满足第二范式，**简记为2NF**

每一行的数据只能与其中一列相关，即**一行数据只做一件事**。只要数据列中出现数据重复，就要**把表拆分开来**

例如：一个人同时订几个房间，就会出来一个订单号多条数据，这样子联系人都是重复的，就会造成数据冗余。我们应该把联系人单独存放一张表拆开来，而此表只存放联系人id

**第三范式：满足2NF，并且，消除传递依赖**，每个**非主属性都不传递**依赖于候选关键属性，满足第三范式，**简记为3NF**

例如：Student 表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）

这样一个表结构，就存在上述关系。 学号--> 所在院校 --> (院校地址，院校电话)

这样的表结构，我们应该拆开来

（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）

**BCNF模式**：即在**第三范式的基础上**，数据库表中**不存在任何属性对任一候选关键属性的传递函数依赖**

假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)

(仓库ID, 存储物品ID) →(管理员ID, 数量)

(管理员ID, 存储物品ID) → (仓库ID, 数量)

所以，**(仓库ID, 存储物品ID) 和 (管理员ID, 存储物品ID)**都是StorehouseManage的 候选关键属性

(仓库ID) → (管理员ID)

(管理员ID) → (仓库ID)

即存在关键字段决定关键字段的情况，所以其不符合BCNF范式

###### (1) 删除异常：

当仓库被清空后，所有"存储物品ID"和"数量"信息被删除的同时，"仓库ID"和"管理员ID"信息也被删除了

###### (2) 插入异常：

当仓库没有存储任何物品时，无法给仓库分配管理员

###### (3) 更新异常：

如果仓库换了管理员，则表中所有行的管理员ID都要修改

###### 把仓库管理关系表分解为二个关系表：

仓库管理：StorehouseManage(仓库ID, 管理员ID)

仓库：Storehouse(仓库ID, 存储物品ID, 数量)