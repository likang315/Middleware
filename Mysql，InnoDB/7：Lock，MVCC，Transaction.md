### Lock、MVCC、Transaction

------

##### 1：锁：数据库系统区别于文件系统的⼀个关键特性，用于管理对共享资源的并发访问

InnoDB 会在行记录上加锁，同时也会在内部其他地方使用，保证并发性和一致性

###### MySQL实现了两种标准的行级锁

1. 共享锁：事务读一行数据，读锁，可重复加锁
2. 排他锁：事务更新或删除一行数据 ，写锁，每次修改操作，默认时排它锁
   - 此外, **InnoDB 支持多粒度锁定**, 允许事务在行级别和表级别同时存在, 因此引出了意向锁(Intention Lock)
   - 意向锁意味着事务希望在更细粒度上进行加锁（行锁）

###### 锁的分类

1. 表锁：操作对象是数据表，没有走索引，全表扫描，加的是表锁
   - MySQL 大多数锁策略都支持，是系统开销最高但并发性最低的一个锁策略。事务对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行
2. 行级锁：操作对象是数据表中的一行
   - InnoDB 行锁：是通过**给索引上的索引项加锁来实现的**，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁（自动加），否则，InnoDB将使用表锁
   - 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是**访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的**
   - MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器
   - 行级锁对系统开销较大，但是处理高并发较好
3. 间隙锁（Next-Key 锁）
   - 当我们**用范围条件而不是相等条件检索数据**，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁
   - 对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）
   - 使用间隙锁的目的：
     1. 为了**防止幻读**，以满足相关隔离级别的要求，使用范围条件检索并锁定记录时，InnoDB这种**加锁机制会阻塞符合条件范围内键值的并发插入**
     2. 为了满足其恢复和复制的需要

###### 加锁方式：

- 自动加锁：**在InnoDB中，insert,update,delete 等语句执行时都会自动加解锁**，修改操作的锁会持有到事务结束，效率高很多
- 手动加锁：**select .... from table where 索引条件 for update**，在SQL语句中手动加锁，是一种悲观锁

###### 悲观锁、乐观锁

- 悲观锁：修改操作式，加的是悲观锁
- 乐观锁：MVCC，通过版本号，当前版本如果对应上了，就更新数据，否则就不会更新成功

##### 2：一致性非锁定读 (consistent nonblocking read) 

- 指InnoDB 通过**多行版本控制的方式来读取当前执行时间数据中的数据**，如果当前数据正在执行修改操作,这时读取操作不会被阻塞，而是去读取⼀个快照数据，通过Undo log 实现，快照数据就是当前行数据的历史版本,有多个版本
- 每行记录可能有多个版本，不同的隔离级别下，读取方式不同
  - REPEATABLE READ 下，一致性非锁定读总是读取事务**开始时的行版本数据（当前读）**
  - READ COMMITTED 下，一致性非锁定读总是读取被锁定行的**最新一份快照（快照读）**

###### MVCC：多版本并发控制技术

- 一行记录可能有多个版本，由此带来的并发控制，称之为MVCC
- MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞，对象 P 维护有多个版本，**每个版本会有一个读时间戳（Read TimeStamp, RTS）和 写时间戳（Write TimeStamp, WTS）**，事务 Ti 读对象 P 的最新版本，该版本早于事务 Ti 的读时间戳 RTS(Ti)
- MVCC 优缺点
  - 代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突，缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作

###### purge thread：

- 由于旧数据并不真正的删除，所以必须对这些数据进行清理（Undo Log），innodb 会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做 purge


##### 3：一致性锁定读

- 用户需要显示地对数据库读取操作进行加锁，保证数据逻辑的一致性
- InnoDB 支持两种一致性的锁定读加锁语句
  - SELECT .... FROM table WHERE 索引条件 FOR UPDATE；
    - 对读取的行加锁之后，其他事物不能对已锁定的行加锁
  - SELECT .... FROM table WHERE 索引条件 LOCK IN SHARE MODE；
    - 对读取的锁之后，其他事物可以对被锁定的行加相同的锁

##### 4：锁的问题：写的时候不加锁造成的

1:更新丢失：双写，解决办法是一个一个地写

1：回滚丢失：一个事务写的时候成功的时候，另一个事务写失败了，导致了回滚，读已提交解决

2：覆盖丢失：一个成功的事务，覆盖了另一个成功的事务的结果，可重复读解决

**2:脏读：**读到未提交的数据，解决办法是写完之后再读

**3:不可重复读：**同一事务的两次读操作取回不一致的结果,解决办法是写完再读

假如A在取款事务的过程中，B往该账户转账100，A两次读取的余额发生不一致

**4:幻读：**新增加了几条数据，前后读取条数不一致，解决办法是写完再读



### 9：死锁检测 (dead lock)

   解决死锁: 

###### 1：超时检测:

 设置一个阈值,当任意一方等待时间超过预设的阈值时, 其中⼀个事务回滚 

###### 2：for-graph 主动检测：

通过“等待获取的锁” 和 “等待获取该锁的事务”, 构造出⼀张有向图，如果图中存在回路, 就代表存在死锁, 一旦  发现回路, 就将其中一个回滚, 另⼀个事务就得以继续执行被回滚的事务会返回"dead lock"



### 10：事务：指的是满足 ACID 特性的任意一种操作

ACID：原子性(Atomic),一致性(Consistency)（数据库的角度）,隔离性(Isolation),和持久性（Durabiliy）

事务的隔离性由锁来实现, 原子性, 一致性和和 Undo Log 来完成，持久性由 Redo Log 实现
Redo Log 用于保障已提交事务的 ACID 特性, Undo log 用于保障未提交的事务不会对数据库的ACID 特性产生影响

### 11：事务实现

##### 1：Redo Log(重做日志）用来实现事务中的持久性, 由两部分组成：

​	内存中的重做日志缓冲(redo log buffer) 
​	磁盘中的重做日志文件(redo log file) 
 当事务提交的时候, 必须先将该事务的所有日志写入到磁盘中的重做日志文件进行持久化, 待事务提交结束才算完成

##### 2：Undo Log（回滚日志）记录了事务的行为, 可以很好的对页进行 "重做" 操作, 但事务有时候需要进行回滚

此时就需要undo log, redo log 存放在数据库内部的回滚段中, 位于共享表空间 

重做日志的主要工作是将数据库逻辑地恢复到原来的样子, 但数据结构和页本身在回滚之后可能和事务开始前不太相同, 因为与此同时有大量的并发事务存在, 不能简单的将一个页回滚到事务开始时的样子, 否则会影响其他事务，恢复行记录

Undo Log 的另一个功能是 MVCC，当需要读取的记录已经被其他事务加锁的时候, 当前事务可以通过 undo 读取之前的版本, 以此实现一致性非锁定读

### 12：事务隔离级别

​	隔离级别有 4 个，由低到高依次为 Read uncommitted、Readcommitted、Repeatable read、Serializable
​	最终解决了更新丢失，脏读，不可重复读，幻读
​	MySQL 的默认隔离级别：Repeatable read

###### 项目中一般用，读已提交 作为 默认的隔离级别

###### 主从复制的 bin log，有三种格式

1：statement：记录修改的Sql语句

2：row：记录每行记录实际数据的变更

3：mixed：两种混合模式

在statement格式下，读已提交这种隔离级别的主从复制，会出现错误的（master上执行先删后插，slave执行的是先插后删），会导致主从不一致，因此**用可重复读，在级别下引入了间隙锁**，或者选用 **row作为binlog的格式**

###### 若使用串行化，事务一个一个按顺序执行，每次读都会加锁，导致快照读失效

在读已提交的情况下，出现不可重复读的问题是可以接受的，因为毕竟你的数据已经提交了，读出来本身是没有太大区别的

### 13：回滚段

​	事务操作时，回滚段包含undo log，可以roolback ,如果事务提交, 回滚段中的 undo log 可以删除

### 14：当前读 和 快照读

在RR级别下，**快照读是通过MVVC(多版本控制)和undo log来实现的**，**当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的**

**在 rr 级别下：**MVCC完全**解决了重复读，但并不能真正的完全避免幻读**，只是在部分利用**历史数据规避了幻读**

对于快照读，mysql使用历史数据部分避免了幻读，若需完全避免，需要手动加锁将快照读调整为当前读（mysql 不会自动加锁），然后mysql使用next-key完全避免了幻读



### 15：主从复制

![主从复制.png](https://github.com/likang315/Java-and-Middleware/blob/master/6%EF%BC%9AMysql%EF%BC%8CInnoDB/InnoDB/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png?raw=true)

从库生成两个线程，**一个I/O线程，一个SQL线程**

主库会把通过**bin log 记录每次修改的记录**数据，**I/O 线程**去请求 主库 的bin log，主库会生成一个 **log dump 线程**，用来给从库 i/o线程传bin log，从库将得到的 **bin log日志写Relay log（中继日志） 文件中，SQL 线程，会读取Relay log文件中的日志**，并解析成具体操作，来实现主从的数据一致

##### 1：异步复制原理 ：

主库提交事务后，立即返回客户端，它的同步是有从库的I/O线程请求才传送 Bin log 的

##### 2：半同步复制原理：

主库在执行完客户端提交的事务后不是立刻返回给客户端，而是**等待至少一个从库接收到并写到relay log中才返回给客户端**，相对于异步复制，半同步复制提**高了数据的安全性，同时它也造成了一定程度的延迟**，这个延迟最少是一个TCP/IP往返的时间

#### 主从复制优缺点：

###### 1：灾容性好，用于故障切换，和恢复数据库

###### 2：读写分离，提供查询服务

###### 缺点：

1：从库**只有一个sql Thread**，主库写压力大，复制很可能延时，通过并行复制解决

#### 主从复制方式

###### 1：一主一从

###### 2：一主多从，读是在从库读取的

###### 3：主主复制

###### 4：多主一从

###### 5：联级复制