### 数据库连接池：Druid

------

​	将数据库连接（数据库实例）作为对象存储在内存中，当用户需要访问数据库时，从连接池中取出一个已建立的空闲连接对象，使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用，而连接的建立、断开都由连接池自身来管理，类似于线程池的概念

##### 1：javax.sql.DataSource（InterFace）

​	提供 DataSource 对象所表示的物理数据库的连接，作为 DriverManager工具的替代项，DataSource 对象是获取连接的首选方法

###### Java 实现数据库连接池操作

1. 实现 Javax.sql.DataSource 接口 
2. 调用 getConnection（）方法得到连接连接池的对象
3. 调用 Connection 的 close（），将连接放回连接池

通过连接池的参数来控制连接池中的**初始连接数、连接的上下限数以及每个连接的最大使用次数**

###### c3p0连接池：

1. 将c3p0的jar包加入classpath 
2. 在classpath中加入c3p0.properties
3.  实例化ComboPooledDataSource
4. ComboPooledDataSource.getConnection()；得到连接对象

###### druid连接池：

1. 加载 mysql-connector-java-5.1.20-bin 数据库驱动

2. 将 druid-1.1.10.jar 加入classpath

3. 在 classpath中加 入druid.properties

4. 实例化DruidDataSource

5. DruidDataSource.getConnection()；得到连接对象

   ```java
   private static DruidDataSource  ds = new DruidDataSource();
   	static {
   		try {
         //从配置文件中导入根据值导入
   			ResourceBundle res = ResourceBundle.getBundle("druid");
   			ds.setUrl(res.getString("url"));
   			ds.setDriverClassName(res.getString("driverClassName"));
   			ds.setUsername(res.getString("username"));
   			ds.setPassword(res.getString("password"));
   			ds.setFilters(res.getString("filters"));
   			ds.setMaxActive(Integer.parseInt(res.getString("maxActive")));
				ds.setInitialSize(Integer.parseInt(res.getString("initialSize")));
   			ds.setMaxWait(Long.parseLong(res.getString("maxWait")));
   			ds.setMinIdle(Integer.parseInt(res.getString("minIdle")));
   		} catch (Exception e) {
   			System.out.println("数据库加载异常");
   		}
   	}
   	
   public static void main(String[] args) throws Exception {
   		ResultSet rs = ds.getConnection().createStatement().executeQuery(
         "select * from person");
   		while(rs.next()) {
   			System.out.println(rs.getInt(1)+"\t"+rs.getString(2));
   		}
   }
   ```

###### java.sql

##### 	 2：Interface Connection：

- void commit()： 使所有上一次提交 / 回滚后进行的更改成为持久更改，并释放此 Connection 对象当前持有的所有数据库锁
- void rollback() ：取消在当前事务中进行的所有更改，并释放此 Connection 对象当前持有的所有数据库锁
- void setAutoCommit(boolean autoCommit) ：将此连接的自动提交模式设置为给定状态 （mysql为自动提交）

###### JDBC 本身不支持事务，它只是对数据库做了简单的封装，还是用的数据库的事务

```java
// 关闭mysql事务的自动提交
con.setAutoCommit(fasle); 
try {	
  // 写事务代码
  con.commit();
} catch(Exceptin e) {
  con.rollback();
} finally {
  con.close();
}
```

##### 3：CallableStatement：用于调用数据库的存储过程，函数的输出需要注册

存储过程：就 sql语句 写的一个函数（代码片段），有数据库的输入，也有数据的输出

```java
Delimiter //         //修改数据库分隔符
create procedure add_person(pname varchar(23),pwd varchar(45),page int(2),psex varchar(2),OUT counter int)
begin
insert into person(name,pwd,age,sex) values(pname,ppwd,page,psex);
select count(*) into counter from person;
End
//
Delimiter ;
```

##### 4：DbUtils：封装操作数据库的 updata，query，传 SQL 语句，参数即可执行

​	使用 Apache 的 commons 的 dbutils 的工具类包，封装了 ArrayListHandler，BeanListHandler，XXXHandler类ResultSetHandler 接口的实现类，实例化 QuenyRunner 类，即可使用

- import org.apache.commons.dbutils.QueryRunner;

###### Interface ResultSetHandler：把数据库记录封装成对象的处理器，其实现类：

- ArrayHandler：适合取1条记录，把结果集中的第一行数据转成对象数组。

- ArrayListHandler

- BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中

- BeanListHandler

- XXXhandler（）：T handle(ResultSet rs) 重写此方法，将结果集封装成对象

  ```java
  import java.sql.ResultSet;
  
  public interface ResultSetHandler<T> {
  	// 结果集封装成对象，重写其方法
  	public T handle(ResultSet rs);
  }
  ```


###### Class QueryRunner ：发送 SQL 语句的，相当于 PreparedStatement 对象 

- QueryRunner() 

- QueryRunner(DataSource ds)

- int[] batch(Connection conn, String sql, Object[][] params) 

  - 批处理执行SQL语句 

- int[] batch(String sql, Object[][] params) 

  - 批处理执行SQL语句

- query(String sql, ResultSetHandler rsh, Object... params)

- query(Connection conn, String sql, ResultSetHandler rsh, Object... params)

- update(Connection conn, String sql, Object... params)

- int update(Connection conn, String sql, Object param)

  ```java
  // 或者直接传入数据源DS
  QueryRunner run = new QueryRunner();
  Connection con = ds.getConnection(); 
  List<Person> list = run.query(con, "select * from person where id>?", new BeanListHandler<Person>(Person.class),1);
  
  Person p = run.query(con, "select * from person where id = ？", new BeanHandler<Person>(Person.class),1);
  
  Object[] list = run.query(con, "select * from person where id > ?", new ArrayHandler(),1);
  
  List<Object[]> list = run.query(con, "select * from person where id>?", new ArrayListHandler(),1);
  ```

```java
// 重写了DbUtils 的 query
public T query(String sql,ResultSetHandler<T> hand,Object...params) {
  T t = null;
  Connection con = null;
  try {
    con = ds.getConnection();
    PreparedStatement ps = con.prepareStatement(sql);
    if(null != params && params.length > 0) {
      for(int i = 0; i < params.length; i++) {
        ps.setObject(i+1, params[i]);
      }
    }
    ResultSet res = ps.executeQuery();
    // 将结果映射成对象，实现方法具体看是哪个类
    t = hand.handle(res);
  } catch (SQLException e) {
    System.out.println("Error_03:query 失败");
  }finally
  {
    try {
      con.close();
    } catch (SQLException e) {
      System.out.println("Error_04:query 连接断开失败");
    }
  }
  return t;
}
```

###### ArrayHandler、ArrayListHandler：通过结果集的元数据得到列数

构造：ArrayHandler() 、ArrayListHandler()

```java
// 通过 ResultSetMetadata 得到表的数据，通过取每一列的原数据来填充对象的属性
public class ArrayListHandler implements ResultSetHandler {
  @Override
  public List<Object[]> handle(ResultSet rs)  
    // 集合里面每一个元素是一个数组
    List<Object[]> list = new ArrayList<Object[]>();
    try {
      // 结果集的原数据
      ResultSetMetaData rmd = rs.getMetaData();
      while(rs.next()) {
        // 通过列数得知数组大小
        Object[] obj = new Object[rmd.getColumnCount()];
        for(int i = 0; i < rmd.getColumnCount(); i++) {
          // 通过列好获取值
          obj[i] = rs.getObject(i+1);
        }
        list.add(obj);
      }
    } catch (Exception e) {
      System.out.println("Error_01:ArrayListHandler 失败");
    }
    return list;
  }
}
```

###### BeanHandler, BeanListHandler：通过反射的得到所有属性，然后从结果街中取出赋值

构造： BeanHandler(Class<? extends T> type) BeanListHandler(Class<? extends T> type)

```java
public class BeanListHandler<T> implements ResultSetHandler {
  @Override
  public List<T> handle(ResultSet rs) {
    List<T> list = new ArrayList<T>();
    try {
      while(rs.next()) {
        // 重新创建了一个新实例
        T t = (T)classes.newInstance();
        // 得到所有属性名的集合
        Field [] allfiled = classes.getDeclaredFields();
        for(Field f:allfiled) {
          String fname=f.getName();
          f.setAccessible(true);
          f.set(t, rs.getObject(fname));
        }
        list.add(t);
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
    return list;
  }
}
```

###### xxxHandler：通过对象直接从结果集中取值

```java
// 通过集合存储对象，直接从结果集中 getXXX()
public class PersonHandler implements ResultSetHandler<List<Person>> {
	@Override
	public List<Person> handle(ResultSet rs) {		
		List<Person> list = new ArrayList<Person>();
		try {
			while(rs.next()) {
				Person p = new Person();
				p.setId(rs.getInt("id"));
				p.setName(rs.getString("name"));
				p.setAge(rs.getInt("age"));
				p.setSex(rs.getString("sex"));
				list.add(p);
			}
		} catch (SQLException e) {
			System.out.println("Error_01:personHandler 失败");
		}
		return list;
	}
}
```