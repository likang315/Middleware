### Lock、MVCC

------

##### 1：锁：数据库系统区别于文件系统的⼀个关键特性，用于管理对共享资源的并发访问

InnoDB 会在行记录上加锁，同时也会在内部其他地方使用，保证并发性和一致性

###### MySQL实现了两种标准的行级锁

1. 共享锁：事务读一行数据，读锁，可重复加锁
2. 排他锁：事务更新或删除一行数据 ，写锁，每次修改操作，默认时排它锁
   - 此外, **InnoDB 支持多粒度锁定**, 允许事务在行级别和表级别同时存在, 因此引出了意向锁(Intention Lock)
   - 意向锁意味着事务希望在更细粒度上进行加锁（行锁）

###### 锁的分类

1. 表锁：操作对象是数据表，没有走索引，全表扫描，加的是表锁
   - MySQL 大多数锁策略都支持，是系统开销最高但并发性最低的一个锁策略。事务对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行
2. 行级锁：操作对象是数据表中的一行
   - InnoDB 行锁：是通过**给索引上的索引项加锁来实现的**，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁（自动加），否则，InnoDB将使用表锁
   - 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是**访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的**
   - MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器
   - 行级锁对系统开销较大，但是处理高并发较好
3. 间隙锁（Next-Key 锁）
   - 当我们**用范围条件而不是相等条件检索数据**，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁
   - 对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）
   - 使用间隙锁的目的：
     1. 为了**防止幻读**，以满足相关隔离级别的要求，使用范围条件检索并锁定记录时，InnoDB这种**加锁机制会阻塞符合条件范围内键值的并发插入**
     2. 为了满足其恢复和复制的需要

###### 加锁方式：

- 自动加锁：**在InnoDB中，insert,update,delete 等语句执行时都会自动加解锁**，修改操作的锁会持有到事务结束，效率高很多
- 手动加锁：**select .... from table where 索引条件 for update**，在SQL语句中手动加锁，是一种悲观锁

###### 悲观锁、乐观锁

- 悲观锁：修改操作式，加的是悲观锁
- 乐观锁：MVCC，通过版本号，当前版本如果对应上了，就更新数据，否则就不会更新成功

##### 2：一致性非锁定读 (consistent nonblocking read) 

- 指InnoDB 通过**多行版本控制的方式来读取当前执行时间数据中的数据**，如果当前数据正在执行修改操作,这时读取操作不会被阻塞，而是去读取⼀个快照数据，通过Undo log 实现，快照数据就是当前行数据的历史版本,有多个版本
- 每行记录可能有多个版本，不同的隔离级别下，读取方式不同
  - REPEATABLE READ 下，一致性非锁定读总是读取事务**开始时的行版本数据（当前读）**
  - READ COMMITTED 下，一致性非锁定读总是读取被锁定行的**最新一份快照（快照读）**

###### MVCC：多版本并发控制技术

- 一行记录可能有多个版本，由此带来的并发控制，称之为MVCC
- MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞，对象 P 维护有多个版本，**每个版本会有一个读时间戳（Read TimeStamp, RTS）和 写时间戳（Write TimeStamp, WTS）**，事务 Ti 读对象 P 的最新版本，该版本早于事务 Ti 的读时间戳 RTS(Ti)
- MVCC 优缺点
  - 代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突，缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作

###### purge thread：

- 由于旧数据并不真正的删除，所以必须对这些数据进行清理（Undo Log），innodb 会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做 purge


##### 3：一致性锁定读

- 用户需要显示地对数据库读取操作进行加锁，保证数据逻辑的一致性
- InnoDB 支持两种一致性的锁定读加锁语句
  - SELECT .... FROM table WHERE 索引条件 FOR UPDATE；
    - 对读取的行加锁之后，其他事物不能对已锁定的行加锁
  - SELECT .... FROM table WHERE 索引条件 LOCK IN SHARE MODE；
    - 对读取的锁之后，其他事物可以对被锁定的行加相同的锁

##### 4：锁的问题：写的时候不加锁造成的

1. 更新丢失：双写，加行锁（独享锁），必须等待事物执行完成之后，另一个事物才可以进行
   1. 回滚丢失：一个事务写的时候成功的时候，另一个事务写失败了，导致了回滚，读已提交解决
   2. 覆盖丢失：一个成功的事务，覆盖了另一个成功的事务的结果，可重复读解决
2. 脏读：一个事物读到了另一个事物未提交的数据（脏数据）
3. 不可重复读：在第一个事物中两次读数据之间，由于第二个事物的修改，导致两次读到的数据不一致
   - 一般来说，不可重复读是可以接受的，因为读到的是已经提交的数据
   - Next-key 可以解决
4. 幻读：同一个事物，前后两次读取条数不一致

##### 5：死锁检测 (dead lock)

1. 超时检测：
   -  设置一个阈值，当任意一方等待时间超过预设的阈值时, 其中⼀个事务回滚 
   - innodb_lock_wait_timeout=50; 设置等待时间
   - innodb_rollback_on_timeout=on； 默认等待 50s，默认不回滚（off）
2. wait-for-graph 主动检测：
   - 通过“等待获取的锁” 和 “等待获取该锁的事务”之间，构造出⼀张有向图，如果图中存在回路, 就代表存在死锁, 一旦发现回路, 会选择undo 量最小的进行回滚, 另⼀个事务就得以继续执行，被回滚的事务会返回"dead lock"