### MySQL：底层原理

------

![](https://github.com/likang315/Java-and-Middleware/blob/master/Mysql%EF%BC%8CInnoDB/InnoDB/mysql%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png?raw=true)

##### MySQL 体系结构：八大模块

1. 数据库驱动：用于连接数据库，JDBC
2. 数据库连接池：管理数据库实例，Druid
3. 管理服务和工具组件：系统管理和控制工具
4. SQL 接口组件：接受用户的SQL语句，并且返回用户需要查询的结果
5. 语法分析器（Parse）：SQL命令传递到解析器的时候会被解析器验证和解析，是个脚本
6. 查询优化器：SQL语句在查询之前会使用查询优化器对查询进行优化
7. 缓冲组件：查询缓存
8. 插件式存储引擎：存储引擎是基于表的，不是基于数据库的

### 数据库读

##### 1：查询语句的执行过程（六步）

1. 客户端通过**TCP连接**发送连接请求到 mysql 连接器，连接器会对该请求进行权限验证及连接资源分配
2. 通过**命令分发器查询**是什么SQL语句，若是select语句，验证用户查询权限，查询缓存
   - 建立连接后客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条select语句，如果是，在开启查询缓存的情况下，先在查询缓存中查找该SQL是否完全匹配（就是拿着你的SQL和原始缓存的SQL比对），如果完全匹配，验证当前用户是否具备查询权限，如果权限验证通过，直接返回结果集给客户端，如果不匹配继续向下执行
3. 将SQL语句交给**查询分析器（Parse）作语法分析**，如果语法不对，就会返回语法错误中断查询
4. 将SQL语句传递给**预处理器**，检查数据表和数据列是否存在，解析别名看是否存在歧义等
5. SQL语句解析完成后，将语句传递给**优化器进行优化**（通过索引选择最快的查找方式），**并生成执行计划**
6. 执行器根据生成的执行计划去 open table，执行SQL语句，执行后会逐渐将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端

- TCP连接—>命令分发器—>查询分析器—>预处理器—>优化器—>查询存储引擎—>开表—>执行语句—>关闭表—>关闭连接

##### 2：SQL解析的开销

- SELECT	id,name,price FROM products WHERE id IN (1,2,3,4,......	30000);              1-2(S) 
- SELECT	id,name,price FROM products WHERE id = 1;				     2-3(S) 
- SELECT	id,name,price FROM products WHERE id = 30000;				     2-3(S)
- SELECT	id,name,price FROM products WHERE id =1 or id=2 …or id = 30000;	    8-10(S)

##### 3：数据库的大字段

- content text(2046)  NOT NULL 
- 查询开销大，会使 mysql 数据库的缓存失效，建议分表操作，把大字段单独存储一个表
- 查询影响大，严重时会触发热页换出

##### 4：InnoDB 自带的 cache

- 大小：256KB ,最大缓存16页(16 X 16)
- MySQL是以页面作为最小缓存单位，读每次返回的是一页数据

######   只要符合条件的数据都应该上缓存

1. 修改不频繁的数据
2. 查询频率较高，带有明显热点请求的数据
3. 非实时的数据，一致性要求不严苛的数据

##### 5：缓存造成的问题

1. 缓存命中：命中率低
2. 缓存穿透：cache中没有到磁盘中寻找
3. 缓存失效（雪崩）：LAR 算法，清除长时间未使用的页
4. 缓存和DB的不一致性：cache和磁盘中的数据不一致

##### 6：MySQL cache VS Redis

- MySQL cache VS redis 性能不同：Redis 的缓存空间大
- MySQL cache VS redis 命中对比：命中率，使用LAU算法，热点页置换

### 数据库写

##### 1：更新SQL语句执行

1. 客户端通过**TCP连接**发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配
2. 通过**命令分发器**判断其是否是一条更新语句，如果是，则直接发送给分析器
3. **分析器**，做语法分析，如果语法不对，就会返回语法错误中断执行
4. 将语句传递给**预处理器**，检查数据表和数据列是否存在，解析别名看是否存在歧义等
5. 将语句传递给**优化器进行优化**（通过索引选择最快的查找方式），**并生成执行计划**
   - 前五步读写一样
6. 进入存储引擎层（默认Innodb），去 **innodb_buffer_pool** 里面的 data dictionary 得到表得相关信息
7. 根据表信息去innodb_buffer_pool 里面的**lock info查看是否有相关的锁信息**，如果有则等待（因为要加排它锁），如果没有则加排它锁，更新 lock info
8. 读取相关数据页从 innodb_buffer_pool中（如果数据页本身就在缓存中，则不用从硬盘读取）
9. 将页中的**原始数据（快照）保存到undo log buffer** 回滚日志中
10. 在innodb_buffer_pool中将**相关页面更新，该页变成脏页**（脏页会定时的刷盘写入到所属表空间中）
11. 页面修改完成后，会把修改后的物理页面**保存到redo log buffer中**，redo log buffer会以相关参数定义的规则进行刷盘操作写入到redo tablespace中
12. 如果开启bin log，则更新数据的逻辑语句也会记录在**bin log_cache**中
13. 执行 commit 操作后，由于**要保证redo log与bin log的一致性，redo log采用两阶段提交方式**
14. 将**redo log buffer 刷盘**（innodb_flush_log_at_trx_commit=1），并将该事务的**redo log标记为prepare 状态**
15. **将 bin log_cache 数据刷盘**（sync_binlog=1），待bin log落盘完成，再将**redo log中该事务信息标记为commit**，释放相关锁资源，此时一个更新事务的操作已经完成，返回给客户端成功更新提示
16. 标记**undo log中该事务修改页的原始快照信息为delete**，当无其他事务引用该原始数据时(MVCC)，再将其删除

##### 2：数据库写负载的连锁反应

1. 大量数据写入时，DB禁止一切写操作，强制刷盘
2. 热点数据的频繁写入，严重的 mutex (排他锁)争用，数据库雪崩效应
3. 数据库选择：关系型数据库不适合频繁的更新的场景，数据持久化的压力、数据库锁(mutex)竞争压力

##### 3：死锁和锁超时

​	InnoDB 锁超时默认需要**等待 5s 超时**，死锁马上就被发现，然后被  DB 自动回滚

##### 4：单机服务器的局限

1. 读写分离，只读表和会被写的表分离
2. 分布式
   - 垂直拆分：把新功能逻辑放到独立的新库里去
   - 水平拆分：数据库存储出现瓶颈，就分表存储

##### 5：分库分表操作

1. 垂直划分：基于数据库中的 "列" 进行
   - 把关联度较低的字段，或者大字段放入另一个表中
2. 水平划分：将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果
   - 按照时间区间（早上，下午）或ID区间来切分
   - 一般采用 hash 取余 mod 的切分方式

##### 6：分布式数据库的困扰

1. 业务处理
   - 复杂SQL支持不了，多表查询范围
   - SQL返回结果的不准确性
2. 分布式事务
   - 分布式事务的实现
   - 分布式事务的性能

##### 7：分布式事务

- 采用：两阶段提交，存在组织者和参与者
  - 第一阶段：组织者通知所有参与者约定时间
  - 第二阶段：组织者通知所有参与者可以提交

##### 8：数据库并发场景

1. 读多写少：可以把锁去掉，最大化并发，但带来的数据完整性的破坏，无缓存，但会产生脏读
2. 写多读少、超高并发：一条记录一个锁，把锁的粒度降低
3. 可以通过签名的方式保证数据的完整性，实现无锁缓存

##### 9：MySQL事务

​	MySQL中只有使用了 Innodb 数据库引擎才支持事务，事务默认自动提交的

- BEGIN、START TRANSACTION; 显式地开启一个事务
- COMMIT; 提交事务，并使已对数据库进行的所有修改成为永久性的
- ROLLBACK; 回滚结束用户的事务，并撤销正在进行的所有未提交的修改
- SET TRANSACTION；用来设置事务的隔离级别
- SET AUTOCOMMIT=0；禁止自动提交 
- SET AUTOCOMMIT=1；开启自动提交