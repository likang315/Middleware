##### 泛型：即：参数化类型-----给类加参数,达到动态的确定类型的目的，是当前类的属性的类型 

​      也可使用Object类使用多态达到泛型的应用，向下造型
​      将方法参数的类型以及方法返回值的类型的定义权交给了使用者。使用者在创建当前类的同时将泛型的实际类型传入

### JVM泛型的擦除机制：

Java中的泛型，只在编译阶段有效，泛型信息不会进入到运行时阶段。
在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法

##### 通配符：?         -----------------通配符用来表未知类型

上下边界问题

```java
？extends E 名为：向上限定，？代表E及其子类，也可以称之为：泛型固定上边界
	因此你做添加操作的时候,你只知道,你添加数据的上限。但是你无法确定你要添加数据的下限，因此无法添加数据
？super E 向下限定，？代表E及其父类(泛型固定下边界)在做添加的时候是不会有问题的
	因为：泛型的下边界,已经限制。再向集合中添加数据,只能是其本身或者他的子类
```



##### 泛型（类，抽象类，接口）：

###### 泛型类，在实例化类的时候指明泛型的具体类型

###### 	泛型方法，在调用方法的时候指明泛型的具体类型

```java
泛型类：public static class Person<T>
	 {  
			private T ob; 			// 定义泛型属性  

  			public Person(T ob) {  
       					this.ob = ob; 
					    } 
   		} 	 
例：
	Person<Integer> intOb = new Person<Integer>(100);  //T的实际类型是整型
```

###### 泛型接口：

```java
public interface Animal <T>{

}
```

​	1:当实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中

​	例：
​		public class Aa<T> implements Animal<T>{

​		}

​	2:实现泛型接口的类，传入泛型实参时，则所有使用泛型的地方都要替换成传入的实参类型

​	例：
​		public class Aa implements Animal<String>{

​		}

##### 泛型方法：public <T> void method(E e );

public 与 返回值中间<T>非常重要，可以理解为声明此方法为泛型方法，只有声明了<T>的方法才是泛型方法，
泛型类中的使用了泛型的成员方法并不是泛型方法

##### 用来调用时，传递泛型的，如果使用泛型要将整个类泛型化，那么就应该使用泛型方法

​	
注意：
​	1：泛型的类型参数只能是类类型，因为传递的是对象
​	2：泛型的类型参数可以有多个
​	3：不能对确切的泛型类型使用 instanceof 操作
​	4：不能创建一个确切的泛型类型的数组， 而使用通配符创建泛型数组是可以的
​		例:List<?>[] ls = new ArrayList<?>[10];  












