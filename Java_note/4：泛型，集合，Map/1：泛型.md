### 泛型：参数化类型 ----- 给类加参数，达到动态的确定类型的目的

### JVM泛型的擦除机制：

Java中的泛型，只在编译阶段有效，泛型信息不会进入到运行时阶段
在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加**类型检查和类型转换的方法**

##### 通配符：?   ----------------- 通配符用来表未知类型

### 上下边界问题

```java
？extends E 名为：向上限定，？代表E及其子类，也可以称之为：泛型固定上边界
	因此你做添加操作的时候,你只知道,你添加数据的上限。但是你无法确定你要添加数据的下限，因此无法添加数据
？super E 向下限定，？代表E及其父类(泛型固定下边界)在做添加的时候是不会有问题的
	因为：泛型的下边界,已经限制。再向集合中添加数据,只能是其本身或者他的子类
```



### 泛型（类，抽象类，接口）：

##### 泛型类：在实例化类的时候指明泛型的具体类型

```java
泛型类：public static class Person<T>
	 {  
			private T ob; 			// 定义泛型属性  

  			public Person(T ob) {  
       					this.ob = ob; 
					    } 
   		} 	 
例：
	Person<Integer> intOb = new Person<Integer>(100);  //T的实际类型是整型
```

##### 泛型接口：

```java
public interface Animal <T>{

}
```

​1:当实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，**需将泛型的声明也一起加到类中**

​	例：
​		public class A<T> implements Animal<T>{

​		}

2:实现泛型接口的类，传入泛型实参时，则**所有使用泛型的地方都要替换成传入的实参类型**

​	例：
​		public class A  implements Animal<String>{

​		}

##### 泛型方法：public <T> void method(E e ) ;

public 与 返回值中间<T>非常重要，可以理解为**声明此方法为泛型方法，只有声明了<T>的方法才是泛型方法，**
泛型类中的使用了泛型的成员方法并不是泛型方法

​	
注意：
​	1：泛型的类型参数只能是**类类型，因为传递的是对象**
​	2：泛型的类型参数可以有多个
​	3：不能对确切的泛型类型 使用 instanceof 操作
​	4：不能创建一个确切的泛型类型的数组， 而使用通配符创建泛型数组是可以的
​		例:List<?>[] ls = new ArrayList<?>[10];  




