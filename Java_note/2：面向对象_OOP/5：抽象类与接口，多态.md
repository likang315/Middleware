
抽象类,接口,普通类

### 抽象类：普通的Java类再抽象一步，得到更抽象的模板，其不能实例化，该类就是一个抽象类-----被继承的

意义：	1：可以提高代码的灵活性，使得编程变得更加通用
	2：包含所有公共的属性和行为，被子类所共享
	3：为子类提供一种公共的类型--向上造型时类型相同，方便操作
	4：包含抽象方法，给所有子类提供提供一个入口

声明语法：
	public abstract class 类名{ 类体}
	

类体： 属性，方法(实例及静态方法、抽象方法)，构造方法(用来初始化其属性)......主要是抽象方法

抽象方法：（实质就是父类给子类定义的功能，增强代码的可塑性）

​	public abstract 返回值类型 方法名称(参数列表);--------只有声明

抽象方法存在的意义： 用来被子类重写的

抽象类与抽象方法的关系：
		抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类

​	一个子类继承了一个抽象的父类，要么实现父类中的抽象方法，要么将自己变成抽象类（二选一，必须的）

修饰符abstract(抽象) 注意：
			1：不能修饰常量
			2：不能修饰静态
			3：不能修饰final修饰的方法及类，final不能被重写和继承
			4：主要用来修饰类和方法



## 接口：定义标准，用interface定义，不能被实例化，其实现类用来遵守标准

意义：为了解决抽象类单继承的缺陷，而出现特殊的抽象类（接口）----是用来被实现的

声明语法：	
	public inteface 接口名称 {接口体}
	

接口体：
	静态的常量，抽象方法
实现接口：
	public class 实现类 implements 接口名称{}
	public class 实现类 extends 抽象类 implements 接口列表{}
	public inteface 接口名称 extends 接口列表{接口 继承了好几个接口}

注意：
	接口的成员都是public的，方法是abstract(可有可无)的，必须重写其方法

接口应用：
	面向接口编程，其实质是使用接口进行架构搭建，具体功能需要做具体实现先继承后重写



## 多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量

​      所指向的具体实例对象的方法，而不是引用变量的类型中定义的方法

多态分为编译时的多态的和运行时的多态

方法的重载(overload)实现是编译时的多态性（前绑定）
方法的重写(override)实现的是运行时的多态性（后绑定）


	注意：
	2：多态环境下，子父类之间出现同名的属性时，访问父类
	3：多态环境下，访问同名方法时，访问的子类的
	4：多态环境下，访问同名静态的方法时，访问父类
	5：多态环境下，父类不能访问子类新扩展的方法


	多态应用：
		1：返回值类型的应用
		2：多态参数的应用

注意：父类不能访问子类新扩展的方法？那如果需要访问怎么办？-----类型转换（多态环境下的对象造型）

前提：必须有继承或者实现关系

父类的类型   父类引用  =  new 子类构造方法    ------父类的引用指向子类的对象   向上造型

子类的类型   子类的引用  = （子类类型）父类的引用；------向下造型

向下造型目的就是为了使得父类能够访问子类新扩展的方法；	

instanceof操作符的应用:

```java
多态参数的应用
public void hh(JTGJ j){//特定参数执行特定方法
	//开发中为了正常的进行向下造型，必须先进行指向的确定
	避免ClassCastException
	 if(j instanceof BB){
		 BB b = (BB)j;
		 b.stop();
	 }
	 if(j instanceof BMW){
		 BMW b = (BMW)j;
		 b.stop();
	 }
	 if(j instanceof QQ){
		 QQ b = (QQ)j;
		 b.stop();
	 }
}

多态返回值类型的应用：
public JTGJ creat(String name) {
	if("QQ".equals(name)) {
		return new QQ();	
	}
	if("BMW".equals(name)) {
		return new BMW();
	}
	return null;
}


```






​	
​	