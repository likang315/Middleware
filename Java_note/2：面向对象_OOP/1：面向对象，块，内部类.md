
来自哲学的问题 

面向对象的思想：要把预处理的问题抽象为对象，然后分析对象的属性与方法，把他们抽象出来，最后得到的范围，也就是类

面向对象的设计三大特点：封装，继承，多态

五大原则是"单一职责原则"、"开放封闭原则"、"里氏替换原则"、"依赖倒置原则"、"接口分离原则"

###### 单一职责原则SRP(Single Responsibility Principle)：是指一个类的功能要单一，不能包罗万象

###### 开闭原则OCP(Open－Close Principle)：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的

###### 接口分离原则ISP(the Interface Segregation Principle ISP)：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

###### 里式替换原则LSP(the Liskov Substitution Principle LSP)：子类应当可以替换父类并出现在父类能够出现的任何地方

###### 依赖倒置原则DIP(the Dependency Inversion Principle DIP)：具体依赖抽象，上层依赖下层

### 高内聚，低耦合

对象是现实世界中真实存在的实体，有两部分组成：静态部分+动态部分

## 对象：属性 + 方法

类：把具有共同属性和共同方法的多个对象称为一个类

类实质上就是封装对象的属性和方法的载体，而对象是类的实例化

注意：类是Java程序的基本编程单位

对象与类之间的关系：类是对象的抽象，对象是类的实例化（具体体现）



创建：先创建类---创建对象---- 对象调用方法---运行

为什么要有类----为了封装对象的属性和方法----为了使用对象的功能（方法）

创建对象的语法 ： 自定义类型   引用变量名； //引用变量的声明（引用数据类型的应用）

引用变量名  = new 该类的构造方法；  //对象的创建与赋值（把对象的地址赋值给引用变量）

自定义类型  引用变量名 = new  构造方法（）;  --------- 表示对象的引用

对象就是用来封装其方法执行时所要用到的数据----- 通过属性封装数据

##  对象的比较：

“==”  : 地址的比较

“equal”:没有重写和 == 一样，重写之后比较的是内容



##  类的创建语法：【访问权限修饰符】 【修饰符】 class  类名{   //类体   }

类体：
	类变量(静态变量)

属性：(成员变量，全局变量) 其是用来封装该类中方法所需要的数据
声明语法：【访问权限修饰符】【修饰符】数据类型 变量名；
成员属性有默认值：整型0，浮点型0.0，char是空 ，boolean：false
引用数据类型默认值是：NULL

静态属性--通过类名.静态变量来访问

## 方法：是具有特定功能的指令和数据的集合

声明语法：【访问权限修饰符】【修饰符】 返回值类型  方法名（形参列表）{ //方法体     }
局部变量：为该方法特定的提供服务的变量
	  注意：局部变量没有默认值，使用之前必须进行初始化（赋初值）

​                                  类名
构造方法：【访问权限修饰符】 方法名（形参列表）{ //方法体     }
注意：属于类，没有修饰符，返回值类型，方法名和类名相同，只伴随new关键字出现，自动调用

  	      如果类中没有构造方法时，jvm会默认的提供一个无参的构造方法，当你自己写出构造方法时就不再默认提供，
	      就需要自己写一个无参的构造方法，否则使用继承时会报错



方法分为：
	实例方法：用实例中的数据产生不同结果的方法
	静态方法：不用实例中的数据，每个对象调用产生同样的结果
	native方法：不是用Java编写的而是用c或者c++编写的

构造方法作用：
		1：创建对象
		2：对对象的属性进行初始化



## 类的高级特性应用：块和内部类

块:(类块，方法块）在大括号中的代码
实例块     {   //实例块代码        }

特点：实例块是在创建对象之前，默认去访问的代码块，每创建一个对象都会去默认执行，多个实例块按照声明顺序执行
（创建那个对象，就执行那个类的实例块）

静态块  static {   //静态块代码     }

特点：在main方法之前执行，用栈去加载

注意：如果在执行类时，希望先执行类的初始化动作，可以使用 static 定义一个静态块

同步块synchronized(class对象){ }
fianlly 块 finally{}


外围类   

## 静态嵌套类 (Static Nested Class) 和内部类(Inner Class)

静态内部类：static，它不依赖于外部类实例被实例 ，new一个静态内部类不需要外部类成员
静态内部类对象的创建：外围类名.内部类名  内部类变量名  = new 外围类类名.内部类的构造方法

内部类：需要在外部类实例化后才能实例化，分为普通内部类，局部内部类，匿名内部类
	静态方法中没有 this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如若直接创建必须按照指定的格式

普通内部类：存在于一个类中的类，它里面可以有类体的所有元素，但是都不能被static修饰，能访问外围类中的所有元素
普通内部类对象创建格式：外围类名.内部类名  内部类变量名 = new 外围类的构造方法.new 内部类的构造方法

局部内部类：作用在一个方法中的内部类
      注意：局部内部类只能访问其所在方法中final所修饰的变量
通过创建外围类的对象，调用外围类的方法，来执行局部内部类的的方法


匿名内部类：匿名内部类就是没有名字的局部内部类，不使用关键字class, extends, implements, 没有构造方法
	    使用时:如果想创建一个类的对象，并且该类只用一次

　　　　　　a·只用到子类的一个实例
　　　　　　b·类在定义后马上用到
　　　　　　c·匿名内部类不能有构造方法
　　　　　　d·匿名内部类不能定义任何静态的成员、方法和类
　　　　　　f·只能创建匿名内部类的一个实例
　　　　　　g·一个匿名内部类一定是在 new 的后面，用其隐含实现一个接口或实现一个类

注意：匿名内部类的两种实现方式：
	1：继承一个类，重写其方法；
	2：实现一个接口，实现其方法。

```java
//Object的子类

 	   new Object(){
            	void show(){
                  System.out.println("show run");                
            	}
           }.show();
```

​         

```java
//创建一个子类，没有名字， 创建子类的对象，引用叫obj,大括号为子类类体
     Object obj = new Object(){
         void show(){
            System.out.println("show run");
         }
     };
     obj.show();
```


​		

### 创建对象的5 中方式

![](G:\Java\Java_note\2：面向对象_OOP\创建对象的5 中方式.jpg)

###  访问对象的两种方式

reference类型数据来作为对象内存数据的引用，但JVM规范没有定义这个引用应该通过何种方式定位、访问堆上的对象，也没有不强制规定对象的内部结构应当如何表示；    

###### 1：使用句柄

Java堆划分一块内存作为句柄池，reference中存储就是对象的句柄地址；

对象句柄包含两个地址：

在堆中分配的对象实例数据的地址

方法区的对象类型数据地址

###### 2：使用直接指针

​       reference 中存储就是在堆中分配的对象实例数据的地址；而对象实例数据中需要有这个对象类型数据的相关信息（方法区）




