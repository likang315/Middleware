
来自哲学的问题 

### 面向对象的思想：

要把预处理的问题抽象为对象，然后分析对象的属性与方法，把他们抽象出来，最后得到的范围，也就是类

### 面向对象的设计三大特点：封装，继承，多态

五大原则是"单一职责原则"、"开放封闭原则"、"里氏替换原则"、"依赖倒置原则"、"接口分离原则"

###### 单一职责原则SRP(Single Responsibility Principle)：是指一个类的功能要单一，不能包罗万象

###### 开闭原则OCP(Open－Close Principle)：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的

###### 接口分离原则ISP(the Interface Segregation Principle ISP)：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

###### 里式替换原则LSP(the Liskov Substitution Principle LSP)：子类应当可以替换父类并出现在父类能够出现的任何地方

###### 依赖倒置原则DIP(the Dependency Inversion Principle DIP)：具体依赖抽象，上层依赖下层



### 高内聚，低耦合

对象是现实世界中真实存在的实体，有两部分组成：静态部分+动态部分

### 对象：属性 + 方法

### 类：把具有共同属性和共同方法的多个对象称为一个类

类实质上就是封装对象的属性和方法的载体，而**对象是类的实例化**

###### 注意：类是Java程序的基本编程单位

对象与类之间的关系：类是对象的抽象，对象是类的实例化（具体体现）

创建：先创建类---创建对象---- 对象调用方法---运行

为什么要有类----为了封装对象的属性和方法----为了使用对象的功能（方法）

### 创建对象的语法 ： 

###### 自定义类型   引用变量名； //引用变量的声明（引用数据类型的应用）

引用变量名  = new 该类的构造方法；  //对象的创建与赋值（把对象的地址赋值给引用变量）

自定义类型  引用变量名 = new  构造方法（）;  --------- 表示对象的引用

对象就是用来封装其方法执行时所要用到的数据----- 通过属性封装数据



### 类的创建语法： 访问权限修饰符     修饰符     class  类名    {   //类体   }

类体：
	类变量(静态变量)

属性：(**成员变量，全局变量**) 其是用来封装该类中方法所需要的数据

###### 声明语法：【访问权限修饰符】【修饰符】数据类型 变量名；

###### 成员属性有默认值：整型0，浮点型0.0，char是空 ，boolean：false

###### 引用数据类型默认值是：null



### 方法：具有特定功能的指令和数据的集合

###### 声明语法：【访问权限修饰符】【修饰符】 返回值类型  方法名（形参列表）{ //方法体     }

局部变量：为该方法特定的提供服务的变量
	  注意：局部变量没有默认值，使用之前必须进行初始化（赋初值）

​                                  

###### 构造方法：访问权限修饰符      方法名（形参列表）{ 方法体     }

注意：属于类，没有修饰符，返回值类型，方法名和类名相同，只伴随 new 关键字出现，自动调用

如果类中没有构造方法时，jvm会默认的提供一个无参的构造方法，当你自己写出构造方法时就不再默认提供，
就需要自己写一个无参的构造方法，否则使用继承时会报错

构造方法作用：
		1：创建对象
		2：对对象的属性进行初始化

#### 方法分为：

###### 	实例方法：用实例中的数据产生不同结果的方法

###### 	静态方法：不用实例中的数据，每个对象调用产生同样的结果

###### 	native方法：不是用Java编写的而是用c或者c++编写的



### 类的高级特性应用：块    和   内部类

#### 块：(类块，方法块）在大括号中的代码

实例块  {   //实例块代码  }

特点：实例块是在创建对象之前，默认去访问的代码块，每创建一个对象都会去默认执行，多个实例块按照声明顺序执行
（创建那个对象，就执行那个类的实例块）

###### 静态块  static {   //静态块代码 }

特点：在main方法之前执行，类的初始化

注意：如果在执行类时，希望先执行类的初始化动作，可以使用 static 定义一个静态块

同步块synchronized(class对象){ }
fianlly 块 finally{}

### 外围类

### 静态内部类 (Static Nested Class)  和  内部类(Inner Class)

##### 静态内部类：

​	static，它不依赖于外部类实例被实例 ，new一个静态内部类不需要外部类成员
静态内部类对象的创建：外围类名.内部类名  内部类变量名  = new 外围类类名.内部类的构造方法

##### 内部类：

需要在外部类实例化后才能实例化**，分为普通内部类，局部内部类，匿名内部类**
静态方法中没有 this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如若直接创建必须按照指定的格式

###### 普通内部类：

存在于一个类中的类，它里面可以有类体的所有元素，但是都不能被static修饰，能访问外围类中的所有元素
**普通内部类对象创建格式：外围类名.内部类名  内部类变量名 = new 外围类的构造方法.new 内部类的构造方法**

###### 局部内部类：

**作用在一个方法中的内部类**
注意：局部内部类只能访问其所在方法中final所修饰的变量
通过创建外围类的对象，调用外围类的方法，来执行局部内部类的的方法

###### 匿名内部类：就是没有名字的局部内部类，不使用关键字class, extends, implements, 没有构造方法

使用时：**如果想创建一个类的对象，并且该类只用一次**
　　　　　　b·类在定义后马上用到
　　　　　　c·匿名内部类不能有构造方法
　　　　　　d·匿名内部类不能定义任何静态的成员、方法和类
　　　　　　f·只能创建匿名内部类的一个实例
　　　　　　g·一个匿名内部类一定是在 new 的后面，用其隐含实现一个接口或实现一个类

##### 注意：匿名内部类的两种实现方式：

​	1：继承一个类，重写其方法
​	2：实现一个接口，实现其方法

```java
//Object的子类

 	   new Object(){
            	void show(){
                  System.out.println("show run");                
            	}
           }.show();
```

​         

```java
//创建一个子类对象，没有名字， 创建子类的对象，引用叫obj,大括号为子类类体
     Object obj = new Object(){
         void show(){
            System.out.println("show run");
         }
     };
     obj.show();
```


​		

### 创建对象的5 中方式

![创建对象的5 中方式.jpg](https://github.com/likang315/Java/blob/master/Java_note/2%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1_OOP/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%845%20%E4%B8%AD%E6%96%B9%E5%BC%8F.jpg?raw=true)

###  访问对象的两种方式

reference类型数据来作为对象内存数据的引用，但JVM规范没有定义这个引用应该通过何种方式定位、访问堆上的对象，也没有不强制规定对象的内部结构应当如何表示；    

###### 1：使用句柄池

Java堆划分一块内存作为句柄池，reference中存储就是对象的句柄地址；

**对象句柄包含两个地址：**

在堆中分配的对象实例数据的地址

方法区的对象类型数据地址

###### 2：使用直接指针

reference 中存储就是在**堆中分配的对象实例数据的地址**；而对象实例数据中需要有这个对象类型数据的相关信息（方法区）




