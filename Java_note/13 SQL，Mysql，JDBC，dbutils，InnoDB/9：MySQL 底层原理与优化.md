
数据库读

1：数据库查询开销
    以MySQL的InnoDB存储引擎为例		       (EXPLAIN）							
     建立TCP连接(三握)-->验证用户-->SQL解析-->生成执行计划-->开表-->搜寻buffer看所需数据页是否被缓存-->从磁盘扫描数据(time)
     -->获取数据并写入buffer pool-->返回数据给客户端-->关闭表-->关闭线程-->关闭连接(四挥)

2：SQL解析的开销
	SELECT	id,name,price FROM products WHERE id IN	(1,2,3,4,......	30000);              1-2(S) 
	SELECT	id,name,price FROM products WHERE id = 1;				     2-3(S) 
	SELECT	id,name,price FROM products WHERE id = 30000;				     2-3(S)
	SELECT	id,name,price FROM products WHERE id =1	or id=2	…or id	= 30000;	     8-10(S)

3：数据库查询开销
	如果你的查询条件索引不是主键：辅助索引(存储索引字段到主键的映射关系)-->回表-->聚集索引

4：数据库的大字段
	content varchar(2046) NOT NULL 
	
	查询开销大，会使mysql数据库的缓存失效，建议分表操作，把大字段单独存储一个表
	查询影响大，严重时会触发热页换出

5：MySQL自带的cache
	大小：256KB ,最大存储16页(16 X 16)
	MySQL是以页面作为最小缓存单位，读每次返回一页的数据

  只要符合条件的数据都应该上缓存
	1：修改不频繁的数据
	2：查询频率较高，带有明显热点请求的数据
	3：非实时的数据，一致性要求不严苛的数据
	
6：缓存造成的问题
	1：缓存命中：命中率低
	2：缓存穿透：cache中没有到磁盘中寻找
	3：缓存失效：LAR算法，清除长时间未使用的页
	4：缓存和DB的不一致性：cache和磁盘中的数据不一致

7：使用别的cache
	MySQL cache VS redis 性能不同：Redis的缓存空间大
	MySQL cache VS redis 命中对比：命中率，使用LAU算法，热点页置换



数据库写

8：数据库写
	先写到cache中，还有缓冲日志，然后再写到磁盘中的缓冲文件，此时事务提交返回，然后会自检磁盘和缓冲日志版本是否一致

9：数据库写负载的连锁反应
	1：大量数据写入时，DB禁止一切写操作,强制刷盘
	2：热点数据的频繁写入，严重的mutex(互斥锁)争用，数据库雪崩效应

   数据库选择：关系型数据库不适合频繁的更新的场景，数据持久化的压力、数据库锁(mutex)竞争压力

10：死锁和锁超时
	InnoDB锁超时默认需要等待 5s 超时,死锁马上就被发现，然后被DB自动回滚
	
11：单机服务器的局限
	常见的拆分方案
	• 读写分离，只读表和会被写的表分离
	• 分布式
		垂直拆分
			把新功能逻辑放到独立的新库里去
		水平拆分
			数据库存储出现瓶颈，就分表存储

12：分布式数据库的困扰
	1：业务处理
		复杂SQL支持不了，多表查询范围
		SQL返回结果的不准确性
	2：分布式事务
		分布式事务的实现
		分布式事务的性能

13：分布式事务
	采用：两阶段提交，存在组织者和参与者
	第一阶段：组织者通知所有参与者约定时间
	第二阶段：组织者通知所有参与者可以提交

14：数据库并发场景

 1：【读多写少】：可以把锁去掉，最大化并发，但带来的数据完整性的破坏，无缓存，但会产生脏读

 2）【写多读少】，【超高并发】：可以通过Map转Array的方式来最小化锁冲突，一条记录一个锁，把锁的粒度减小

 3）可以通过签名的方式保证数据的完整性，实现无锁缓存




