## InnoDB：

## 是 MySQL 从 5.5 版本开始默认的存储引擎, 是第一个支持完整 ACID 特性的 MySQL 存储引擎

###### 特点：行锁设计,支持持 MVCC,支持外键,提供一致性非锁定读, 同时尽可能高效的利用计算机硬件资源

### 1：InnoDB 存储引擎体系架构：多个后台线程，InnoDB 存储引擎，数据库

##### 后台线程：

  作用：1：负责刷新内存池中的数据，保证缓冲池中的内存缓冲的是最近的数据
	     2：将以修改的数据文件刷新到磁盘文件，同时保证数据库在发生异常的情况下InnoDB能恢复到正常的运行状态

 1：Master Thread：将内存数据异步刷新到磁盘, InnoDB 的主要工作都是该线程完成. 该线程具有最高的优先级
			在DB 运行过程中主要进行两部分操作: 每秒将日志缓冲刷新到磁盘, 合并插入缓冲, 将脏页刷新到磁盘等
 2：IO Thread：处理 IO 请求的回调
 3：Purge Thread：在事务提交的时候回收 Undo Log
 4：Page Clear Thread ：将之前版本的脏页刷新操作都放入到单独的线程中来完成

**脏页：把数据库读出来的数据修改，还没有刷新到磁盘上**

##### 缓冲池：

​	1：InnoDB 存储引擎是基于磁盘的,并将其中所有的记录按照页的方式进行管理. 由于CPU 和磁盘速度的鸿沟, 采用缓冲池技术来提高数据库的性能
​	2：缓存池是一块内存区域, 在 DB 读取页的时候, 首先将从磁盘读到页存放到缓存池中, 这个过程称为将页"FIX"在缓冲池中,下次再读相同页的时候先判断是否在缓冲池中. 对于写操作,首先修改缓冲池中的页, 再以一定的频率刷新到磁盘上,
通过"CheckPoint 机制"，刷新会磁盘
​	3：InnoDB 中缓冲池页的大小**默认为 16KB, 使用LRU(**最近最少使用)算法进行管理,InnoDB 对新读取的页会放在 midpoint  (默认5/8长度处). 
​	4：重做日志缓冲: InnoDB 首先将 Redo Log 放入这个缓冲区, 然后以一定的频率刷新到 Redo Log 文件中

### 2：InnoDB 关键特性

#### 1：Insert Buffer

​	在 InnoDB 中,主键是唯一的标识,在插入记录的顺序是按照主键递增的顺序进行.因此不需要磁盘的随机读取.在⼀般情况下, 不需要随机读取另⼀个页中的记录, 因此 InnoDB 如果采用自增主键的方式去插入速度会非常快.但与此同时,更多情况下表中除了主键以外还存在其他索引, 此时的插入顺序依然是按照主键顺序存放, 对于非聚集索引的叶子节点的插入就不再是顺序的, 此时就需要离散的访问非聚集索引页, 从而产生大量随机读取导致插入性能下降，因此对于非聚集索引的插入或者更新, 不是一次直接插入到索引页中, 而是**先判断插入的非聚集索引页是否在缓冲池中**, 如果在，直接插入, 否则先放入⼀个 Insert Buffer 对象,作为占位符，然后再以⼀定的频率进行 Insert Buffer 和 辅助索引叶子节点的 merge 操作

#### 2：自适应性哈希索引

​     哈希表是⼀种非常快的查找方式, 在⼀般情况下可以在 O(1) 复杂度内完成. 而 B+ 树普边需要3-4层,意味着在磁盘上进行3-4次查询

InnoDB 会监控表上各项索引页的查询, 如果**观察到适合建立哈希索引就会行动**, 因此被称为自适应性哈希索引(Adaptive Hash Index, AHI), AHI 通过索引页构造而来, InnoDB 会根据访问的频率和模式来自动为某些热点页建立 AHI

### 3：日志文件

###### 1：错误日志(ErrLog) 

​    错误日志对 MySQL 的启动, 运行, 关闭过程进行了记录, 不仅记录了所有错误信息, 也记录了一些警告信息, 遇到问题是应该首先查看该文件以便定位问题. 当 MySQL 不能正常启动, 或者 MySQL 在运行期间遇到的内存不足等问题都可以在其中找到详细记录

###### 2：慢查询日志(SlowLog) 

​    慢查询日志能够定位到可能存在问题的 SQL 语句, 可以设定一个阈值, 将运行时间超过该值的 SQL 语句都记录到慢查询日志文件中 另一个可用的参数是 log_queries_not_using_indexes, 如果SQL 语句没有使用索引, 同样会将这条 SQL 语句记录到慢查询日志文件 

###### 3：查询日志(QueryLog) 

​    查询日志记录了所有对 MySQL 请求的信息（对数据库没有修改的数据）, 不论是否得到了正确的执行. 默认文件名: 主机名.log. 

###### 4：二进制日志(BinaryLog) 

​    BinLog 记录了对 MySQL 执行更改的 (不包括SELECT 和 SHOW 等对数据本身没有修改) 的操作. 不过若⼀个修改操作本身没有导致数据库发生变化也会被写入 BigLog 中(如修改了一条不存在的记录). 此外, 二进制日志还包括了DB 修改操作的时间以及其他额外信息

######   BinLog 主要用途有: 

1. 数据恢复:某些数据的恢复需要 BinLog

 	2. 集群同步:通过复制和执行 BinLog, 使一台远程的 MySQL 从库与当前主库进行实时同步
 	3. 数据同步:不同于集群同步, 业务场景中经常需要其他组件(搜索引擎, 业务报表等)需要感知数据库的修改, 此时可以通过同步BinLog 实现

### 4：InnoDB 表存储

​	在 InnoDB 中, 表都是根据主键顺序组织存放的, 这种存储方式成为索引组织表. 每张表都有一个主键, 如果没有显式指定, InnoDB 会使用第一个非空的唯一索引, 如果没有唯一索引, InnoDB 会自动创建一个 6 字节大小的指针作为主键

![](G:\Java\Java_note\13 SQL，Mysql，JDBC，dbutils，InnoDB\InnoDB存储.png)

###### 所有的数据被存放在一个表空间 (tablespace) 中, 表空间由 段(segment), 区(extent), 页(page) 组成.

​	**1：表空间(Tablespace)**：是 InnoDB 存储引擎逻辑存储的顶层对象,所有数据都存放在表空间. 其中包括数据, 索引, 插入缓冲, 回滚信息, 系统事务信息等
​	**2：段(Segment)**：表空间是由多个段组成的, 常见的段有数据段, 索引段, 回滚段等. InnoDB 由于索引组织表的特点, 
数据即索引, 索引即数据. 因此数据段是 B+ 树的叶子节点, 索引段是 B+ 树的非叶子节点
​	**3：区(Extent)**：区是由连续页组成的空间, 在任何情况下每个区的大小都为 1MB, 为了保证区中页的连续性, InnoDB 一次从磁盘申请 4-5 个区, 默认情况下 InnoDB 页的大小为 16KB, 一个区中一共有 64 个连续的页 
​	**4：页(Page)**：是 InnoDB 磁盘理的最小单位, 默认 16KB, 常见的页有: 数据页 / undo log页 / 系统页等. 
​	**5：行(Row)**：InnoDB 中数据按行进行存放, 每页最多允许存放 16KB / 2 - 200 = 7992 行记录

InnoDB 中页是管理数据库的最小磁盘单位,页类型为 B-tree Node 的页存放的就是表中的实际数据
InnoDB 数据页由一下 7 部分组成: 
	• File Header(文件头), 固定 38 字节,用来记录头信息, 以及相邻页的指针 
	• Page Header(页头), 固定 56 字节, 用来记录数据页的状态信息
	• Infinum 和 Suprenum Records, 虚拟的行记录, 用来限定记录的边界
	• User Recodes(用户记录, 即行记录) 
	• Free Space(空闲记录) 
	• Page Directory(页目录), 存放记录的相对位置, 找到 B+ 树叶⼦节点后, 再通过Page Directory 再进行二分查找 
	• File Trailer(文件结尾信息), 固定 8 字节, 用于检测页是否已经完整地写入磁盘

### 5：B+ 树：一个表（索引段和数据段）就是一个B+数

### 6：索引：

### 数据度对象之一，是为了提高查询效率，索引其实是就一张表，该表保存了主键与索引字段，并指向数据表中的记录

##### 1：聚集索引(物理索引，主键索引)

​	InnoDB 存储引擎是索引组织表, 表中数据按照主键顺序存放

 聚集索引就是按照每张表的主键构造⼀棵 B+ 树, 同时叶子节点中存放整张表的记录数据(数据页), 聚集索引的特性决定了索引组织表中数据也是索引的一部分, 每个数据都通过一个双向链表来进行连接

一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况,并且多数情况下查询优化器都倾向于采用聚集索引, 因为可以直接在其叶子节点上找到数据

##### 2：辅助索引

​	实际生产中, 往往需要通过不同的方式去查询, 此时一个聚集索引是远远不够的, 就引出了辅助索引, 叶子节点不包括行记录的全部数据, 叶子节点除了包含键值以外, 每个叶子节点中还包含了一个指针, 指向聚集索引中的主键, 然后再通过主键索引来找到一个完整的记录（存储了此索引到主键的一种映射关系）

##### 3：联合索引 

​	联合索引也是一棵 B+ 树, 不同的是联合索引的键值数量大于2 ,此外, 逻辑上和单键值的 B+ 树并没有什么区别, 键值依旧是有序的,只不过这个有序是一个前提的: 首先会按照 a 列进行排序, 此外 b 列的排序规则是在 a 相同的前提下, b 才有序

**注意：参考十位、个位的关系，另外联合索引要遵循最左匹配原则，即多个主键必须一次索引**

##### 4：覆盖索引 

​	InnoDB 支持直接从辅助索引中查询记录并返回(如果有的话), 而不需要查询聚集索引中的记录.使用覆盖索引的好处是辅助索引不包含整行记录的所有信息, 故其大小要远小于聚集索引, 因此可以减少大量的 IO 操作

此外, 在某些统计场景中, 查询优化器也会倾向于选择辅助索引去统计. 辅助索引远小于聚集索引, 选择辅助索引可以减少 IO 操作

##### 5：索引失效

​	有时候在执行 EXPLAIN 进行 SQL 语句分析的时候, 会发现优化器并没有选择索引,而是执行全表扫描.这种情况多发生于范围查找 JOIN 连接等场景
典型的场景：如果辅助索引不能覆盖所有要查询的信息, 就需要再走一次主索引, 而主索引上的访问是离散的,离散的读操作如果数量较大, 优化器就会选择通过聚集索引来查找数据.因此在优化的时候尽量通过辅助索引查询到全部数据, 避免大量的回表

1：OR 条件连接的多个条件中有不走索引的字段
2：复合索引的使用不符合最左匹配原则
3：LIKE 查询前缀模糊匹配
4：InnoDB 出现隐式类型转换(varchar -> bigint)
5：InnoDB 评估使用全表扫描比走索引更快 
6：无法通过索引获取全部数据, 需要从主索引中进行大量的随机读

### 6：索引的类型

​	INDEX 普通索引：允许出现相同的索引内容
​	UNIQUE 唯一索引：不可以出现相同的值,可以有NULL值
​	PRIMARY KEY 主键索引：不允许出现相同的值,且不能为NULL值,一个表只能有一个primary_key索引
​	fulltext index 全文索引

######   索引的添加

​		CREATE INDEX：只能对表增加普通索引或UNIQUE索引
​		CREATE INDEX index_name ON table_name (column_list)
​		CREATE UNIQUE INDEX index_name ON table_name (column_list)

```sql
ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）'索引名'（字段名）
ALTER TABLE 'table_name' ADD INDEX 'index_name' ('column_list')-索引名,可要可不要;如果不要,当前的索引名就是该字段名
```

######   索引的删除

```sql
ALTER TABLE 'table_name' DROP INDEX 'index_name'
ALTER TABLE 'table_name' DROP PRIMARY KEY -- 删除主键索引,注意主键索引只能用这种方式删除
```

######   索引的查看

​	show index from tablename \G;

######   强制使用某种索引

​	FORCE INDEX （索引字段名）



### 7：锁：数据库系统区别于文件系统的⼀个关键特性, 用于管理对共享资源的并发访问

   InnoDB 会在行记录上加锁,同时也会在内部其他地方使用,如LRU列表.InnoDB提供一致性的非锁定读,行锁,可以同时保证并发性和一致性 

   InnoDB 实现了一下两种标准的行级锁

###### 1：共享锁, 允许事务读一行数据，读锁 

###### 2：排他锁, 允许事务删除或更新一行数据 ，写锁

   此外, InnoDB 支持多粒度锁定, 允许事务在行级别和表级别同时存在, 因此引出了意向锁(Intention Lock)
   意向锁意味着事务希望在更细粒度上进行加锁

######  3：表锁：操作对象是数据表

Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行

######  4：行级锁：操作对象是数据表中的一行

是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好

### 8：一致性非锁定读(consistent nonblocking read) （MVCC ：多版本并发控制技术）

​	指InnoDB 通过多行版本控制的方式来读取当前执行时间数据中的数据.如果当前数据正在执行写操作,这时读取操作不会因此阻塞而是去读取⼀个快照数据(副本)，快照数据就是当前行数据的历史版本,有多个版本

每行记录可能有多个版本, READ COMMITTED 和 REPEATABLE READ 下, InnoDB 都会使用一致性非锁定读, 但方式不同: 
		READ COMMITTED 下, 一致性非锁定读总是读取被锁定行的最新一份快照
		REPEATABLE READ 下, 一致性非锁定读总是读取事务开始时的行版本数据

MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞。对象 P 维护有多个版本，**每个版本会有一个读时间戳**（Read TimeStamp, RTS）和 **写时间戳（Write TimeStamp, WTS）**，事务 Ti 读对象 P 的最新版本，该版本早于事务 Ti 的读时间戳 RTS(Ti)

#### MVCC优缺点

代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作

#### purge：undo log 每一行都记录了一个版本

由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge

### 9：锁造成的问题，都是写的时候不加锁造成的

###### ​1:更新丢失：双写，解决办法是一个一个地写

###### 	2:脏读：读到未写完的数据，解决办法是写完之后再读

###### 	3:不可重复读：同一事务的两次读操作取回不一致的结果,解决办法是读完再写

###### 	4:幻读：新增加了几条数据，前后读取条数不一致，解决办法是读完再写



### 9：死锁检测(dead lock)

   解决死锁: 

###### 	1：超时检测:

 设置一个阈值,当任意一方等待时间超过预设的阈值时, 其中⼀个事务回滚 

###### 	2：for-graph 主动检测：

通过“等待获取的锁” 和 “等待获取该锁的事务”, 构造出⼀张有向图，如果图中存在回路, 就代表存在死锁, 一旦  发现回路, 就将其中一个回滚, 另⼀个事务就得以继续执行 被回滚的事务会返回"dead lock"



### 10：事务：指的是满足 ACID 特性的任意一种操作

ACID：原子性(Atomic),一致性(Consistency)（数据库的角度）,隔离性(Isolation),和持久性（Durabiliy）

事务的隔离性由锁来实现, 原子性, 一致性和和 Undo Log 来完成，持久性由 Redo Log 实现
Redo Log 用于保障已提交事务的 ACID 特性, Undo log 用于保障未提交的事务不会对数据库的ACID 特性产生影响

### 11：事务实现

#####   1：Redo Log(重做日志）用来实现事务中的持久性, 由两部分组成：

​	内存中的重做日志缓冲(redo log buffer) 
​	磁盘中的重做日志文件(redo log file) 
 当事务提交的时候, 必须先将该事务的所有日志写入到磁盘中的重做日志文件进行持久化, 待事务提交结束才算完成

#####   2：Undo Log（回滚日志）记录了事务的行为, 可以很好的对页进行 "重做" 操作, 但事务有时候需要进行回滚, 

此时就需要undo log, redo log 存放在数据库内部的回滚段中, 位于共享表空间 

	重做日志的主要工作是将数据库逻辑地恢复到原来的样子, 但数据结构和页本身在回滚之后可能和事务开始前不太相同, 因为与此同时有大量的并发事务存在, 不能简单的将一个页回滚到事务开始时的样子, 否则会影响其他事务，恢复行记录
	
	Undo Log 的另一个功能是 MVCC,当需要读取的记录已经被其他事务加锁的时候, 当前事务可以通过 undo 读取之前的版本, 以此实现一致性非锁定读

### 12：事务隔离级别

​	隔离级别有 4 个，由低到高依次为 Read uncommitted、Readcommitted、Repeatable read、Serializable
​	最终解决了脏读，不可重复读，幻想读
​	MySQL 的默认隔离级别：Repeatable read

### `13`：回滚段

​	事务操作时，回滚段包含undo log，可以roolback ,如果事务提交, 回滚段中的 undo log 可以删除
​	





​	