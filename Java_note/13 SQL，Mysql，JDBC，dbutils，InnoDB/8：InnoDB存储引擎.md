
InnoDB：是 MySQL 从 5.5 版本开始默认的存储引擎, 是第一个支持完整 ACID 特性的 MySQL 存储引擎

特点：行锁设计,支持持 MVCC,支持外键,提供一致性非锁定读, 同时尽可能高效的利用计算机硬件资源

1：InnoDB 存储引擎体系架构：多个后台线程，InnoDB存储引擎，数据库

后台线程：
  作用：1：负责刷新内存池中的数据，保证缓冲池中的内存缓冲的是最近的数据
	2：将以修改的数据文件刷新到磁盘文件，同时保证数据库在发生异常的情况下InnoDB能恢复到正常的运行状态

 1：Master Thread：将内存数据异步刷新到磁盘, InnoDB 的主要工作都是该线程完成. 该线程具有最高的优先级
		   在DB 运行过程中主要进行两部分操作: 每秒将日志缓冲刷新到磁盘, 合并插入缓冲, 将脏页刷新到磁盘等
 2：IO Thread：处理 IO 请求的回调
 3：Purge Thread：在事务提交的时候回收 Undo Log
 4：Page Clear Thread ：将之前版本的脏页刷新操作都放入到单独的线程中来完成

缓冲池：
	1：InnoDB 存储引擎是基于磁盘的,并将其中所有的记录按照页的方式进行管理. 由于CPU 和磁盘速度的鸿沟, 采用缓冲池技术来
	   提高数据库的性能
	2：缓存池是一块内存区域, 在 DB 读取页的时候, 首先将从磁盘读到页存放到缓存池中, 这个过程称为将页"FIX"在缓冲池中,
	   下次再读相同页的时候先判断是否在缓冲池中. 对于写操作,首先修改缓冲池中的页, 再以一定的频率刷新到磁盘上,
	   通过"CheckPoint 机制"，刷新会磁盘
	3：InnoDB 中缓冲池页的大小默认为 16KB, 使用LRU(最近最少使用)算法进行管理,InnoDB 对新读取的页会放在 midpoint 
	   (默认5/8长度处). 
	4：重做日志缓冲: InnoDB 首先将 Redo Log 放入这个缓冲区, 然后以一定的频率刷新到 Redo Log 文件中



2：InnoDB 关键特性

1：Insert Buffer
	在 InnoDB 中,主键是唯一的标识,在插入记录的顺序是按照主键递增的顺序进行.因此不需要磁盘的随机读取.在⼀般情况下, 不需
	要随机读取另⼀个页中的记录, 因此 InnoDB 如果采用自增主键的方式去插入速度会非常快.但与此同时,更多情况下表中除了主键
	以外还存在其他索引, 此时的插入顺序依然是按照主键顺序存放, 对于非聚集索引的叶子节点的插入就不再是顺序的, 此时就需要
	离散的访问非聚集索引页, 从而产生大量随机读取导致插入性能下降，因此对于非聚集索引的插入或者更新, 不是一次直接插入到
	索引页中, 而是先判断插入的非聚集索引页是否在缓冲池中, 如果在直接插入, 否则先放入⼀个 Insert Buffer 对象,作为占位符
	然后再以⼀定的频率进行 Insert Buffer 和 辅助索引叶子节点的 merge 操作

2：自适应性哈希索引
     哈希表是⼀种非常快的查找方式, 在⼀般情况下可以在 O(1) 复杂度内完成. 而 B+ 树普边需要3-4层,意味着在磁盘上进行3-4次查询
	
	InnoDB 会监控表上各项索引页的查询, 如果观察到适合建立哈希索引就会行动, 因此被称为自适应性哈希索引(Adaptive Hash 
	Index, AHI), AHI 通过索引页构造而来, InnoDB 会根据访问的频率和模式来自动为某些热点页建立 AHI



3：日志文件

1：错误日志(ErrLog) 
    错误日志对 MySQL 的启动, 运行, 关闭过程进行了记录, 不仅记录了所有错误信息, 也记录了一些警告信息, 遇到问题是应该首先查看
    该文件以便定位问题. 当 MySQL 不能正常启动, 或者 MySQL 在运行期间遇到的内存不足等问题都可以在其中找到详细记录

2：慢查询日志(SlowLog) 
    慢查询日志能够定位到可能存在问题的 SQL 语句, 可以设定一个阈值, 将运行时间超过该值的 SQL 语句都记录到慢查询日志文件中 
    另一个可用的参数是 log_queries_not_using_indexes, 如果SQL 语句没有使用索引, 同样会将这条 SQL 语句记录到慢查询日志文件 

3：查询日志(QueryLog) 
    查询日志记录了所有对 MySQL 请求的信息（对数据库没有修改的数据）, 不论是否得到了正确的执行. 默认文件名: 主机名.log. 

4：二进制日志(BinaryLog) 
    BinLog 记录了对 MySQL 执行更改的 (不包括SELECT 和 SHOW 等对数据本身没有修改) 的操作. 不过若⼀个修改操作本身没有导致
    数据库发生变化也会被写入 BigLog 中(如修改了一条不存在的记录). 此外, 二进制日志还包括了DB 修改操作的时间以及其他额外信息
  BinLog 主要的用途有: 
	1. 数据恢复:某些数据的恢复需要 BinLog
	2. 集群同步:通过复制和执行 BinLog, 使一台远程的 MySQL 从库与当前主库进行实时同步
	3. 数据同步:不同于集群同步, 业务场景中经常需要其他组件(搜索引擎, 业务报表等)需要感知数据库的修改, 此时可以通过同步
		    BinLog 实现


4：InnoDB 表存储
	在 InnoDB 中, 表都是根据主键顺序组织存放的, 这种存储方式成为索引组织表. 每张表都有一个主键, 如果没有显式指定, 
	InnoDB 会使用第一个非空的唯一索引, 如果没有唯一索引, InnoDB 会自动创建一个 6 字节大小的指针作为主键

所有的数据被存放在一个表空间 (tablespace) 中, 表空间由 段(segment), 区(extent), 页(page) 组成.
	1：表空间(Tablespace)：是 InnoDB 存储引擎逻辑存储的顶层对象,所有数据都存放在表空间. 其中包括数据, 索引, 插入缓冲,
	   回滚信息, 系统事务信息等
	2：段(Segment)：表空间是由多个段组成的, 常见的段有数据段, 索引段, 回滚段等. InnoDB 由于索引组织表的特点, 
			数据即索引, 索引即数据. 因此数据段是 B+ 树的叶子节点, 索引段是 B+ 树的非叶子节点
	3：区(Extent)：区是由连续页组成的空间, 在任何情况下每个区的大小都为 1MB, 为了保证区中页的连续性, InnoDB 一次从磁盘
		       申请 4-5 个区, 默认情况下 InnoDB 页的大小为 16KB, 一个区中一共有 64 个连续的页 
	4：页(Page)：是 InnoDB 磁盘理的最小单位, 默认 16KB, 常见的页有: 数据页 / undo log页 / 系统页等. 
	5：行(Row)：InnoDB 中数据按行进行存放, 每页最多允许存放 16KB / 2 - 200 = 7992 行记录

	InnoDB 中页是管理数据库的最小磁盘单位,页类型为 B-tree Node 的页存放的就是表中的实际数据
	InnoDB 数据页由一下 7 部分组成: 
		• File Header(文件头), 固定 38 字节,用来记录头信息, 以及相邻页的指针 
		• Page Header(页头), 固定 56 字节, 用来记录数据页的状态信息
		• Infinum 和 Suprenum Records, 虚拟的行记录, 用来限定记录的边界
		• User Recodes(用户记录, 即行记录) 
		• Free Space(空闲记录) 
		• Page Directory(页目录), 存放记录的相对位置, 找到 B+ 树叶⼦节点后, 再通过Page Directory 再进行二分查找 
		• File Trailer(文件结尾信息), 固定 8 字节, 用于检测页是否已经完整地写入磁盘


5：B+ 树





6：索引：数据度对象之一，是为了提高查询效率，索引其实是就一张表，该表保存了主键与索引字段，并指向数据表中的记录

1：聚集索引(物理索引)
	InnoDB 存储引擎是索引组织表, 表中数据按照主键顺序存放. 聚集索引就是按照每张表的主键构造⼀棵 B+ 树, 同时叶子节点中
	存放整张表的记录数据(数据页), 聚集索引的特性决定了索引组织表中数据也是索引的一部分, 每个数据都通过一个双向链表来
	进行连接
	一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况,并且多数情况下查询优化器都倾向于采用聚集索引, 因为可以
	直接在其叶子节点上找到数据
2：辅助索引
	实际生产中, 往往需要通过不同的方式去查询, 此时一个聚集索引是远远不够的, 就引出了辅助索引, 叶子节点不包括行记录的
	全部数据, 叶子节点除了包含键值以外, 每个叶子节点中还包含了一个指针, 指向聚集索引中的主键, 然后再通过主键索引来找到
	一个完整的记录（存储了此索引到主键的一种映射关系）
3：联合索引 
	联合索引也是一棵 B+ 树, 不同的是联合索引的键值数量大于2 ,此外, 逻辑上和单键值的 B+ 树并没有什么区别, 键值依旧是
	有序的,只不过这个有序是一个前提的: 首先会按照 a 列进行排序, 此外 b 列的排序规则是在 a 相同的前提下, b 才有序

	注意：参考十位、个位的关系，另外联合索引要遵循最左匹配原则，即多个主键必须一次索引
4：覆盖索引 
	InnoDB 支持直接从辅助索引中查询记录并返回(如果有的话), 而不需要查询聚集索引中的记录.使用覆盖索引的好处是辅助索引
	不包含整行记录的所有信息, 故其大小要远小于聚集索引, 因此可以减少大量的 IO 操作

此外, 在某些统计场景中, 查询优化器也会倾向于选择辅助索引去统计. 辅助索引远小于聚集索引, 选择辅助索引可以减少 IO 操作

5：索引失效
	有时候在执行 EXPLAIN 进行 SQL 语句分析的时候, 会发现优化器并没有选择索引,而是执行全表扫描.这种情况多发生于范围查找 JOIN 连接等场景.  
  典型的场景：如果辅助索引不能覆盖所有要查询的信息, 就需要再走一次主索引, 而主索引上的访问是离散的,离散的读操作如果数量
	      较大, 优化器就会选择通过聚集索引来查找数据.因此在优化的时候尽量通过辅助索引查询到全部数据, 避免大量的回表

	1：OR 条件连接的多个条件中有不走索引的字段
	2：复合索引的使用不符合最左匹配原则
	3：LIKE 查询前缀模糊匹配
	4：InnoDB 出现隐式类型转换(varchar -> bigint)
	5：InnoDB 评估使用全表扫描比走索引更快 
	6：无法通过索引获取全部数据, 需要从主索引中进行大量的随机读

6：索引
  索引的类型
	INDEX 普通索引：允许出现相同的索引内容
	UNIQUE 唯一索引：不可以出现相同的值,可以有NULL值
	PRIMARY KEY 主键索引：不允许出现相同的值,且不能为NULL值,一个表只能有一个primary_key索引
	fulltext index 全文索引

  索引的添加
	CREATE INDEX：只能对表增加普通索引或UNIQUE索引
		CREATE INDEX index_name ON table_name (column_list)
		CREATE UNIQUE INDEX index_name ON table_name (column_list)

	ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）'索引名'（字段名）
	
	ALTER TABLE 'table_name' ADD INDEX 'index_name' ('column_list')-索引名,可要可不要;如果不要,当前的索引名就是该字段名

  索引的删除

	ALTER TABLE 'table_name' DROP INDEX 'index_name'
	ALTER TABLE 'table_name' DROP PRIMARY KEY -- 删除主键索引,注意主键索引只能用这种方式删除

  索引的查看
	show index from tablename \G;

  强制使用某种索引
	FORCE INDEX （索引字段名）



### 7：锁：数据库系统区别于文件系统的⼀个关键特性, 用于管理对共享资源的并发访问

   InnoDB 会在行记录上加锁,同时也会在内部其他地方使用,如LRU列表.InnoDB提供一致性的非锁定读,行锁,可以同时保证并发性和一致性 

   InnoDB 实现了一下两种标准的行级锁
	1：共享锁, 允许事务读一行数据 
	2：排他锁, 允许事务删除或更新一行数据 
   此外, InnoDB 支持多粒度锁定, 允许事务在行级别和表级别同时存在, 因此引出了意向锁(Intention Lock)
   意向锁意味着事务希望在更细粒度上进行加锁

### 一致性非锁定读(consistent nonblocking read)

​	指InnoDB 通过多行版本控制的方式来读取当前执行时间数据中的数据.如果当前数据正在执行写操作,这时读取操作不会因此阻塞而是去读取⼀个快照数据(副本)，快照数据就是当前行数据的历史版本

每行记录可能有多个版本, READ COMMITTED 和 REPEATABLE READ 下, InnoDB 都会使用一致性非锁定读, 但方式不同: 
		READ COMMITTED 下, 一致性非锁定读总是读取被锁定行的最新一份快照
		REPEATABLE READ 下, 一致性非锁定读总是读取事务开始时的行版本数据

### 8：锁造成的问题

###### ​	1:更新丢失：更新丢失本质上是写不加锁带来的后果，解决办法是一个一个地写

###### 	2:脏读：读到未写完的数据，脏读本质上是写操作只加共享锁带来的问题，解决办法是写完之后再读

###### 	3:不可重复读：本质上写的时候不加锁带来的，因此会让同一事务的两次读操作取回不一致的结果,解决办法是读完	再写

###### 	4:幻读：幻象读本质上是写的时候未加锁，解决办法是读完再写

### 9：死锁检测(dead lock)

   解决死锁: 

###### 	1：超时检测: 设置一个阈值,当任意一方等待时间超过预设的阈值时, 其中⼀个事务回滚 

###### 	2：for-graph 主动检测:通过“等待获取的锁” 和 “等待获取该锁的事务”, 构造出⼀张有向图如果图中存在回路, 

​	就代表存在死锁, 一旦发现回路, 就将其中一个回滚, 另⼀个事务就得以继续执行 被回滚的事务会返回"dead lock"

### 10：事务：指的是满足 ACID 特性的任意一种操作

ACID：原子性(Atomic),一致性(Consistency)（数据库的角度）,隔离性(Isolation),和持久性（Durabiliy）

事务的隔离性由锁来实现, 原子性, 一致性和和 Undo Log 来完成，持久性由 Redo Log 实现
Redo Log 用于保障已提交事务的 ACID 特性, Undo log 用于保障未提交的事务不会对数据库的ACID 特性产生影响

### 11：事务实现

#####   1：Redo Log(重做日志）用来实现事务中的持久性, 由两部分组成：

​	内存中的重做日志缓冲(redo log buffer) 
​	磁盘中的重做日志文件(redo log file) 
​        当事务提交的时候, 必须先将该事务的所有日志写入到磁盘中的重做日志文件进行持久化, 待事务提交结束才算完成

#####   2：Undo Log（回滚日志）记录了事务的行为, 可以很好的对页进行 "重做" 操作, 但事务有时候需要进行回滚, 

​			 此时就需要undo log, redo log 存放在数据库内部的回滚段中, 位于共享表空间 

	重做日志的主要工作是将数据库逻辑地恢复到原来的样子, 但数据结构和页本身在回滚之后可能和事务开始前不太相同, 因为与此同时有大量的并发事务存在, 不能简单的将一个页回滚到事务开始时的样子, 否则会影响其他事务，恢复行记录
	
	Undo Log 的另一个功能是 MVCC,当需要读取的记录已经被其他事务加锁的时候, 当前事务可以通过 undo 读取之前的版本, 以此实现一致性非锁定读

### 12：事务隔离级别

​	隔离级别有 4 个，由低到高依次为 Read uncommitted、Readcommitted、Repeatable read、Serializable
​	最终解决了脏读，不可重复读，幻想读
​	MySQL 的默认隔离级别：Repeatable read

### 13：滚段

​	事务操作时，回滚段包含undo log，可以roolback ,如果事务提交, 回滚段中的 undo log 可以删除
	





​	