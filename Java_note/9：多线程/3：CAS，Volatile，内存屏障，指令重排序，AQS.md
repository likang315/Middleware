### 变量同步：就是多个线程看到的共享变量的值时一样的值

多线程中的**非同步问题主要出现在对域的读写上**，如果**让域自身避免这个问题**，则就不需要修改操作该域的方法。用final域，有锁保护的域和 volatile 域可以避免非同步的问题



### CAS（Compare and swap）比较与交换：是一种无锁算法，乐观锁的 一种实现

###### 无锁编程：即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步

CAS 算法涉及到**三个操作数：**

###### ​	读写的内存值 （当前值）V

###### ​	进行比较的值 （预期值）A

###### 		要写入的新值（新值）      B

当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作

通过 **自旋  CAS 的方式来实现原子操作，Java中 java.util.concurrent.atomic 包相关类就是 CAS的实现**

​	AtomicBoolean：可以用原子方式更新的 `boolean` 值

​	AtomicInteger：可以用原子方式更新的 `int` 值

​	AtomicLong：可以用原子方式更新的 `long` 值

​	AtomicIntegerFieldUpdater<T>：基于反射的实用工具，可以对指定类的指定 `volatile int` 字段进行原子更新

###### atomic  包中的类可将 `volatile` 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类

Java中，i++ 等类似操作并不是线程安全的，因为  i++可分为三个独立的操作：获取变量当前值，为该值+1，然后写回新的值。在没有额外资源可以利用的情况下，只能使用加锁才能保证**读-改-写**这三个操作时“原子性”的。但是利用加锁的方式来实现该功能的话，代码将非常复杂及难以维护

```java
synchronized (lock) {  
 i++;  
}
```



### CAS仍然存在三大问题：

#### 1：ABA问题：

CAS需要**在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值**。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的

ABA问题的解决思路就是在**变量前面添加版本号**，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”

#### compareAndSet方法：AtomicStampedReference 类来解决ABA问题，具体操作封装在 compareAndSet() 中

###### 首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新

```java
/** 使用CAS实现线程安全计数器 */  
private void safeCount() {  
        for (;;) {  
            int i = ai.get();  
            // 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值  
            boolean suc = ai.compareAndSet(i, ++i);  
            if (suc) {  
                break;  
            }  
        }  
}  
```

#### 2：循环时间长开销大：

自旋CAS（**不成功就一直循环执行直到成功**）如果长时间不成功，会给CPU带来非常大的执行开销。

如果JVM能支持处理器提供的**pause指令那**么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memoryorder violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率

#### 3：只能保证一个共享变量的原子操作：

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就**可以用锁**，或者把**多个共享变量合并成一个共享变量来操作**。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij



### volatile：一种轻量级的变量同步机制

**volatile：更轻量级，它不会引起线程上下文的切换和调度，但是volatile 变量的同步性较差，而且其使用也更容易出错**

### 特点

###### 1：保证可见性，不保证原子性

volatile变量更新时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，这个写会操作会导致其他线程中的缓存无效

###### 2：禁止指令重排 

用 volatile 修饰的共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序



### 内存屏障

加入volatile关键字时，会多出一个**lock前缀指令**，lock前缀指令实际上相当于一个内存屏障（也称内存栅栏）

###### 内存屏障会提供 3 个功能：

1：它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面，即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
2：它会强制将对缓存的修改操作立即写入主存															3：如果是写操作，它会导致其他CPU中对应的缓存行无效



### 指令重排序

指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段

###### 重排序需要遵守一定规则：

重排序操作不会对存在**数据依赖关系的操作**进行重排序

重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变



## AQS：

AQS（AbustactQueuedSynchronizer），它是一个Java提高的底层同步的工具类，**用一个int类型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态**

### 同步队列：

是AQS很重要的组成部分，它是一个**双端队列，遵循FIFO原则**，主要作用是用来**存放阻塞的线程**，当一个线程尝试获取锁时，如果已经被占用，那么当前线程就会**被构造成一个Node节点放入到同步队列的尾部**，**队列的头节点是成功获取锁的节点，当头节点线程释放锁时，会唤醒后面的节点并释放当前头节点的引用**

![同步队列.png](https://github.com/likang315/Java/blob/master/Java_note/9%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97.png?raw=true)



### 独占锁的获取和释放

##### 获取锁

​	1：调用入口方法acquire(arg)
​	2：调用模版方法tryAcquire(arg)尝试获取锁，若成功则返回，若失败则走下一步

​	3：将当前线程**构造成一个Node节点，并利用CAS将其加入到同步队列到尾部，然后该节点对应到线程进入自旋状态**自旋时，首先判断其前驱节点是否为头节点 && 是否成功获取同步状态，两个条件都成立，则将当前线程的节点设置为头节点，如果不是，则利用LockSupport.park(this)将当前线程挂起 ,等待被前驱节点唤醒

##### 释放锁

​	1：调用入口方法release(arg)
​	2：调用模版方法tryRelease(arg)释放同步状态
​	3：获取当前节点的下一个节点

​	4：利用 LockSupport.unpark(currentNode.next.thread) 唤醒后继节点

![独占锁的获取与释放.png](https://github.com/likang315/Java/blob/master/Java_note/9%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%87%8A%E6%94%BE.png?raw=true)

### 共享锁 的 获取 和 释放 时

##### 获取锁

​	1：调用acquireShared(arg)入口方法
​	2：进入tryAcquireShared(arg)模版方法获取同步状态，如果返回值>=0，则说明同步状态(state)有剩余，获取锁成功直接返回
​	3：如果 tryAcquireShared(arg) 返回值 <0，说明获取同步状态失败，向队列尾部添加一个共享类型的Node节点，随即该节点进入自旋状态
​	4：自旋时，首先检查前驱节点是否为 头节点 & tryAcquireShared() 是否 >=0 (即成功获取同步状态)
​			如果是，则说明当前节点可执行，同时把当前节点设置为头节点，并且唤醒所有后继节点
​			如果否，则利用 LockSupport.unpark(this) 挂起当前线程，等待被前驱节点唤醒

##### 释放锁

​	1：调用 releaseShared(arg) 模版方法，释放同步状态												

​	2：如果释放成，则遍历整个队列，利用LockSupport.unpark(nextNode.thread)唤醒所有后继节点

### 独占锁和共享锁在实现上的区别

1：独占锁的同步状态值为1，即同一时刻只能有一个线程成功获取同步状态，共享锁的同步状态 >1，取值由上层同步组件确定
2：独占锁队列中头节点运行完成后通知它的直接后继节点，共享锁队列中头节点运行完成后通知它后面的所有节点

3：共享锁中会出现多个线程（即同步队列中的节点）同时成功获取同步状态的情况



