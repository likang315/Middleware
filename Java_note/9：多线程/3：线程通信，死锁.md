
线程通信：

	线程间的通信方式：
		1：线程同步机制：多个线程需要访问同一个方法时，谁拿到了锁（synchronized同步锁），谁就可以执行。
		2：wait/notify机制，A线程等待B通知,A线程在执行
		
	wait()----当线程执行wait()时，会把当前的锁释放，然后让出CPU（时间片），进入等待状态。

	notify();任意唤醒一个处于等待该对象锁的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized块）
		 后再释放锁。

	notifyAll();会唤醒所有处于等待该对象锁的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized块 ）			    后再释放锁。

 	



线程状态转换：
	
	新建状态--------就绪状态-----运行状态------阻塞状态-----死亡状态
			
									
			sleep()                         wait()
			Thread的static方法              
			休眠                            等待
			不释放锁             		释放锁



死锁现象：
	1：一个线程T1持有锁L1并且申请获得锁L2，而另一个线程T2持有锁L2并且申请获得锁L1，因为默认的锁申请操作都是阻塞的，所以线程T1和T2永远被阻塞了，导致了死锁。
	2：线程T1持有锁L1并且申请获得锁L2，而线程T2持有锁L2并且申请获得锁L3，而线程T3持有锁L3并且申请获得锁L1，这样导致了一个锁依赖的环路。

死锁的原因：
	
	1：线程在获得一个锁L1的情况下再去申请另外一个锁L2，也就是锁L1想要包含了锁L2，也就是说在获得了锁L1，并且没有释放锁L1的情况下，又去申请获得锁L2，
	2：默认的锁申请操作是阻塞的。

	Java中的锁一般也是以对象为单位的，对象的内置锁保护对象中的数据的并发访问
	

死锁的案例：

注意：在没有明确的共享数据时，想让一段代码同步，那么创建0长度的byte数组作为加锁对象更经济





ThreadLocal 类:提供了线程局部变量,ThreadLocal实例通常是类中的 private static 字段，它们希望将状态与某一个线程

线程局部变量不同于普通变量，因为访问某个变量（通过get或set方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本





















