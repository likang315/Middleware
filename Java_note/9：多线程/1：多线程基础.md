## 多线程:

##### 进程（process）：是操作系统中能独立运行并作为资源分配的基本单位

1：进程是一个“运行中的程序”																		程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体

2：进程是一个实体																					每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量

3:进程可以分为系统进程 和用户进程																		用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身;所有由用户启动的进程都是用户进程

##### 线程（thread）：又称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元，线程是cpu调度的最小单位

一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成										进程中所包含的一个或多个线程，同属一个进程的其它线程共享进程所拥有的全部资源，线程切换开销小，

```java
注意：
	1：线程只能归属于一个进程并且只能访问该进程所拥有的资源
	2：当操作系统创建一个进程后，该进程会自动申请一个名为主线程的线程
	3：线程通常用于在一个程序中需要同时完成多个任务的情况
```

##### 协程：不是进程或线程，其执行过程更类似于子程序，或者说不带返回值的函数调用

##### 多线程：在同一个时间段，计算机系统中如果允许两个或两个以上的进程处于运行状态

总线程数（进程数）<= CPU数量：并行运行																			总线程数（进程数）> CPU数量：并发运行

##### 多线程并发原理：

​	感观上多个线程能“同时”运行的技术,事实上线程并发运行时，OS将CPU时间分为很多时间片段（时间片），尽可能的均匀分配给每一个线程，获取时间片段的线程被CPU运行而其他线程全部等待，这种现象将并发

##### java线程的五种状态

![](F:\note\9：多线程\线程状态转换图.png)

```txt
1：新建状态（New）：当线程对象对创建后，即进入了新建状态，

2：就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。
   					  处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执					  行了 t.start()此线程立即就会执行；

3：运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态

4：阻塞状态（Block）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，
				   此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。

	等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
	同步阻塞：线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态
	其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态
		     当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态

5:死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期，对象被垃圾回收
```





### 线程类的创建方式（两种）：

###### 1：继承Thread类，重写run（） 来定义线程要执行的任务

启动线程是要指定start方法，而并不是调用run方法，run方法是线程要执行的任务，当线程的start方法被调用后，线程进入Runnable状态，等待获取cpu,一旦获取CPU时间片，run()自动被调用
缺点：
1：由于java时单继承，那么当继承了Thread后就无法在继承其它类
2：由于继承了Thread后重写run方法规定了线程执行的任务，这导致线程与任务有一个必然的耦合关系，不利于线程的重用

###### 2：实现Runnable接口，重写run（）方法，再调用Thread构造

Thread(Runnable target) 
      分配新的 Thread 实例		

使用匿名内部类来完成方式一和方式二的线程创建

```java
	new Thread（new Runnable(){
		@Override
		public void run()
        {
		   for(int i=0;i<1000;i++)
		   {
    			System.out.println(i);
		   }
		} 
	}).start();
```



### 线程类

###### java.lang 																																							Interface Runnable    

​	void   run（）



###### Java.lang																						

###### Class  Thread 线程类，一个Thread类的实例就是一个线程

public class Thread extends Object implements Runnable

属性：																															static class Thread.state	 返回线程的状态类		​																																																											 	

构造方法：
	Thread() 
      		分配新的 Thread 对象 
	Thread(Runnable target) 
      		分配新的 Thread 对象
	Thread(Runnable target, String name) 
     		分配新的 Thread 对象
	Thread(String name) 
      		分配新的 Thread 对象，线程名
方法:

void notify()																																																 						唤醒线程，通知wait() 的线程																						void join(long millis) 
      		等待该线程终止，最大等待 millis 毫秒 ，底层调用Object.wait()
static void sleep(long millis) 
      		在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）
static void yield() 
     		暂停当前正在执行的线程对象，让出时间片，由运行状态到就绪状态，等待获取时间片，**线程让步**	

void interrupt ()																																			只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的

void setPriority(int newPriority) 
      		更改线程的优先级																						  void setDaemon(boolean on) 
 		将该线程标记为守护线程或用户线程			

​	

​	void join() 
​		使调用该方法的线程进入阻塞状态，直到该方法所属线程完成工作才会解除线程的阻塞状态。	
​	static Thread currentThread() 
​     		 获取运行当前方法的线程 
​	String getName() 
​      		返回该线程的名称
​	int getPriority() 
​      		返回线程的优先级 
​	void interrupt() 
​    		 中断线程
​	boolean isAlive() 
​      		测试线程是否存存活
​	static boolean interrupted() 
​      		测试当前线程是否已经中断 
​	boolean isDaemon() 
​      		测试该线程是否为守护线程

#### 线程的优先级：线程默认优先级为5，范围是1-10

线程的切换是由CPU的调度(轮转时间片)控制的，并且线程的调度不能被干预，但是可以通过提高线程的优先级来提高获取时间片的概率

#### 守护进程(Daemon程序)：是一直运行的服务端程序，通常在系统后台运行，没有控制终端，不与前台交互，Daemon程序一般作为系统服务使用

setDaemon(true) ：设置为守护线程，先设置后启动，垃圾回收器（GC）就是守护线程




