### 进程间通信方式（ 6 种）：

**1：管道pipe：**管道是一种**半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用**。进程的亲缘关系通常是指父子进程关系

**2：消息队列MessageQueue：**消息队列是**由消息的链表，存放在内核中并由消息队列标识符标识**。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点

**3：共享存储SharedMemory：**共享内存就是映射一段能被其他进程所访问的内存，这**段共享内存由一个进程创建，但多个进程都可以访问**

**4：信号量Semaphore（P,V）：**信号量是**一个计数器，可以用来控制多个进程对共享资源的访问**。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段

**5：套接字Socket：**套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信

**6：信号 ( sinal ) ：** 用**于通知接收进程某个事件已经发生**



### 线程间通信方式：

**1：线程同步机制：**多个线程需要访问同一个方法时，**谁拿到了锁（synchronized同步锁），谁就可以执行**

**2：wait / notify机制：**Object类的方法

wait()：当线程执行wait()时，会把**当前的锁释放，让出CPU（时间片），进入就绪状态**

notify()：**任意唤醒一个处于等待该对象锁的线程**，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized块）后再释放锁

notifyAll()：**会唤醒所有处于等待该对象锁的线程**，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized块 ）后再释放锁

### 线程池：降低资源消耗，提高响应速度，提高线程可管理性

- 重复利用已经创建的线程，减少创建线程和销毁线程的开销
- 提高响应速度，不需要等到线程创建就能立即执行
- 使用线程池可以进行统一分配，调优和监控
- 当我们的应用需要创建大量线程或者发现线程会频繁的创建和销毁时就应当考虑使用线程池来维护线程

### 线程池原理：

![线程池.png](https://github.com/likang315/Java/blob/master/Java_note/9%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png?raw=true)

###### 1：提交任务

###### 2：核心线程池（corePoolSize）是否已经满，如果未满的话就创建线程执行任务

###### 3：否则查看队列（BlockingQueue）是否已满，未满的话，将任务存储在队列里

###### 4：如果已经满了，看线程池（maximumPoolSize）是否已满，如果满的话按照拒绝处理任务策略（handler）处理无法执行的任务

###### 5：如果未满，创建线程执行任务



### ThreadPoolExecutor 的 参数

- **corePoolSize**：**核心池的大小，**构建线程池后，并不会创建线程，当前线程数如果小于corePoolSize时，当要执行任务时，创建一个线程。当前线程数 等于corePoolSize，会将任务放入队列中

- **maximumPoolSize：**（线程池最大大小)，线程数大于或等于核心线程,且任务队列已满时**,线程池会创建新的线程,直到线程数量达到maxmumPoolSize**。如果线程数已等于maxmumPoolSize,且任务队列已满,则已超出线程池的处理能力,线程池会拒绝处理任务而抛出异常

- **keepAliveTime：**工作线程空闲后，保持存活的时间。默认情况下，如果当前线程数大于corePoolSize，并且一个线程如果没有任务，当空闲的时间大于keepAliveTime时，会终止该线程，直到线程数不超过corePoolSize

- **workQueue：**存储任务的队列（4种）

  1：ArrayBlockingQueue：**基于数组结构的有界阻塞队列**，按FIFO排序任务；

  2：LinkedBlockingQuene：**基于链表结构的阻塞队列，**按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；

  3：SynchronousQuene：**一个不存储元素的阻塞队列**，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；

  4：priorityBlockingQuene：**具有优先级的无界阻塞队列；**

- **rejectedExecutionHandler：**拒绝处理任务的策略（4种）

  1：AbortPolicy：**直接抛出异常，默认策略；**

  2：CallerRunsPolicy：用**调用者所在的线程来执行任务；**

  3：DiscardOldestPolicy：**丢弃阻塞队列中靠最前的任务，并执行当前任务；**

  4：DiscardPolicy：**直接丢弃任务；**

- **ThreadFactory：**线程工厂，用来创建线程,通过**线程工厂模式**可以给创建的线程设置名字



### ThreadPoolExecutor 的方法

execute：在**将来某个时间执行给定任务**

submit：**提交一个任务用于执行，并返回一个表示该任务的 Future**，和 execute 不同的是返回的是一个Future，可以在任务执行完毕之后得到任务执行结果

shutdown：按**过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务，也就是说，中断没有正在执行任务的线程，等待任务执行完毕**

shutdownnow： 尝试**停止所有的活动执行任务**、暂停等待任务的处理，并返回等待执行的任务列表

### 线程池的状态：

```java
volatile int runState;
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
```

- **RUNNING:**创建线程池后，初始状态为RUNNING
- **SHUTDOWN：**执行shutdown方法后，线程池处于SHUTDOWN状态
- STOP：执行shutdownNow方法后，线程池处于STOP状态
- **TERMINATED：当**线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态



### java.util.concurrent

### Class Executors：提供创建线程池的方法

###### static ExecutorService newFixedThreadPool(int nThreads) 

创建一个**可重用固定线程数的线程池，以共享的无界队列方式**来运行这些线程 

###### static ExecutorService newSingleThreadExecutor() 

单线程线程池，同样**队列使用的无限制大小的链表阻塞队列**

###### static ExecutorService newCachedThreadPool()

**无界线程池，无论多少任务，直接运行，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程**



### 死锁现象：

1：一个线程T1持有锁L1并且申请获得锁L2，而另一个线程T2持有锁L2并且申请获得锁L1，因为默认的锁申请操作都是阻塞的，所以线程T1和T2永远被阻塞了，导致了死锁
2：线程T1持有锁L1并且申请获得锁L2，而线程T2持有锁L2并且申请获得锁L3，而线程T3持有锁L3并且申请获得锁L1，这样导致了一个锁依赖的环路

##### 解决死锁的方法

###### 1：超时检测: 设置一个阈值,当任意一方等待时间超过预设的阈值时, 其中⼀个事务回滚

###### 2：for-graph 主动检测：通过“等待获取的锁” 和 “等待获取该锁的事务”, 构造出⼀张有向图如果图中存在回路, 就代表存在死锁, 一旦发现回路, 就将其中一个回滚, 另⼀个事务就得以继续执行 ，被回滚的事务会返回"dead lock"的锁

一般也是以对象为单位的，**对象的内置锁保护对象中的数据的并发访问**



