## Java 对象头 和 monitor 是实现 synchronized 的基础

### Java对象头

Hotspot虚拟机的对象头主要包括两部分数据：**Mark Word +  Class Metadata Address**

###### Mark Word：存储对象的hashCode或者锁信息

###### Class Metadata Address：存储对象类型数据的指针，是那个类的实例

如果对象是数组，还会有一个部分存储的是数据的长度

### Mark Word

![mark word.png](https://github.com/likang315/Java/blob/master/Java_note/9%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/mark%20word.png?raw=true)

Mark Word：一个**非固定的数据结构**以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间

### Monitor：内置锁，监视器锁（monitor）

###### 内置锁：一种同步机制，它通常被描述为一个对象

所有的Java对象是天生带着Monitor，**每一个Java对象都有成为Monitor的潜质**，它叫做内置锁或者Monitor锁

Monitor 是线程私有的数据结构，**每一个线程都有一个可用 monitor record 列表**。**每一个被锁住的对象都会和一个monitor关联**（对象头的 Mark Word 中的 Lock Word 指向monitor的起始地址），同时monitor中有一个**Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用**

### 锁的状态：锁的等级只可以升级，不可以降级

###### 重量级锁状态

###### 轻量级锁状态

###### 偏向锁状态

###### 无锁状态



### 重量级锁

在JDK 1.6之前，监视器锁可以认为**直接对应底层操作系统中的互斥量（mutex）**。这种同步方式的成本非常高，包括**系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换**等。因此，后来称这种锁为“重量级锁”

线程的阻塞和唤醒需要 CPU从 用户态转为 内核态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁

### 轻量级锁

如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。轻量级锁的目标是，减少**无实际竞争情况下，使用重量级锁产生的性能消耗**

轻量级锁：不需要**申请互斥量，仅仅 将 Mark Word 中的部分字节，CAS更新指向线程栈中的Lock Record**，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），膨胀为重量级锁

当然，由于轻量级锁天然瞄准不存在锁竞争的场景，**如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁**

**缺点：**同自旋锁相似：如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么**维持轻量级锁的过程就成了浪费**



### 偏向锁

偏向锁的目标是，**减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗**。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS

偏向锁：假定将来**只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录 owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁**。

**缺点：**同样的，如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁

### 偏向锁的释放锁 

偏向锁的释放**采用了一种只有竞争才会释放锁的机制**，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）

**其步骤如下：**

###### 1：暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态

###### 2：撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态



### 偏向锁、轻量级锁、重量级锁适用于不同的并发场景：

偏向锁：    无实际竞争，且将来只有第一个申请锁的线程会使用锁
轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争
重量级锁：有实际竞争，且锁竞争时间长
另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换



### 自旋锁

###### 就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁

怎么等待呢？**执行一段无意义的循环（自旋）**，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起

在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整； 
JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明

### 自适应自旋锁

###### 自适应意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源

**缺点：**由于锁竞争时间不确定，自适应自旋也没能彻底解决该问题，如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值



### 锁消除

###### 有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除，锁消除的依据是**逃逸分析的数据支持** 

如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定

### 锁粗化

###### 锁粗化：就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的加锁

使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁，如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念
