### NIO 实现原理

NIO 底层**Buffer数组实现的**，限度读写到缓存中，然后再通过管道读到内存中或写到磁盘上

### IO 和 NIO （阻塞与非阻塞）

当使⽤**IO读写⽅法时, 默认是阻塞的**, ⽐如 read ⽅法传⼊参数 n, 代表最多读取 n 个字节后再返回, 如果⼀个字节都没有, 那么线程就会阻塞, 直到新的数据到来或者连接关闭才返回. ⽽ write ⼀般不会阻塞, 除⾮内核为 socket 分配的写缓冲区已经满了. socket 线程就会阻塞直到缓冲区有空闲空间

**⾮阻塞 NIO , 读写⽅法不会阻塞, 能读多少读多少, 能写多少写多少.** 能读多少取决于内核为 socket 分配的读缓冲区内数据, 能写多少取决于写缓冲区的空闲空闲字节数. **读写⽅法都会通过返回值来告知调⽤⽅实际读写了多少字节**.⾮阻塞 IO 意味着线程在读写 IO 的时候不必再阻塞, 读写可以瞬间完成然后线程继续其他

⾮阻塞 IO 有⼀个问题, 那就是线程要读数据, 结果读了⼀部分就返回, 如果知道何时才应该继续读, 也就是当数据来了, 线程如何得到通知, 以及如果⼀次写不完, 剩下的数据应该何时才能继续写, 线程也应该得到通知

最简单的**事件轮询 API 就是 select 函数**, 它是操作系统提供给⽤户程序的 API, 输⼊是读写描述符 read_fds & write_fds, 输出的是与之对应的可读可写事件, 同时还提供了⼀个 timeout 参数, 如果没有任何事件到来, 那么线程最多阻塞 timeout 时间. ⼀旦期间有任何事件到来, 就可以⽴即返回.拿到事件后, 线程就可以继续挨个处理响应的事件, 处理完了继续过来轮询.

### IO 和 NIO 的区别

1：IO面向流的，NIO面向缓冲的

2：IO时阻塞式的，NIO时非阻塞式的

3：NIO有选择器（Selectors），而IO没有

### NIO的选择器

允许一个单独的线程来监视多个输入通道，然后使用一个单独的线程来选择通道，这种选择机制，使得一个单独的线程很容易来管理多个通道

### BIO、NIO 和 AIO 的 区别

Java BIO ： 同步阻塞，客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善

Java NIO ： 同步非阻塞，客户端发送的连接请求都会**注册到多路复用器**上，多路复用器**轮询到连接有I/O请求时才启动一个线程进行处理**

Java AIO： 异步非阻塞，服务器实现模式为一个有效请求一个线程，**客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理**



