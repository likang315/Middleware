### 泛型（参数化类型）：给类加参数，达到动态的确定类型的目的

### 1：JVM 泛型的擦除机制：

Java 中的泛型，只在编译阶段有效，泛型信息不会进入到运行时阶段
在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法

###### 通配符（？）：通配符代表任意类型



### 2：上下边界问题

###### ？extends E ：向上限定，？代表E 本身或者其子类，也可以称之为：泛型固定上边界

​	做添加操作的时候,你只知道,你添加数据的上限。但是你无法确定你要添加数据的下限，因此无法添加数据

###### ？super E ：向下限定， ？代表 E 或者其父类 (泛型固定下边界)   在做添加的时候是不会有问题的

​	泛型的下边界,已经限制。再向集合中添加数据,只能是其本身或者他的子类



### 3：泛型（类，接口）：

###### 泛型类：在实例化类的时候指明泛型的具体类型

```java
public static class Person<T>{  
  private T ob;
  public Person(T ob) {  
    this.ob = ob; 
  }
} 	 
例：
Person<Integer> person = new Person<>(100);  //T的实际类型是整型
```

###### 泛型接口：

```java
public interface Animal <T>{

}
```

- 当实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中

```java
public class A<T> implements Animal<T>{

}
```

- 实现泛型接口的类，传入泛型实参时，则所有使用泛型的地方都要替换成传入的实参类型

```java
public class A implements Animal<String>{

}
```



### 4：泛型方法：

```java
//只有声明了<T>的方法才是泛型方法,泛型类中的使用了泛型的成员方法并不是泛型方法
public <T> void method(T e ){

}
```



### 5：泛型特点

1. 泛型的类型参数只能是类类型，因为传递的是对象
2. 泛型的类型参数可以有多个
3. 不能对确切的泛型类型 使用 instanceof 判断
4. 使用通配符创建泛型数组是可以的
   ​List<?>[] ls = new ArrayList<?>[10];  


