
虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统

JVM

### 1：内存模型

![](F:\note\9：JVM\jvm内存模型.png)



1：程序计数器：当前线程所执行字节码的行号指示器，值 +1，就去下一条的字节码指令去执行
		1：每个线程都有一个独立的程序计数器，线程私有

2：Java 栈（stack）：方法执行的内存模型
	1：JVM会为每一个调用的方法在栈中分配一个存储空间，称为栈桢（栈中栈）
	2：栈桢用于存储局部变量表,操作数栈,动态链接,方法出口等信息
	3：每个方法的调用直至执行过程，对应一个栈帧在java栈中入栈，出栈操作
	4：java栈可以动态扩展，使用连续的内存空间，线程私有区域

3：本地方法栈：Native 方法执行的内存模型
	1：存储jvm使用到的Native 方法（本地方法库）

4：Java堆（heap）：运行时进行存储空间分配和回收的内存管理模型

?	1：所有new的对象实例（包括成员变量的属性），都存储在堆中
	2：Java堆时GC管理的主要区域，因此有时也称GC堆
	3：物理上可以不使用连续的内存地址，只要逻辑上连续即可
	4：线程共享区域，生命周期与jvm相同

3：方法区：存储类的信息，通过类加载器载入类的字节码文件，经解析后装入方法区
	1：线程共享的区域，方法只有一份，通过this来区分那个对象调用
	2：运行时常量池(Constant Pool)：方法区的一部分，用于存放编译器生成的各种字面量和符号引用
	3：Class文件的常量池，在类加载装入方法区的运行时的常量池中存放
	4：运行时常量池和class文件的常量池相比，具有动态性，即运行时也可以放入新的常量
		例：String类的 intern（）方法

 例:
      String str = new String("hello"); 
      变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的常量池中

### 2：内存分配

  1：方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收; 

  2：方法的引用，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完后从栈空间回收

  3：方法调用时传入的实际参数，先在栈空间分配，在方法调用完成后从栈空间释放

  4：数组既在栈空间分配数组名， 又在堆空间分配数组的大小

3：JVM 主内存与工作内存：JVM将内存组织为主内存和工作内存两个部分

主内存：包括本地方法区和堆，线程共享区
工作内存：每个线程都有一个工作内存，工作内存中主要包括两个部分，一个是属于该线程私有的栈(Java栈和Native方法					栈)和 对程序计数器PC，线程隔离区

1.所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的
2.每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存       中进行而不能直接读写主内存中的变量

3.线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成



### 4：heap和stack的区别

?	1. 申请方式 
?	2. 申请后系统的响应 
?	3. 申请大小的不同
?	4. heap和stack中的存储内容 
?	5. 数据结构层面的区别 

### 5：栈，堆，方法区

?	1：基本数据类型的变量，对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间
?	2：通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾回收器管理的主要区域
?	3：常量池，源代码中的命名常量、String常量和static变量保存在方法区

### 6：内存泄漏和内存溢出

内存泄漏：不再使用的对象没有被及时的回收，内存无法被回收，造成浪费
		建议：当对象不在使用时应及时设置为null
内存溢出：内存空间已满，不够用，定义的数据没有足够的空间存储










