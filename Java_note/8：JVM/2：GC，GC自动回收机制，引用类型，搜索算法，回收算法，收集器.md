

### 1：垃圾：没有任何引用所指向的对象

回收过程是透明的，并不一定看到垃圾就回收，若想快一些，可以调用System.gc();

### 2：垃圾回收器（Garbage Collection）

JVM自带的一个优先级很低的线程，用于回收没有任何引用所指向的对象，不 同的虚拟机平台，实现的方法也	各不相同

  目的：
	1:安全性考虑
	2:减少内存泄露
	3:减少程序员工作量

### 3：JVM 垃圾自动回收机制（GC）：主要进行回收的内存是JVM中的方法区和堆

   1：对于堆中的对象，主要用根搜索判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收

   2：对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类,就可以被回收

虽然存在着垃圾回收机制，但是可能会存在"无用但可达"的对象（出栈对象），这些对象不能被 GC 回收，因此也会导致内存泄露的发生 



### 4：Java中的引用类型

   根据对引用的不同需求，又分成了4种引用，每种引用的回收机制都是不同的
   Java中对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用

决定对象的生命周期

强引用（StrongReference）
   new的对象拥有强引用的对象，那么垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题

软引用（SoftReference）
   如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存
   软引用是主要用于内存敏感的高速缓存，收集软可及的对象，可能解决内存吃紧问题，避免内存溢出

弱引用（WeakReference） 
  如果一个对象只具有弱引用，那该类就是可有可无的对象，因为只要该对象被 gc 扫描到不管内存是否够用都会把它干掉，这些对象只能生存到下次GC之前

不能决定对象的生命周期

虚引用（PhantomReference） 
  "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪某个对象被垃圾回收的活动



### 5：Java对象在内存中的状态

可达的/可触及的：
　　Java对象被创建后，如果被一个或多个变量引用，那就是可达的，即从根节点可以触及到这个对象
　　其实就是从根节点扫描，只要这个对象在引用链中，那就是可触及的

可恢复的：
　　Java对象不再被任何变量引用就进入了可恢复状态
　　在回收该对象之前，该对象的finalize()方法进行资源清理，如果在finalize()方法中重新让变量引用该对象
    则该对象再次变为可达状态，否则该对象进入不可达状态       

```java
   protected void	finalize()
```

不可达的：
　　Java对象不被任何变量引用，且系统在调用对象的finalize()方法后依然没有使该对象变成可达状态（该对象依然没有被变量引用）那么该对象将变成不可达状态,当Java对象处于不可达状态时，系统才会真正回收该对象所占有的资源



### 6：搜索算法：搜索定位这些无用的对象（垃圾）

  1：引用计数器算法（废弃） 
     引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为对象不再被使用，是“垃圾”了

 缺陷：不能解决对象的循环引用问题

  2：根搜索算法（使用） ：可达性分析(Reachability Analysis) 
	根搜索算法是通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（Reference Chain）当一个对象没有被GC Roots的引用链连接的时候，说明这个对象是不可用的或者不可达的

```java
GC roots（GC根），在JAVA语言中，可以当做GC roots的对象有以下几种：

  		1：栈（栈帧中的本地变量表）中引用的对象
		2：本地方法栈中JNI（一般说的Native方法）引用的对象
		3：方法区中的静态成员
		4：方法区中的常量引用的对象（全局变量），指的是声明为final的常量值

?    
```



### 7：回收算法：算法搜索到无用对象之后，就是回收过程

标记-清除算法、复制算法、标记-整理算法，这三种算法都扩充了根搜索算法

1：标记―清除算法（Mark-Sweep）
     标记―清除算法包括两个阶段：“标记”和“清除”。在标记阶段，确定所有要回收的对象，并做标记。清除阶段
     紧随标记阶段，将标记阶段确定不可用的对象清除

缺陷：标记―清除算法是基础的收集算法，标记和清除阶段的效率不高，而且清除后回产生大量的不连续空间，
      这样当程序需要分配大内存对象时，可能无法找到足够的连续空间


2：标记―整理算法（Mark-Compact） ---老生代
     标记―整理算法和标记―清除算法一样，但是标记―整理算法是把标记的存活对象往内存的一端移动，然后直接回收边界以外的内存


3：复制算法（Copying） -----新生代
     复制算法是把内存分成大小相同的两块，每次使用其中一块，当垃圾回收的时候，把存活的对象复制到另一块上，
     然后把这块内存整个清理掉

缺陷：复制算法实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率不高

现实中的虚拟机复制算法：
 将java堆 内存分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，8:1:1
 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的 Survivor空间,HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，
 每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费

新生代中的对象98%都是“朝生夕死”的，当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以直接把大对象进入老年代

4：分代收集（Generational Collection)
     分代收集是根据对象的存活时间把内存分为新生代和老年代，根据各个代对象的存活特点，每个代采用不同的垃圾回收算法

    一般是把Java堆分为新生代和老年代：存活时间短的对象归为新生代，存活时间长的对象归为老年代
    永久代：即方法区
    
    存活率低：少量对象存活，适合复制算法
    在新生代中，每次GC时都发现有大批对象死去，只有少量存活（新生代中98%的对象都是“朝生夕死”），那就选用复制算法
    只需要付出少量存活对象的复制成本就可以完成GC
    存活率高：大量对象存活，适合用标记-清理/标记-整理
    在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC

注：老年代的对象中，有一小部分是因为在新生代回收时，老年代做担保，进来的对象,绝大部分对象是因为很多次GC都没有被回收掉而进入老年代



### 9：垃圾收集器

   1：Serial收集器（串行收集器）
	  是一个单线程的收集器,它进行垃圾收集时,必须暂停其他所有的工作线程(Stop-The-World:将用户正常工作的线程全部暂停掉)直到它收集结束

?		新生代采用复制算法，Stop-The-World，老年代采用标记-整理算法，Stop-The-World

当它进行GC工作的时候，虽然会造成Stop-The-World，但它存在的原因，正是因为它的简单而高效
Serial收集器:是虚拟机运行在client模式下的默认新生代收集器）

   2：ParNew收集器：Serial收集器的多线程版本，多个Serial收集器线程一起GC,运行在server模式下的首选新生代收集器

   3：G1收集器：面向服务端应用的收集器
	1：并行并发：G1使用多个CPU来缩短Stop-The-World停顿时间，通过并发可以让java程序继续运行
	2：分代收集
	3：空间整合：结合多种垃圾收集算法，不会产生内碎片
	4：可预测的停顿：低停顿的同时实现高吞吐，可以明确指定M毫秒的时间片内，消耗在垃圾收集上的时间不能超过N毫秒

   4：CMS收集器（Concurrent Mark Sweep：并发标记清除）:一种以获取最短回收停顿时间为目标的收集器
	适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短
	

?	1：只会回收老年代和永久代，不会回收新生代
	2：是一种预处理垃圾回收器，会在内存用尽之前，完成回收操作，有一个阈值，默认是老年代或永久代达到92%.
	









