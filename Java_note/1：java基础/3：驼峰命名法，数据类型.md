### 除数不能为 0：java.lang.ArithmeticException

​		无限乘以0，结果为NAN
​		无限除以0，结果不变，还是无限
​		无限做除了乘以0，做意外的运算，结果还是无限

```java
System.out.println(1%0.0);  //NAN,是Not a Number的缩写 非数,取余	
System.out.println(1/0.0);  //Infinity(无穷大)无穷大
System.out.println(2.0/0); //Infinity,自动类型转换2.0/0.0
System.out.println(0.0/0); //NAN
```

### 编码规范：

- 括号成对出现；
- 一级相对上级缩进一个tab
- 指令后面一定要有英文编辑模式下的“;
- 注释：对当前的代码进行解释说明，增强代码的可读性，在编译或者解释执行过程中没有任何意义

### java中的注释有三种：

​	单行注释： //说明
​	多行注释：/*说明*/
​	段落注释：(文档注释)
​			/**

​				说明
​			*/
 // TODO(姓名)：将要做的事

段落注释：通过javadoc工具，把该注释中的内容，生成HTML文档说明

### 标识符：在程序中对目标进行表示的符号------类名，常量名，变量名，方法名，块名

​	注意：
​		1：字母，数字，$，_
​		2:  不能以数字开头
​		3：区分大小写
​		4：不能使用关键字或者保留字

###### 变量：在程序中一个目标的数据发生变化，其就是变量

###### 常量：在程序中一个目标的数据不发生变化，其就是常量 static final int x;

命名规则：驼峰命名法	（大驼峰和小驼峰）

前提：因名知意
​		1：类名：一个单词首字母大写，如果多个单词每个单词首字母都大写
​		2：变量名,方法名:如果一个单词都小写，多个单词从第二个单词开始每个单词首字母都大写
​		3：常量名：一个单词每个字母都大写，多个单词之间用_链接，并且每个单词都大写
​		

### 数据类型：用来对数据进行分类的，四类八种

###### 	java中的数据类型有两大类：基本数据类型  +  引用数据类型（对象型数据类型，复合数据类型）

基本数据类型：

###### 		整型：

​			byte  8位---一个字节  -128-127
​			short 16位---两个字节	-32768-32767
​			int   32位---四个字节 -2(31)---2(31)-1
​			long  64位---八个字节  

###### 		浮点型：

​			float 32位---四个字节
​			double 64位---八个字节

因为double是64位以及小数点后精确到16位，float是32位，小数点后精确到7位，不管位数还是精确度呈二倍关系，因此把double叫做双精度型浮点数，float叫做单精度型浮点数

###### 		布类型	

​			boolean  8位--一个字节（true：1，false:0）

###### 		字符型：

​			char 16位---两个字节(unicode)
​			**char 本质上是一个整数，所有字符的运算都会转换成对应的ACALL码进行运算**

**char本质上是一个占用两个字节的无符号正整数**，这个正整数对应于Unicode编号，用于表示那个Unicode编号对应的字符
由于固定占用两个字节，char只能表示Unicode编号在65536以内的字符，而不能表示超出范围的字符



### 有符号位

**一个+0表示为：00000000，一个-0表示为：1000000，因为符号位不算在里面，所以就会有两个0，所以从一开始发明二进制的时候，就把-0规定为-128，如此二进制的补码就刚好在计算机中运作中吻合**

**原因：**首先看-0，[-0]原码=1000 000，其中1是符号位，根据反码规定，算出[-0]反码=1111 1111，再看-128，[-128]原码=1000 000，假如让-128也有反码，根据反码规定，则[-128]反码=1111 1111，会发现，-128的反码和-0的反码相同，所以为了避免面混淆，有了-0，便不能有-128，这是反码规则决定的

公式：计算一个数据类型的数据大小范围：-2^（字节数*8-1）~2^(字节数*8-1)-1

	声明二进制 ：int mark=0b10111111;     0.....   0x.... 

注意：	

​	    1：jvm中默认数据的字面长度是默认是int类型，声明一个long类型的变量在值后面加 L/l
​		2：浮点数字面长度默认是double，要声明一个float类型的变量，在值后加F/f
​		3：声明一个char类型的变量在值上必须加单引号
​

### double 和 float 的区别:

1：double精度高，有效数字16位，float精度7位
​2：但double消耗内存是float的两倍，double的运算速度比float慢得多，能用单精度时不要用双精度（以省内存，加快运算速度）

### 运算注意：

###### a += 4 和 a =a+4的区别，a 为byte类型

两个不一样，**在第二个中，a+4时，会进行 自动类型转换 ，所以 a+4 会转换成int类型，而变量a还是byte类型，将int 类型的a+4赋值给byte类型的a ,无疑会报错**，需要强制转换

 **而“+=”是java中的一个运算符**，而不是两个，所以在运算时 会进行自动类型转换

### 精度丢失

​	由于浮点数由两部分组成：指数和尾数,如果在这个转换的过程中，浮点数参与了计算，那么转换的过程就会变得不可预知，并且变得不可逆,**用BigdDecimal,BigInteger**

重点看

### 枚举类型：是一个被命名的整型常数的集合，用于声明一组带标识符的常数

```java
public enum Color
{
	RED,BLUE,WRITE
	//public static final Color red = new Color();声明常量
}
public enum SeasonEnum {
  	// Enum 的实例，默认调用了构造器
    SPRING("春天"),SUMMER("夏天"),FALL("秋天"),WINTER("冬天");
    
    private final String name;
    private SeasonEnum(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
}

switch(color) {
  case RED:
    color=Signal.GREEN;
    break;
  case YELLOW:
    color=Signal.RED;
    break;
  case GREEN:
    color=Signal.YELLOW;
    break;
}
```



### java.lang.Enum

​	Java 中的每一个枚举都继承自 java.lang.Enum 类，当定义一个枚举类型时，每一个枚举类型成员都可以看作是 Enum 类的实例,所以不能再继承

- Enum：就是把有确定几个值的全局变量，放在一个类中，方便使用，编译之后，其实就是一个类，extends Enum
- values() ： 以数组形式返回枚举类型的所有成员，Signal.values()[i]
- 枚举类的所有实例都必须放在第一行展示，默认添加了 private static final
- 实际上在第一行写枚举类实例的时候，默认是调用了构造器的，所以此处需要传入参数，因为没有显式声明无参构造器，只能调用有参数的构造器
- 枚举类的构造器只能是私有的

enum与Enum之间的区别？
	enum是声明枚举的关键字，Enum是java中的一个类。使用enum声明的枚举的实质是该枚举类型继承Enum
		  



