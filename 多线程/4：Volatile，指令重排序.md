### Java 并发机制的底层实现

------

##### 1：volatile

​	更轻量级的变量同步机制，它不会引起线程上下文的切换，但是volatile 变量的同步性较差，而且其使用也更容易出错

1. 保证可见性，不保证原子性
   - volatile 变量更新时，JVM会把该线程本地内存中的缓存的变量强制刷新到主内存中去，这个写操作会导致其他线程中缓存的此变量无效
2. 禁止指令重排 
   - 用 volatile 修饰的共享变量，在编译时，会在指令序列中插入**内存屏障（lock）**来禁止指令重排序
   - 读多写少的场景下，或者做状态标志，主要是写操作的时候改变

##### 2：内存屏障

​	被volatile关键字时，编译时会多出一个 **lock 汇编指令**，lock 汇编指令实际上就是内存屏障

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面
2. 它会强制的将对缓存的修改操作立即写入主存
3. 如果是写操作，它会导致其他CPU中对应的缓存变量无效，执行写操作时，需要重新执行写操作

##### 3：volatile的使用优化

​	JUC中新增一个队列集合类LinkedTransferQueue<E>，它在使用volatile变量时，用一种追加字节的方式（将共享变量追加到64字节）来优化队列出队和入队的性能

- 如果队列的头节点和尾节点都**不足64字节**的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。
- LinkedTransferQueue 使用追加到64字节的方式来**填满高速缓冲区的缓存行**，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定，主要取决于处理器的缓存行的大小。

##### 4：指令重排序

​	指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段

- 重排序操作不会对存在数据依赖关系的操作进行重排序
- 重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不会被改变