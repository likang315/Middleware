### 并发编程的内存模型

------

​	多线程并发访问同一资源时，就会形成“抢”的现象，由于线程切换实际不确定，可能导致执行代码顺序的混乱，严重时会导致系统瘫痪，例：上厕所、上锁

- 线程安全的核心：对共享且可变状态的资源访问进行管理，例：加锁、final、volitile

##### 1：线程同步和异步

- 同步执行：多个线程排队有序执行
- 异步执行：多个线程可以同时进行

##### 2：顺序一致性

​	一个线程在写一个变量，另一个线程在读同一个变量，而且写和读没有通过同步来排序，当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果；如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序

- JMM对**正确同步的多线程程序**的内存一致性做了保证，如果程序是正确同步的，程序的执行将具有顺序一致性

##### 3：顺序一致性内存模型

​	顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。在任意时间点**最多只能有一个线程可以连接到内存**。当多个线程并发执行时，图中的开关装置能把**所有线程的所有内存读/写操作串行化**（即在顺序一致性模型中，所有操作之间具有全序关系）

- 因为顺序一致性内存模型中的每个操作必须立即对任意线程可见，而JMM模型就没有这个保证

![](https://github.com/likang315/Java-and-Middleware/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png?raw=true)

##### 4：顺序一致性模型保证对所有的内存读/写操作都具有原子性

- 总线事务包括读事务（Read Transaction）和写事务（WriteTransaction）
  - 读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，**总线会同步（总线仲裁）试图并发使用总线的事务**。在一个处理器执行总线事务期间，总线会禁止其他的处理器和I/O设备执行内存的读/写

##### 5：锁的内存语义

​	锁是并发编程中最重要的同步机制。锁除了让**临界区互斥执行**外，还可以让释放锁的线程向获取同一个锁的线程发送消息

- 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中
- 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，重写读取
- 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息（共享内存）

###### 锁释放-获取的内存语义的实现

1. 利用volatile变量的写-读所具有的内存语义
2. 利用CAS所附带的volatile读和volatile写的内存语义

##### 6：final域的内存语义

​	final域与锁和volatile相比，对final域的读和写更像是普通的变量访问，通过内存屏障来实现

###### 对于final域，编译器和处理器遵守两个重排序规则

1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
2. 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序

###### 写final域的重排序规则，保证对final的写入正确

1. JMM禁止编译器把final域的写重排序到构造函数之外
2. 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外

###### 读final域的重排序规则，保证对final域的读取正确

- 在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（这个规则仅仅针对处理器）
- 因为这两个操作存在间接依赖关系，编译器会在读final域操作的前面插入一个LoadLoad屏障，但是少数处理器允许对存在间接依赖关系的操作做重排序

```java
public class FinalExample {
    int i;　　　　　　　　　　 // 普通变量
    final int j;　　　　　　　　 // final变量
    static FinalExample obj;
    public FinalExample () {　　 // 构造函数
        i = 1;　　　　　　　　 // 写普通域
        j = 2;　　　　　　　　 // 写final域
    }
    public static void writer () {　 // 写线程A执行
    		obj = new FinalExample ();
    }
    public static void reader () {　 // 读线程B执行
        FinalExample object = obj; // 读对象引用
        int a = object.i;　　　　　 // 读普通域
        int b = object.j;　　　　　 // 读final域
    }
}
```

###### final域为引用数据类型

- 在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序



