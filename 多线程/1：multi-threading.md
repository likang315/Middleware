## 多线程  ：

------

##### 1：进程（process）：是操作系统中能独立运行并作为资源分配的基本单位，由核数决定

1. ###### 进程就是一个运行中的程序																			

   - 程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体

2. ###### 进程是一个实体

   - 每一个进程都有它自己的地址空间，一般包括文本区域（text region）、数据区域（data region）和堆栈（stack region）
     - 文本区域：存储处理器执行的代码
     - 数据区域：存储变量和进程执行期间使用的动态分配的内存
     - 堆栈区域：存储着活动过程调用的指令和本地变量

3. ###### 进程：分为系统进程和用户进程

   - 系统进程：用于完成操作系统各种功能的进程
     - 内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序
   - 用户进程：由用户启动的进程
     - 用户态: 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取

##### 2：线程（thread）：线程是 cpu 调度的最小单位

- 标准的线程由线程ID，当前指令指针(PC），寄存器集合 和 堆栈组成										
- 进程中包含一组线程，同属一个进程的其它线程共享进程所拥有的全部资源，线程切换开销小
- 线程只能归属于一个进程，并且只能访问该进程所拥有的资源
- 当操作系统创建一个进程后，该进程会自动申请一个名为主线程的线程（master）

##### 3：协程：

​	其执行过程更类似于子程序，或者说不带返回值的函数调用

##### 4：多线程：在同一个时间段，计算机系统中如果允许两个或两个以上的线程处于运行状态

- 总进程数<= CPU数量：并行运行																			
- 总线程数>   CPU数量：并发运行

###### 多线程并发原理：

​	感观上多个线程能同时运行的技术,事实上线程并发运行时，OS将CPU时间分为很多时间片段（时间片），尽可能的均匀分配给每一个线程，获取时间片段的线程被CPU运行而其他线程全部等待，这种现象称为并发

##### 5：线程的五种状态

![](https://github.com/likang315/Java-and-Middleware/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png?raw=true)

- 新建状态(New)：当线程对象对创建后，即进入了新建状态
- 就绪状态(Runnable)：当调用线程对象的start()方法，线程即进入就绪状态
  - 处于就绪状态的线程，说明此线程已经做好了准备，随时等待CPU调度执行
- 运行状态(Running)：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态
- 阻塞状态(Block)：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态
  - 等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态
  - 同步阻塞：线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态
  - 其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态
    - 当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态
- 死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期，对象被垃圾回收

##### 6：线程的调度算法

- 先来先服务（FIFS）
- 短作业优先调度
- 优先级调度算法：在线程等待队列中选择优先级最高的来执行
- 时间片轮转算法
- 多级反馈队列调度算法：把时间轮转与优先级调度相结合，把进程按优先级分成的队列，先按照优先级调度，优先级相同的，按照时间片轮转

##### 7：两种线程调度模型：Java使用的是抢占式调度模型

1. 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配 CPU 的时间片给每个线程占用
2. 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些
   - 默认使用