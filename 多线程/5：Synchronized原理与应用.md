### Synchronized 原理与应用

------

##### 1：synchronized

​	Java中的关键字，是一种同步锁，为重量级锁，即锁住了当前对象也把锁给了当前对象

###### Java中的每一个对象都可以作为锁

- 对于静态同步方法，锁是当前类的Class对象
- 对于同步方法块，锁是Synchonized括号里配置的对象
- 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁

###### 锁原理

- synchronized：是通过**字节码指令**来实现的
  - synchronized 同步块：编译后会在同步块前后形成 monitorenter 和 monitorexit 两个字节码指令
    - 执行 monitorenter 指令时需要先获得对象的锁(每个对象有一个监视器锁monitor)，如果这个对象获取锁或者当前线程已经获得此锁（可重入锁），那么锁的计数器+1。如果获取失败，那么当前线程阻塞，直到锁被另一个线程释放，执行monitorexit指令时，计数器 -1，当为 0 的时候锁释放
    - 任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态
  - synchronize 同步方法：编译后会在方法访问处，添加字节码指令 ACC_SYNCHRONIZED  标志
    - 不管是monitorenter，还是ACC_SYNCHRONIZED本质都是对一个对象的监视器（monitor）进行获取，而这个获取是排他的

###### synchronized：同步块

​	要求多个线程对该块内的代码依次排队执行，前提条件是同步监视器对象，可以有效的缩小同步范围，并保证并发安全的同时尽可能的提高效率

- 当一个线程访问对象中的synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块，因为非synchronized不需要monitor锁

```java
// this锁：指monitor对象
synchronized (this) {
	// todo
}

// 有一个明确的对象作为锁时
public void  method3(SomeObject obj) {
   // 非this锁：monitor对象
   synchronized (obj) {
      // todo
   }
}

// 当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁
private Byte[] local= new Byte[0];
synchronized (local) {
  // todo
}
```

###### synchronized：同步方法

​	即：多个线程不能同时进入方法内部执行

- synchronized 同步方法：在一个线程调用该方法时将该方法所属对象加锁，其他线程在执行此方法时，由于执行此方法的线程没有释放锁，所以只能在方法外阻塞，直到持有同步锁的线程将方法执行完毕，释放锁，此线程获取同步锁
- **同一个锁对象可以产生互斥作用，不同锁对象不能产生互斥作用**
- 若修饰静态方法：属于类的，具有同步效果，与对象无关

```java
public synchronized void synchronizedMethod() {
  // ...
}
// synchronized 修饰的静态方法锁定的是这个类的所有对象
public static synchronized void method() {
	// ...
}
```

###### 注意：

1. 被 synchronized修饰方法，不能被继承，若需要同步，在子类的重写该方法添加 synchronized 关键字
2. 在接口中定义方法时不能使用 synchronized 关键字
3. 构造方法不能使用 synchronized关键字，但可以使用 synchronized 代码块来进行同步

###### synchronized 类锁：Class锁

- synchronized 作用于一个类时，每个类有且只有一个Class对象，即类的 Class 对象锁，类的所有对象都是同一把锁

```java
synchronized (ClassName.class) {
	// todo
}
```

##### 2：Java 对象头

- Hotspot 虚拟机的对象头主要包括两部分数据：
  - Mark Word （标记字段）+  Class Metadata Address（类型指针）+ Array Length （数组长度）
- Mark word：存储锁的信息，和hashCode()值
- Class Metadata Address：存储到对象类型数据的指针，用于确定是哪个类的实例
-  Array Length：如果当前对象是数组，则存储的是数据的长度

##### 3：Mark Word

- 一个非固定的数据结构，它会根据对象的状态复用自己的存储空间
- 大小：一个字节

![](https://github.com/likang315/Java-and-Middleware/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/mark%20word.png?raw=true)

##### 4：Monitor：监视器锁

- 内置锁：一种同步机制，包含在对象中
- 所有的Java对象是天生带着Monitor，每一个Java对象都有成为Monitor的潜质，它叫做内置锁或者Monitor锁

###### 线程和Monitor相关联

​	每一个线程都有一个可用 monitor record 列表，每一个被锁住的对象都会和一个monitor关联（对象头的 Mark Word 中的 Lock Word 指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用

##### 5：锁的状态：

​	阻塞或唤醒一个线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长

- 锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率
  - 无锁状态
  - 偏向锁状态
  - 轻量级锁状态
  - 重量级锁状态（自旋锁状态）

##### 6：重量级锁

​	在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”

线程的阻塞和唤醒需要 CPU从 用户态转为 内核态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁

##### 7：自旋锁

​	让该线程自旋一段时间，不会被立即挂起（释放CPU时间片），看持有锁的线程是否会很快释放锁

- 执行一段无意义的循环（自旋），自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起
- JDK1.6中默认开启，同时自旋的**默认次数为10次**，可以通过参数-XX:PreBlockSpin来调整
- JDK1.6以后引入自适应的自旋锁，让虚拟机会变得越来越聪明
- 自旋锁的实现原理：CAS原子操作
  - AtomicInteger 中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功

```java
public final int getAndSetInt(Object var1, long var2, int var4) {
    int var5;
    do {
      var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var4));

    return var5;
}
```

##### 8：自适应自旋锁

​	自适应意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

- 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源
- 缺点：由于锁竞争时间不确定，自适应自旋也没能彻底解决该问题，如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值

##### 9：轻量级锁

​	如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗

- 轻量级锁：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间**，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word**，线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），膨胀为自适应自旋锁

###### 轻量级释放锁

​	释放锁时，会使用CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁

###### 性能消耗

​	如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费

###### 两个线程同时争夺锁，导致锁膨胀的流程

![](https://github.com/likang315/Java-and-Middleware/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png?raw=true)

##### 10：偏向锁

​	偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS

- 偏向锁：当一个线程访问同步块并获取锁时，会在**对象头和栈帧中的锁记录里存储锁偏向的线程ID**，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）；如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程
- 如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁，维护偏向锁的过程就成了浪费时间的过程

###### 偏向锁的释放

​	偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争，偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）

- 其步骤如下：
  1. 暂停拥有偏向锁的线程，检查偏向锁的线程是否还活着
  2. 撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态
  3. 最后唤醒暂停的线程

###### 偏向锁的关闭

- 如果确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁
- -XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态

##### 11：偏向锁、轻量级锁、自旋锁，重量级锁 适用于不同的并发场景：

- 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁
- 轻量级锁：无实际竞争，多个线程交替依次使用锁，允许短时间的锁竞争
- 自旋锁：有实际竞争，锁竞争时间较短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能
- 重量级锁：有实际竞争，且锁竞争时间较长

##### 12：锁消除、锁粗化

###### 锁消除

- 有些情况下，JVM检测到不可能存在共享数据竞争，不会使用到锁，这是JVM会对这些同步锁进行锁消除，锁消除的依据是逃逸分析的数据支持 

###### 锁粗化

- 就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的加锁
- 使用同步锁的时候，需要让同步块的作用范围尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁，如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念



