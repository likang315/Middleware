### 多线程  ：

------

##### 1：进程（process）：是操作系统中能独立运行并作为资源分配的基本单位，由核数决定

1. ###### 进程就是一个运行中的程序																			

   - 程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体

2. ###### 进程是一个实体

   - 每一个进程都有它自己的地址空间，一般包括文本区域（text region）、数据区域（data region）和堆栈（stack region）
     - 文本区域：存储处理器执行的代码
     - 数据区域：存储变量和进程执行期间使用的动态分配的内存
     - 堆栈区域：存储着活动过程调用的指令和本地变量

3. ###### 进程：分为系统进程和用户进程

   - 系统进程：用于完成操作系统各种功能的进程
     - 内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序
   - 用户进程：由用户启动的进程
     - 用户态: 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取

##### 2：线程（thread）：线程是 cpu 调度的最小单位

- 标准的线程由线程ID，当前指令指针(PC），寄存器集合 和 堆栈组成										
- 进程中包含一组线程，同属一个进程的其它线程共享进程所拥有的全部资源，线程切换开销小
- 线程只能归属于一个进程，并且只能访问该进程所拥有的资源
- 当操作系统创建一个进程后，该进程会自动申请一个名为主线程的线程（master）

##### 3：协程：

​	其执行过程更类似于子程序，或者说不带返回值的函数调用，在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

##### 4：多线程：在同一个时间段，计算机系统中如果允许两个或两个以上的线程处于运行状态

- 总进程数<= CPU数量：并行运行																			
- 总线程数>   CPU数量：并发运行

###### 多线程并发原理：

​	感观上多个线程能同时运行的技术,事实上线程并发运行时，OS将CPU时间分为很多时间片段（时间片），尽可能的均匀分配给每一个线程，获取时间片段的线程被CPU运行而其他线程全部等待，这种现象称为并发

##### 5：线程的五种状态

![](https://github.com/likang315/Java-and-Middleware/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png?raw=true)

- 新建状态(New)：当线程对象对创建后，即进入了新建状态
- 就绪状态(Runnable)：当调用线程对象的start()方法，线程即进入就绪状态
  - 处于就绪状态的线程，说明此线程已经做好了准备，随时等待CPU调度执行
- 运行状态(Running)：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态
- 阻塞状态(Block)：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态
  - 等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态
  - 同步阻塞：线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态
  - 其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态
    - 当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态
- 死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期，对象被垃圾回收

##### 6：线程的调度算法

- 先来先服务（FIFS）
  - 并不能保证紧急的任务优先处理
- 短作业优先调度
  - 虽然节省了任务执行时间，但是并不能保证紧急的任务优先处理
- 优先级调度算法：在线程等待队列中选择优先级最高的来执行
  - 保证了紧急任务的执行，但是多个紧急的任务执行时，并没有考虑他的效率
- 时间片轮转算法
  - 导致任务可能没有执行完，就会被切换，线程间的切换，唤醒非常浪费资源
- 多级反馈队列调度算法：把时间轮转与优先级调度相结合，把进程按优先级分成的队列，先按照优先级调度，优先级相同的，按照时间片轮转
  - 既保证了紧急的任务优先处理，又保证了任务执行的效率

##### 7：两种线程调度模型：Java使用的是抢占式调度模型

1. 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配 CPU 的时间片给每个线程占用
2. 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些
   - 默认使用

##### 8：线程同步和异步

- 同步执行：多个线程必须排队执行
- 异步执行：多个线程可以同时进行

##### 9：线程间的通信方式

1. 线程同步机制：多个线程需要同时访问同一个方法时，谁获取了锁（synchronized），谁先执行
2. wait / notify机制：Object 类的方法
   - wait()：当线程执行 wait() 时，会把当前的锁资源释放，让出CPU（时间片），进入就绪状态
   - notify()：任意唤醒一个处于等待获取该对象锁的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized块）后再释放锁
   - notifyAll()：会唤醒所有处于等待该对象锁的线程

##### 10：进程间通信方式

1. 管道(pipe)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用
   - 进程的亲缘关系通常是指父子进程关系
2. 消息队列(MessageQueue)：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
3. 共享存储(SharedMemory)：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
4. 信号量 Semaphore(P,V)：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段