### 线程池

​	降低资源消耗，提高响应速度，提高线程可管理性

------

##### 1：线程池

- 重复利用已经创建的线程，减少创建线程和销毁线程的开销，不需要等到线程创建就能立即执行
- 使用线程池可以对线程统一分配，调优和监控
- 当我们的应用需要创建大量线程或者发现线程会频繁的创建和销毁时就应当考虑使用线程池来维护线程

##### 2：线程池原理

![](https://github.com/likang315/Java-and-Middleware/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png?raw=true)

1. 提交任务
2. 判断核心线程池（corePoolSize：核心线程数）是否都处于工作状态，若没有，则创建线程执行任务
3. 若否出与工作状态，则查看阻塞队列（BlockingQueue）是否已满，未满的话，将任务存储在队列里
4. 若阻塞队列已满，再看线程池（maximumPoolSize：最大线程数量）中的线程是否都处于工作状态，若没有，创建线程执行任务，若都处于工作状态，则按照拒绝处理任务策略（handler）处理无法执行的任务

##### 3：ThreadPoolExcutor

- ThreadPoolExcutor 执行excute( ) 示意图
- 在步骤一、三创建线程都会要求获取全局锁，要尽可能的避免获取全局锁

![](https://github.com/likang315/Java-and-Middleware/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadPoolExcutor.png?raw=true)

##### 4：创建线程池的参数

- ###### corePoolSize

  - 核心线程池的大小
  - 构建线程池后，并不会立即 创建线程，当执行任务时，如果当前线程数如果小于corePoolSize，则创建一个线程，当前线程数等于corePoolSize，会将任务放入队列中

- ###### workQueue：任务的队列（4种）

  - ArrayBlockingQueue：
    -  基于数组结构的有界阻塞队列，按FIFO排序任务
  - LinkedBlockingQuene：
    - 基于链表结构的无界阻塞队列，按FIFO排序任务，吞吐量高于ArrayBlockingQuene
    - ExecutorService newFixedThreadPool( ) 使用此队列
  - SynchronousQuene：
    - 不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene
    - ExecutorService newCachedThreadPool( )  使用此队列
  - priorityBlockingQuene：
    - 具有优先级的无界阻塞队列

- ###### maximumPoolSize：

  - 线程池最大数量
  - 如果任务队列已满时，并且创建的线程数小于最大线程数，则会创建线程执行任务
  - 若使用无界队列则此参数没有意义

- ###### keepAliveTime：

  - 线程活动保持时间，工作线程空闲后，保持存活的时间
  - 默认情况下，如果当前线程数大于corePoolSize，并且存在线程如果没有任务执行，当空闲的时间大于keepAliveTime时，会终止该线程，直到线程数不超过corePoolSize

- ###### TimeUnit：

  - 线程活动保持时间的单位
  - 毫秒：MILLISECONDS
  - 微妙：MICROSECONDS
  - 纳秒：NANOSECONDS

- ###### rejectedExecutionHandler：拒绝策略（4种）

  - AbortPolicy：直接抛出异常，默认策略
  - CallerRunsPolicy：只用调用者所在的线程来执行任务
  - DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务
  - DiscardPolicy：不处理，丢弃掉
  
- ###### ThreadFactory：

  - 用于设置创建线程的工厂，通过线程工厂可以使创建的线程具有意义的名字

  ```java
  new ThreadFactoryBuilder().setNameFormat("XX-task-%d").build();
  ```

##### 5：操作线程池

- execute( )：
  - 用于提交不需要返回值的任务，所以无法判断是否被线程池执行成功
  - 输入的任务一个Runnable 的实例
- submit( ):
  - 提交需要有返回值的任务，线程池会一个 Future 对象，通过Future 可以知道线程是否执行成功
  - Future 的get( ) 方法：阻塞当前线程直到任务完成
    - get（long timeOut，TimeUnit unit）：阻塞timeOut时间，返回，任务可能为执行完成，但是超时了
- shutdown( )：
  - 将线程池的状态设置为SHUTDOW，然后遍历工作线程，调用interupt（），中断没有正在执行任务的线程，若有现成正在执行任务，等待任务执行完毕
- shutdownNow( )：
  - 将线程池的状态设置为STOP，中断所有工作线程，不区分是否正在执行任务
- isShutdown( )：
  - 只要调用关闭方法就会返回ture，当所有任务执行完成后，才表示线程池关闭成功
- isTerminaed( ):
  - 线程池关闭成功，才会返回True

##### 6：线程池的状态

```java
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
```

- RUNNING：创建线程池后，初始状态为RUNNING
- SHUTDOWN：调用shutdown（）后，线程池处于SHUTDOWN状态
- STOP：调用shutdownNow（）后 ，线程池处于STOP状态
- TERMINATED：当线程关闭成功时，状态为TERMINATED
