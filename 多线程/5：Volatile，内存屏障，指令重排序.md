##### 1：volatile

​	更轻量级的变量同步机制，它不会引起线程上下文的切换和调度，但是volatile 变量的同步性较差，而且其使用也更容易出错

1. 保证可见性，不保证原子性
   - volatile 变量更新时，JVM会把该线程本地内存中的变量强制刷新到主内存中去，这个写操作会导致其他线程中缓存的此变量无效
2. 禁止指令重排 
   - 用 volatile 修饰的共享变量，在编译时，会在指令序列中插入**内存屏障**来禁止指令重排序
   - 读多写少的场景下，或者做状态标志

##### 2：内存屏障

​	被volatile关键字时，会多出一个 **lock 前缀指令**，lock 前缀指令实际上相当于一个内存屏障

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面
2. 它会强制的将对缓存的修改操作立即写入主存
3. 如果是写操作，它会导致其他CPU中对应的缓存变量无效

##### 3：指令重排序

​	指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段

- 重排序操作不会对存在数据依赖关系的操作进行重排序
- 重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不会被改变