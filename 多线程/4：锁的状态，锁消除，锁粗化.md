### 锁的状态

------

​	synchronized 在操作同步资源之前需要给同步资源先加锁，这把锁就是存在 Java 对象头里的 monitor

##### 1：Java 对象头

​	Hotspot 虚拟机的对象头主要包括两部分数据：

- Mark Word （标记字段）+  Class Metadata Address（类型指针）
- Mark word：存储锁的信息，和hashCode()值
- Class Metadata Address：对象指向它的类元数据的指针，用于确定是哪个类的实例
  - 如果对象是数组，则存储的是数据的长度

##### 2：Mark Word

- 一个非固定的数据结构，它会根据对象的状态复用自己的存储空间
- 大小：一个字节

![](https://github.com/likang315/Java-and-Middleware/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/mark%20word.png?raw=true)

##### 3：Monitor：监视器锁

- 内置锁：一种同步机制，包含在对象中
- 所有的Java对象是天生带着Monitor，每一个Java对象都有成为Monitor的潜质，它叫做内置锁或者Monitor锁

###### 线程和Monitor相关联

​	每一个线程都有一个可用 monitor record 列表，每一个被锁住的对象都会和一个monitor关联（对象头的 Mark Word 中的 Lock Word 指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用

##### 4：锁的状态：锁的等级只可以升级，不可以降级

​	阻塞或唤醒一个线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长

- 重量级锁状态
- 轻量级锁状态
- 偏向锁状态
- 无锁状态

##### 5：重量级锁

​	在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”

线程的阻塞和唤醒需要 CPU从 用户态转为 内核态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁

##### 6：自旋锁

​	让该线程自旋一段时间，不会被立即挂起（释放CPU时间片），看持有锁的线程是否会很快释放锁

- 执行一段无意义的循环（自旋），自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起
- JDK1.6中默认开启，同时自旋的**默认次数为10次**，可以通过参数-XX:PreBlockSpin来调整
- JDK1.6以后引入自适应的自旋锁，让虚拟机会变得越来越聪明
- 自旋锁的实现原理：CAS原子操作
  - AtomicInteger 中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功

```java
public final int getAndSetInt(Object var1, long var2, int var4) {
  int var5;
  do {
    var5 = this.getIntVolatile(var1, var2);
  } while(!this.compareAndSwapInt(var1, var2, var5, var4));

  return var5;
}
```

##### 7：自适应自旋锁

​	自适应意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

- 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源
- 缺点：由于锁竞争时间不确定，自适应自旋也没能彻底解决该问题，如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值

##### 8：轻量级锁

​	如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗

- 轻量级锁：不需要申请互斥量，仅仅 将 Mark Word 中的部分字节，CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），膨胀为自适应自旋锁
- 当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁
- 同自旋锁相似：如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费

##### 9：偏向锁

​	偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS

- 偏向锁：假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中CAS记录 owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁
- 同样的，如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁，维护偏向锁的过程就成了浪费时间的过程

###### 偏向锁的释放

偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争，偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）

- 其步骤如下：
  1. 暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态
  2. 撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态

##### 10：偏向锁、轻量级锁、自旋锁，重量级锁 适用于不同的并发场景：

- 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁
- 轻量级锁：无实际竞争，多个线程交替依次使用锁，允许短时间的锁竞争		
- 自旋锁：有实际竞争，锁竞争时间较短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能
- 重量级锁：有实际竞争，且锁竞争时间较长

##### 11：锁消除、锁粗化

###### 锁消除

- 有些情况下，JVM检测到不可能存在共享数据竞争，不会使用到锁，这是JVM会对这些同步锁进行锁消除，锁消除的依据是逃逸分析的数据支持 

###### 锁粗化

- 就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的加锁
- 使用同步锁的时候，需要让同步块的作用范围尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁，如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念



