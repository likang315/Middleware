### 并发编程的挑战

------

##### 1：上下文切换

​	CPU通过**时间片分配算法**来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以**任务从保存到再加载的过程就是一次上下文切换**。CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。

- 因为线程有创建和上下文切换的开销，所以导致并发比一定比单线程执行快

##### 2：死锁

1. 一个线程T1持有锁L1并且申请获得锁L2，而另一个线程T2持有锁L2并且申请获得锁L1，因为默认的锁申请操作都是阻塞的，所以线程T1和T2永远被阻塞了，导致了死锁
2. 线程T1持有锁L1并且申请获得锁L2，而线程T2持有锁L2并且申请获得锁L3，而线程T3持有锁L3并且申请获得锁L1，这样导致了一个锁依赖的环路

###### 解决死锁的方法

1. 超时检测: 设置一个阈值，当任意一方等待时间超过预设的阈值时, 则回滚此线程，返回死锁
2. wait-for-graph 主动检测：通过“等待获取的锁” 和 “等待获取该锁的事务”, 构造出⼀张有向图如果图中存在回路, 就代表存在死锁, 一旦发现回路, 就将其中一个等待的事物回滚, 另⼀个事务就得以继续执行 ，被回滚的事务会返回"dead lock"

###### 避免死锁的方法

1. 避免一个线程同时获取多个锁
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
3. 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制

###### 死锁Demo

```java
public class DeadLockDemo {
        private static String A = "A";
        private static String B = "B";
        private void deadLock() {
            Thread t1 = new Thread(new Runnable() {
                @Override
                public void run() {
                    synchronized (A) {
                        try {
                          	// 防止t2线程未启动，t1线程已执行完毕
                            Thread.sleep(2000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        synchronized (B) {
                            System.out.println("1");
                        }
                    }
                }
            });
            Thread t2 = new Thread(new Runnable() {
                @Override
                public void run() {
                    synchronized (B) {
                        synchronized (A) {
                            System.out.println("2");
                        }
                    }
                }
            });
            t1.start();
            t2.start();
        }
  
  			public static void main(String[] args) {
            new DeadLockDemo().deadLock();
        }
}
```

