### 垃圾搜索、回收算法

------

[TOC]

##### 01：垃圾

- 没有被任何引用所指向的对象;
- 回收过程是透明的，并不一定看到垃圾就回收，若想快一些，可以调用 System.gc();

##### 02：垃圾回收器（Garbage Collection）

​	JVM自带的一个优先级很低的线程，用于回收没有任何引用所指向的对象，不同的虚拟机平台，实现的方法也各不相同;

###### 目的：

1. 安全性考虑
2. 减少内存泄露
3. 减少程序员工作量

##### 03：垃圾回收区域

- 主要进行回收的内存是 JVM 中的方法区和堆

1. 对于堆中的对象，主要用**根搜索算法**判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收
   - 可能会存在"无用但可达"的对象（出栈对象），这些对象不能被 GC 回收，因此也会导致内存泄露的发生;
2. 对于方法区中的常量和类，当**一个常量没有任何对象引用它**，它就可以被回收了，而对于类，如果可以判定它为**无用类**，就可以被回收;

###### 如何判定为无用类

- 该类所有的实例都已经被回收，即 Java 堆中不存在该类的任何实例，加载该类的ClassLoader已经被回收，该类对应的 java.lang.Class 对象没有在任何地方被引用，在任何地方都无法通过反射访问该类的方法；


##### 04：Java 中的引用类型

- Java 中对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用

###### 决定对象的生命周期

- **强引用（StrongReference）**：new Object( );
  - new 的对象拥有强引用的对象，**垃圾回收器绝不会回收它**。当内存空间不足，Java 虚拟机宁愿抛出 OOM 错误，使程序异常终止，也不会随意回收具有强引用的对象来解决内存不足问题；
- **软引用（SoftReference）**：Java.lang.ref.Softerference <T> 类
  - 如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它，如果**内存空间不足时 ，就会回收这些对象的内存**；
  - 软引用是主要用于**内存敏感的高速缓存（mybatis），收集软可及的对象**，可能解决内存吃紧问题，避免内存溢出；
- **弱引用（WeakReference）** ：java.lang.ref Class WeakReference<T> 类
  - 如果一个对象只具有弱引用，那该类就是**可有可无的对象**，**只要该对象被 gc 扫描到，不管内存是否够用都会把它干掉**，这些对象只能生存到下次GC之前；
  - 用范型确定所引用的对象

###### 不能决定对象的生命周期

- **虚引用（PhantomReference）【幽灵引用】** ：java.lang.ref Class PhantomReference<T>
  - PhantomReference(T referent, ReferenceQueue <? super q)  ：通过 get() 获取
  - "虚引用"顾名思义，就是**形同虚设**，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么**它就和没有任何引用一样，在任何时候都可能被垃圾回收**；
  - 虚引用主要用来跟踪某个对象被垃圾回收的活动；

##### 05：对象在内存中的状态

1. 可达的
  
   - Java对象被创建后，如果被一个或多个变量引用，那就是可达的，即从根节点可以触及到这个对象，就是从根节点扫描，只要这个**对象在引用链中，那就是可达的**;
2. 可恢复的
   - Java 对象不再被任何变量引用就进入了可恢复状态，在回收该对象之前，**该对象的finalize()方法进行资源清理**，如果在finalize()方法中重新让变量引用该对象，则该对象再次变为可达状态，否则该对象进入不可达状态;
   
   - ```java
     @Deprecated(since="9")
     protected void finalize() throws Throwable { }
     ```
3. 不可达的
  
   - Java 对象不被任何变量引用，且系统在调用对象的 finalize( ) 方法后依然没有使该对象变成可达状态，那么该对象将变成不可达状态，此时系统才会真正回收该对象所占有的资源；

##### 06：搜索算法：搜索定位出不可达对象

1. ###### 引用计数器算法（废弃）

   - 引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为对象不再被使用，是“垃圾”；
   - 缺陷：不能解决对象的**循环引用**问题
   - 强弱指针解决：若 A 强引用了 B，那 B 引用 A 时就需使用弱引用，当判断是否为无用对象时仅考虑强引用计数是否为 0，不关心弱引用计数的数量，但是会出现野指针问题；

2. ###### 根搜索算法（使用）：可达性分析(Reachability Analysis)

   - 通过一些 “GC Roots” 对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（Reference Chain），当一个对象没有被GC Roots的引用链连接的时，说明这个对象是不可达的；
   - GC roots（GC根），可以当做GC roots的对象有以下几种：
     1. 栈（栈帧中的本地变量表）中引用的对象
     2. 本地方法栈中JNI（一般说的Native方法）引用的对象
     3. 方法区中的静态变量
     4. 方法区中的常量引用的对象（全局变量），指的是声明为final的常量值

##### 07：回收算法：回收不可达对象

1. **标记—清除算法（Mark-Sweep）**老年代
- 标记—清除算法包括两个阶段：“标记”和“清除”；
   - 标记阶段：遍历所有的 GC Roots，然后将所有GC Roots可达的对象标记为存活的对象；
   - 清除阶段：遍历堆中所有的对象，**将没有标记的对象全部清除掉**；
   - 缺点：
     - 标记和清除阶段的效率不高，而且清除后回产生大量的不连续空间， 这样当程序需要分配大内存对象时，可能无法找到足够的连续空间；
2. **标记—整理算法（Mark-Compact）**：老生代
- 把标记的存活对象往内存的一端移动，然后直接回收边界以外的内存
   - 不会产生内存碎片，利于内存的管理
3. **复制算法（Copying）：**新生代
- 把内存分成大小相同的两块，每次使用其中一块，当垃圾回收的时候，把存活的对象复制到另一块上， 然后把这块内存整个清理掉，下一次重复相同的步骤
   - 实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率不高

 4. **分代收集（Generational Collection)** 
- 根据**对象的存活时间**把内存分为新生代和老年代，根据各个代对象的存活特点，每个代采用不同的垃圾回收算法;
     - 存活时间短的对象归为新生代，存活时间长的对象归为老年代，永久代：即方法区
     - **存活率低：少量对象存活，适合复制算法**
        - 在新生代中，每次GC时都发现有大批对象死去，只有少量存活（新生代中98%的对象都是“朝生夕死”），那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC;
     - **存活率高：大量对象存活，适合用标记-清除/标记-整理**
        - 在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC
        - 在老年代的对象中，有一小部分是因为在新生代回收时，老年代做担保，进来的对象，绝大部分对象是因为很多次GC都没有被回收掉而进入老年代;

###### MinorGC/young GC 采用：复制算法：

- 将 Java 堆内存的新生代，分为**一块比较大的Eden空间和两块较小的Survivor空间**，每次使用Eden 和其中一块Survivor（**比例为：8:1:1**） ，当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的 Survivor空间，HotSpot虚拟机默认Eden和Survivor的大小比例是8:1， 每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），实际上只有10%的空间会被浪费。
- 新生代中的对象 98%都是“朝生夕死”的，当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，**当 Survivor 空间不够用时，需要依赖于老年代进行分配担保，所以直接把大对象进入老年代**。
- 把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）；然后清空 Eden 和 ServicorFrom 中的对象，最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo成为下一次GC时的ServicorFrom 区。

###### MajorGC/Full GC 采用：标记—清除算法

- 首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。**MajorGC的耗时比较长，因为要扫描再回收;**
- MajorGC 会产生内存碎片，为了减少内存损耗，我们一般**需要进行合并或者标记出来方便下次直接分配**;
- 触发  Full GC 的条件：
  1. System.gc() 方法的调用
  2. 老年代空间不足，在新生代对象转入及创建大对象、大数组时才会出现不足的现象
  3. 永久代空间不足（方法区）
  4. CMS GC 时，出现 promotion failed 和 concurrent mode failure（并发标记）；