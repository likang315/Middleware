### 类的加载、类加载器

------

[TOC]

##### 01：概述

- **类的编译：**Java 编译器将 Java 文件编译成为 class 文件的过程；
- **Java 字节码：**Java虚拟机执行的一种虚拟指令格式；

##### 02：编译器类型

1. 前端编译器(Javac编译器)：把 Java 文件编译成 Class 文件；
2. 后端编译器（JIT编译器）：它在程序运行期间将字节码转变成机器码；
   - 当某一方法调用次数达到**即时编译定义的阈值时**，就会触发即时编译，这时即时编译器会将IR进行优化，并生成这个方法的机器码，后面再调用这个方法，就会直接调用机器码执行，这个就是编译执行的过程，它存在于堆外内存
   - 如果有大量的代码触发了即时编译，而且没有及时GC的话，**CodeCache就会被填满**。
3. 静态提前编译器（AOT编译器）：直接将 Java 文件部分内容编译成机器码；

##### 03：类加载的三种方式

1. 启动应用时由JVM初始化加载；
2. 通过Class.forName() 方式动态加载；
3. 通过 ClassLoder.loadClass() 方法动态加载；

##### 04：类加载器（ClassLoader）：

###### 用来加载类文件的类，JVM中有3个默认的类加载器：

1. **启动类加载器（Bootstrap）：**
   - 嵌在JVM内核中的加载器，用C++语言写的，负责**加载核心Java库**，负责加载<JAVA_HOME>/jre/lib 目录中的类库；
2. **扩展类加载器（Extensions）：**
   - 在<JAVA_HOME>/jre/lib/ext,或java.ext.dirs指明的目录中**加载Java的扩展库**，该类由sun.misc.Launcher$ExtClassLoader；
3. **System类加载器（Application类加载器）：**
   - 它负责从**classpath环境变量中加载某些应用相关的类**
   -  一般来说，Java 自定义的类都是由它来完成加载的，该类由sun.misc.Launcher$AppClassLoader实现；
4. **自定义加载器：**
   - 自定义类加载器，必须**继承ClassLoader，重写 findClass(String 类的绝对路径名)**，其核心逻辑是**获取指定类的字节数组，并调用 defineClass( )，得到对应的 class 对象**，其中 defineClass 方法不建议重写，自定义类加载器一般自定义的是获取类的字节流的方法；
   - 没有破坏双亲委派模型，依然交给父类加载器；

![](https://github.com/likang315/Middleware/blob/master/02%EF%BC%9AJVM/photos/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png?raw=true)

##### 05：类的加载机制 (装载)

- Class 对象：在加载类时，由 Java 虚拟机以及通过调用类加载器中的 defineClass() 自动构造的；

###### 双亲委派模型（PDM）

1. 当 AppClassLoader 加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委托给父类加载器ExtClassLoader去完成
2. 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类的加载请求委派给BootStrapClassLoader去完成 
3. 如果 BootStrapClassLoader 加载失败（例如在 JAVA_HOME​/jre/lib 里未查找到该 class），会使用ExtClassLoader来尝试加载
4. 若 ExtClassLoader也加载失败，则会使用AppClassLoader来加载，**如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException；**

###### PDM优点：

- Java类随着它的类加载机制具备了一种带有**优先级的层次**，通过这种关系可以避免类的重复加载，防止**API核心类被篡改**（自定义String类和JDK定义的String类），更好的保证了 Java 平台的安全性；


##### 06：破坏双亲委派模型

- 方法：继承ClassLoader重写loadClass()方法，即可破坏PDM；

###### 什么时候需要破坏PDM

- 某些情况下**父类加载器需要委托子类加载器去加载class文件**，受到加载范围的限制，父类加载器无法加载到需要的文件，**以Driver接口为例**；
- 由于Driver接口定义在JDK中的，而其实现由各个数据库的服务商来提供，DriverManager要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能加载JAVA_HOME的lib下文件，而其实现是由服务商提供的类，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派；
- 根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类；

##### 07：类加载过程：类被加载到内存的过程

- 由于 Java 的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件，当 Java 程序需要使用某个类时，JVM会确保这个类已经被**加载、连接（验证、准备和解析）和初始化**；


1. **加载：**

   - 指把类的.class 文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应的Class对象，加载完成后，此时的Class 对象还不完整，所以此时的类还是不可用的；

2. **连接：包括验证、准备，解析**

   1. **验证：**验证语法格式，文件格式；
   2. **准备：**为类静态变量分配内存并设置默认的初始值；
   3. **解析：**将符号引用替换为直接引用，因为编译时，java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替；
      - 符号引用：以一组符号来表示所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可；
      - 直接引用：直接指向目标的指针；

3. **类的初始化：**

   - 为类或接口的静态变量赋正确的初始值；
   - 执行静态块
   - ###### 何时执行类的初始化
   
     1. 创建类的实例
     2. 访问类的静态变量、类的静态方法（静态域）
     3. 反射(Class.forName("my.xyz.Test"))
     4. 当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化
     5. 虚拟机启动时，定义了main()方法的那个类先初始化

