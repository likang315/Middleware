### 类的加载 & 类加载器

------

[TOC]

##### 01：编译器类型

1. 前端编译器(Javac编译器)：把 Java 文件编译成 Class 文件；
2. 后端编译器（JIT编译器）：它在程序运行期间将字节码解释成机器码；
3. 静态提前编译器（AOT编译器）：直接将 Java 文件部分内容编译成机器码；

##### 02：类加载的三种方式

1. 命令行启动应用时，由 JVM 初始化加载；
2. 通过 Class.forName() 方式动态加载；
3. 通过 ClassLoder.loadClass() 方法动态加载

##### 03：类加载机制【五步】

- Java 虚拟机把**描述类的数据从Class文件加载到内存，并对数据进行验证、转换解析和初始化**，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制。
- Java 虚拟机中类加载的全过程，即加载、验证、准备、解析和初始化；
  - 验证、准备、解析统称连接（Linking）；
  - 并非依次执行，有交集执行；



1. **加载（Load）**

   1. 通过一个**类的全限定名来获取定义此类的二进制字节流**。 
   2. 将这个字节流所代表的**静态存储结构转化为方法区的运行时数据结构**。 
   3. 在内存中**生成一个代表这个类的 java.lang.Class 对象**，作为方法区这个类的各种数据的访问入 口。
      - 此时的 Class 对象还不完整，所以此时的类还是不可用的；
      - **数组类本身**不通过类加载器创建，它是由 **Java 虚拟机直接在内存中动态构造出来的**，但它的元素类型还是要靠类加载器来完成加载。

2. **验证（Verification）：**是确保 Class 文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。（从文件中加载类）

   - **文件格式验证**：要验证字节流**是否符合 Class 文件格式的规范**，并且能被当前版本的虚拟机处理，只有通过了这个阶段的验证之后，这段**字节流才被允许进入Java虚拟机内存的方法区中进行存储**。
   - **元数据验证**：对类的元数据信息进行**语义校验**，保证不存在与《Java语言规范》定义相悖的元数据信息。
   - **字节码验证**：对类的**方法体（Class文件中的Code属性）进行校验分析**，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。
     - JDK 6 之后的 Javac 编译器和 Java 虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行。
       - 具体做法是给方法体**Code属性的属性表中新增加了一项名为“StackMapTable”的新属性**，这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，Java 虚拟机就**不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可**。
   - **符号引用验证**：对类自身以外（**常量池中的各种符号引用**）的各类信息进行匹配性校验。
     - 发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生）。
   - 关闭验证阶段：**-Xverify：none**，关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

3. **准备（Preparation）：**正式为类中定义的变量（即静态变量，被static修饰的变量）**分配内存并设置类变量初始值**；

   - 仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中；

   - 变量 value 在准备阶段过后的**初始值为0而不是123**，因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器`<clinit>()`方法之中，所以把value赋值为123的动作要到**类的初始化阶段**才会被执行。

   - 编译时 Javac 将会为value生成 ConstantValue 属性，在准备阶段虚拟机就会**根据 ConstantValue 的设置将value赋值为123**。

     ```java
     public static int value = 123; 
     // ConstantValue
     public static final int value = 123;
     ```

4. **解析（Resolution）：**将**常量池内的符号引用替换为直接引用**，因为编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替；

   - 符号引用：以一组符号来表示所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标；
   - 直接引用：直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄；

5. **类的初始化（Initalization）**

   - 准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员**通过程序编码制定的主观计划去初始化类变量和其他资源（执行静态块）**；
     - **`<clinit>()方法`**：由编译器自动收集**类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生**的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块**可以赋值，但是不能访问**。
     - 与类的构造函数（即在虚拟机视角中的实例构造器`<init>()`方法）不同，它**不需要显式地调用父类构造器**，Java虚拟机会保证在子类的`<clinit>()`方法执行前，父类的`<clinit>()`方法已经执行完毕。因此**在Java虚拟机中第一个被执行的`<clinit>()`方法的类型肯定是java.lang.Object。** 
     - 对于类或接口来说并**不是必需的**，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方。
       - Java 虚拟机必须保证**一个类的`<clinit>()`方法在多线程环境中被正确地加锁同步**，如果多个线程同时去初始化一个类，那么**只会有其中一个线程去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待**，直到活动线程执行完毕`<clinit>()`方法。如果执行`<clinit>()`方法的那条线程退出`<clinit>()`方法后，其他线程唤醒后则不会再次进入`<clinit>()`方，**即同一个类加载器下，一个类型只会被初始化一次。**
   - 有且只有**六种情况**必须立即对类进行初始化
     1. 遇到`new、getstatic、putstatic、invokestatic`这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。
        - 创建类的实例，访问类的静态变量、类的静态方法（静态域）。
     2. 反射：使用`java.lang.reflect`包的方法**对类型进行反射调用的时候**，如果类型没有进行过初始化，则需要先触发其初始化。
     3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要**先触发其父类的初始化**。
     4. 当虚拟机启动时，用户需要**指定一个要执行的主类**（包含main()方法的那个类），虚拟机会先初始化这个主类。 
     5. JDK 7 动态语言支持时，如果一个` java.lang.invoke.MethodHandle` 实例最后的解析结果为`REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial`四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
     6. 当一个接口中定义了JDK 8 新加入的**默认方法（被default关键字修饰的接口方法）时**，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。 

##### 04：类与类加载器

- 把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便**让应用程序自己决定如何去获取所需的类**。实现这个动作的代码被称为“类加载器”（Class Loader）；
- 确定类的唯一性
  - 对于任意一个类，都必须由**加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性**，每一个类加载器，都拥有一个独立的类名称空间。（比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等）。

##### 05：类加载器（Class Loader）【四种】

1. **启动类加载器（Bootstrap）**
   - 使用C++语言实现，是虚拟机自身的一部分，负责**加载核心 Java 库**，负责加载`<JAVA_HOME>/lib` 目录中的类库；
2. **扩展类加载器（Extensions）**
   - 在`<JAVA_HOME>/lib/ext`，或 java.ext.dirs 指明的目录中**加载 Java 的扩展库**；
   - 在类sun.misc.Launcher$ExtClassLoader 中以Java代码的形式实现的，由于是 Java 代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件
3. **System 类加载器（Application 类加载器）**
   - 负责**加载用户类路径（ClassPath）上所有的类库**，开发者同样可以直接在代码中使用这个类加载；
   - 一般来说，Java 自定义的类都是由它来加载的，该类由 sun.misc.Launcher$AppClassLoader 实现；
4. **自定义加载器**
   - 自定义类加载器，必须**继承ClassLoader，重写 findClass(String 类的绝对路径名)**，其核心逻辑是**获取指定类的字节数组，并调用 defineClass( )，得到对应的 class 对象**，其中 defineClass 方法不建议重写，自定义类加载器一般自定义的是获取类的字节流的方法；
   - 没有破坏双亲委派模型，依然交给父类加载器；

![](https://github.com/likang315/Middleware/blob/master/02%EF%BC%9AJVM/photos/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png?raw=true)

##### 06：双亲委派模型（PDM，Parent Delegation Model）

- 类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常**使用组合（Composition）关系**来复用父加载器的代码。 

1. 当 AppClassLoader 加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委托给父类加载器ExtClassLoader 去完成；
2. 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类的加载请求委派给BootStrapClassLoader 去完成；
3. 如果 BootStrapClassLoader 加载失败（例如在 JAVA_HOME​/lib 里未查找到该 class），会使用 ExtClassLoader 来尝试加载；
4. 若 ExtClassLoader也加载失败，则会使用AppClassLoader来加载，**如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException；**

###### PDM 优点

- Java 类随着它的类加载机制具备了一种带有**优先级的层次**，通过这种关系可以**避免类的重复加载**，防止**API核心类被篡改**（自定义 String 类和 JDK定义的 String 类），更好的保证了 Java 平台的安全性；


##### 07：破坏双亲委派模型

- 方法：继承 ClassLoader 重写 loadClass() 方法，即可破坏PDM；

###### 什么时候需要破坏 PDM

- JNDI 服务：启动类加载器是绝不可能认识、加载这些代码的，此时需要**父类加载器需要委托子类加载器去加载 class 文件**，**以 Driver 接口为例**；
  - **线程上下文类加载器（Thread Context ClassLoader）**：这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是**应用程序类加载器**；
  - JNDI服务使用这个线程上下文类加载器**去加载所需的SPI服务代码**，这是一种父类加载器去请求子类加载器完成类加载的行为；
- 由于 Driver 接口定义在JDK中的，而其实现由各个数据库的服务商来提供，DriverManager 要加载各个实现了 Driver 接口的实现类，然后进行管理，但是 DriverManager 由启动类加载器加载，只能加载JAVA_HOME的lib下文件，而其实现是由服务商提供的类，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载 Driver 实现，从而破坏了双亲委派；

##### 08：Java 模块化系统

- 为了能够实现模块化的关键目标—**可配置的封装隔离机制**，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。
