### Zookeeper

------

##### 01：分布式协调技术

- 分布式协调远比在同一台机器上对多个进程的调度要难得多，而且如果为每一个分布式应用都开发一个独立的协调程序。一方面，协调程序的反复编写浪费，且难以形成通用、伸缩性好的协调器。另一方面，协调程序开销比较大，会影响系统原有的性能。所以，急需一种高可靠、高可用的通用协调机制来用以协调分布式应用。
- 防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个**分布式锁**

##### 02：Zookeeper 

​	ZooKeeper是一种为分布式应用所设计的高可用、高性能且一致的开源协调服务，它提供了一项基本服务：**分布式锁服务**。由于ZooKeeper的开源特性，后来我们的开发者在分布式锁的基础上，摸索了出了其他的使用方法：**配置维护、组服务、分布式消息队列**、**分布式通知/协调**等。

- ZooKeeper所提供的服务主要是通过：数据结构【Znode】+ 原语 + watcher机制，三个部分来实现的；
- 一种新的**数据结构—Znode**；
- 定义**原语**：一些关于该数据结构的一些操作；
- Watcher 机制：由于我们的ZooKeeper是工作在一个分布式的环境下，我们的服务是通过消息以网络的形式发送给我们的分布式应用程序，所以还需要一个**通知机制**；

##### 03：Zookeeper 的数据结构Znode【HFS】

![Zonde](/Users/likang/Code/Git/Middleware/Zookeeper/photo/Zonde.png)

- ZooKeeper树中的每个节点被称为：Znode
- **引用方式**
  - Zonde通过**路径引用**，路径必须是绝对的，因此他们必须由斜杠字符来**开头**。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串"/zookeeper"用以保存管理信息，比如关键配额信息。
- **Znode结构**
  - ZooKeeper命名空间中的Znode，兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。图中的每个节点称为一个Znode。 每个Znode由3部分组成:
    - stat：此为状态信息, 描述该Znode的版本, 权限等信息
    - data：与该Znode关联的数据
    - children：该Znode下的子节点
  - ZooKeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来**管理调度数据**，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。ZooKeeper的服务器和客户端都被设计为**严格检查并限制每个Znode的数据大小至多1M**，但常规使用中应该远小于此值。
- **数据访问**
  - ZooKeeper中的每个节点存储的数据要被**原子性的操作**。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。
- **节点类型**
  - 节点有两种，分别为**临时节点**和**永久节点**。节点的类型在创建时即被确定，并且不能改变。
  - **临时节点：**该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，**ZooKeeper的临时节点不允许拥有子节点**。
  - **永久节点：**该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。
- **顺序节点**：
  - 当创建Znode的时候，用户可以请求在ZooKeeper的路径结尾添加一个**递增的计数**。这个计数**对于此节点的父节点来说**是唯一的，它的格式为"%10d"(10位数字，没有数值的数位用0补充，例如"0000000001")。当计数值大于232-1时，计数器将溢出。
- **观察**
  - 客户端可以在节点上设置watch，我们称之为**监视器**。当节点状态发生改变时(Znode的增、删、改)将会**触发watch所对应的操作**。当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次，这样可以减少网络流量。

##### 04：Zookeeper 中的时间【多种记录时间的格式】

- Zxid
  - 使ZooKeeper**节点状态改变的每一个操作**都**将使节点接收到一个Zxid格式的时间戳**，并且这个**时间戳全局有序**，也就是说，每个对节点的改变都将产生一个唯一的Zxid。如果Zxid1的值小于Zxid2的值，那么Zxid1所对应的事件发生在Zxid2所对应的事件之前。
  - 实际上，ZooKeeper的每个节点维护者三个Zxid值，为别为：cZxid、mZxid、pZxid。
  - **cZxid**： 是节点的创建时间所对应的Zxid格式时间戳。
  - **mZxid**：是节点的修改时间所对应的Zxid格式时间戳。
  - 实现中Zxid是**一个64位的数字**，它**高32位是epoch用来标识leader关系是否改变**，每次一个leader被选出来，它都会有一个 新的epoch。低32位是个**递增计数**。
- 版本号
  - 对节点的每一个操作都将致使这个节点的版本号增加。每个节点维护着三个版本号，他们分别为：
  - version：节点数据版本号
  - cversion：子节点版本号
  - aversion：节点所拥有的ACL版本号

##### 05：Zookeeper 的节点属性

|      属性      | 描述                                                         |
| :------------: | :----------------------------------------------------------- |
|     cZxid      | 创建节点时的事务ID                                           |
|     mZxid      | 最后修改节点时的事务ID                                       |
|     pZxid      | 表示该节点的子节点列表最后一次修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响该ID**（注意，只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响pzxid）** |
|     mtime      | 最后修改节点时的时间                                         |
|     ctime      | 创建节点时的时间                                             |
|    cversion    | 子节点版本号，子节点每次修改版本号加1                        |
|  dataversion   | 数据版本号，数据每次修改该版本号加1                          |
|   aclversion   | 权限版本号，权限每次修改该版本号加1                          |
| ephemeralOwner | 创建该临时节点的会话的sessionID。**（如果该节点是持久节点，那么这个属性值为0）** |
|   dataLength   | 该节点的数据长度                                             |
|  numChildren   | 该节点拥有子节点的数量**（只统计直接子节点的数量）**         |

##### 06：Zookeeper 服务中的操作

| 操作            | 描述                                |
| --------------- | ----------------------------------- |
| create          | 创建Znode（父Zode必须存在）         |
| delete          | 删除Znode（Znode没有子节点）        |
| exists          | 测试Znode是否存在，并获取他的元数据 |
| getACL/setACL   | 为Znode获取设置ACL                  |
| getChildren     | 获取Znode所有子节点的列表           |
| getData/setData | 获取设置Znode的相关数据             |
| sync            | 使客户端的Znode视图与Zookeeper同步  |

- 更新ZooKeeper操作是**有限制的**；
  - delete或setData必须**明确要更新的Znode的版本号**，我们可以调用exists找到。如果版本号不匹配，更新将会失败。
- 更新ZooKeeper操作是**非阻塞式的**；
  - 因此客户端如果失去了一个更新(由于另一个进程在同时更新这个Znode)，他可以在不阻塞其他进程执行的情况下，选择重新尝试或进行其他操作。 

##### 07：Watch触发器

###### watch概述

- ZooKeeper可以为**所有的读操作**设置watch，这些读操作包括：exists()、getChildren()及getData()。
- watch事件是**一次性的触发器**，当watch的对象状态发生改变时，将会触发此对象上watch所对应的事件。该事件将被**异步**地发送给客户端，并且ZooKeeper为watch机制提供了有序的**一致性保证**。理论上，客户端接收watch事件的时间要快于其看到watch对象状态变化的时间。

###### watch类型

- ZooKeeper所管理的watch可以分为两类：
  - 数据watch(data  watches)：**getData**和**exists**负责设置数据watch；
  - 孩子watch(child watches)：**getChildren**负责设置孩子watch；

###### watch的注册和触发

![watch](/Users/likang/Code/Git/Middleware/Zookeeper/photo/watch.png)

###### watch 处理的两类事件【重载的process(Event event)】

- 连接状态事件(type=None, path=null)
  - 这类事件不需要注册，也不需要我们连续触发，我们只要处理就行了。
- 节点事件
  - 节点的建立，删除，数据的修改。它是one time trigger，我们需要不停的注册触发，还可能发生事件丢失的情况。

##### 08：Zookeeper 应用举例【分布式锁】

###### 场景介绍：

- 在分布式锁服务中，有一种最典型应用场景，就是通过对集群进行**Master选举**，来解决分布式系统中的**单点故障**。
- 分布式系统中的单点故障：通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就都瘫痪了，那么我们把这种故障叫作单点故障。

###### 传统解决方案

1. 传统方式是**采用一个备用节点**，这个备用节点定期给当前主节点发送ping包，主节点收到ping包以后向备用节点发送回复Ack，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务；
2. 当主节点挂了，这时候备用节点收不到回复了，然后他就认为主节点挂了接替他成为主节点；
3. 网络问题：
   - 主节点的并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，这样我们的分布式系统当中就有了两个主节点也就是—**双Master**，出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就乱套啦；

###### Zookeeper

1. 引入Zookeeper以后我们启动了两个主节点，"主节点-A"和"主节点-B"他们启动以后，都向ZooKeeper去注册一个节点。我们假设"主节点-A"锁注册地节点是"master-00001"，"主节点-B"注册的节点是"master-00002"，注册完以后进行选举，**编号最小的节点将在选举中获胜获得锁成为主节点**，也就是我们的"主节点-A"将会获得锁成为主节点，然后"主节点-B"将被阻塞成为一个备用节点。那么，通过这种方式就完成了对两个Master进程的调度。
2. 如果"主节点-A"挂了，这时候他所注册的节点将被自动删除，**ZooKeeper会自动感知【如何感知】节点的变化**，然后再次发出选举，这时候"主节点-B"将在选举中获胜，替代"主节点-A"成为主节点。
3. Master 恢复
   - 如果主节点恢复了，他会再次向ZooKeeper注册一个节点，这时候他注册的节点将会是"master-00003"，ZooKeeper会感知节点的变化再次发动选举，这时候"主节点-B"在选举中会再次获胜继续担任"主节点"，"主节点-A"会担任备用节点。。

![master选举](/Users/likang/Code/Git/Middleware/Zookeeper/photo/master-选举.png)







