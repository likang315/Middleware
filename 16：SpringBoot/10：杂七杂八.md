



##### 06：模板引擎

1. ###### FreeMarker 的使用

   1. 加入依赖

      ```xml
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-freemarker</artifactId>
      </dependency>
      ```

   2. 编写控制器

   3. 穿件后缀为 ***.ftl** 模板文件

      - 在src/main/resources/创建一个templates文件夹，后缀为*.ftl，先创建HTML文件，修改后缀为ftl；
      - 此文件加是受保护的，必须通过controller层跳转，不能直接访问；
      - 具体写法类似于jsp标签

2. ###### Jsp的使用

   1. 添加依赖

      ```xml
      <dependency>
        <groupId>org.apache.tomcat.embed</groupId>
        <artifactId>tomcat-embed-jasper</artifactId>
      </dependency>
      ```

   2. 创建配置文件

      - 在resources文件夹下创建application.properties文件，并配置
        - spring.mvc.view.prefix=/WEB-INF/view/
        - spring.mvc.view.suffix=.jsp
        - server.port=8888   配置tomcat端口号
        - Server.context-path=/xupt  配置项目名称，用于访问页面时作为根路径

3. ###### thymeleaf

   1. 添加依赖

      ```xml
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
      </dependency>
      ```

   2. 在src/main/resources/创建一个templates文件夹，后缀为*.yml，先创建HTML文件，修改后缀为yml；

      1. 必须在html文件中引入xmlns:th="http://www.thymeleaf.org"

   3. 在application.propesties中配置跳转的前后缀

      - spring.thymeleaf.prefix=classpath:/templates/ 
      - spring.thymeleaf.suffix=.html  

   4. 或者在模板引擎文件中配置

      ```yml
      spring:
         thymeleaf:
         		prefix: "classpath:/templates/"
          	suffix: ".html"
      ```

##### 07：yaml 配置文件

- 以数据为中心，使用空白、缩进、分行组织数据，用于指定分层配置数据；
- 语法：
  1. 大小写敏感
  2. 使用缩进表示层级关系
  3. 禁止使用tab缩进，只能使用空格键 , 建议使用两个空格
  4. 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可
  5. "#"：表示注释，从这个字符一直到行尾，都会被解析器忽略
  6. 字符串可以不用引号，也可以使用单引号或者双引号	
  7. 书写(Key: Value)
     - key：需要顶格写，不能有空格，冒号后面需要有一个空格然后再跟值，相同的缩进属于同一个map ；

##### 08：SpringBoot 默认的配置文件【重要】

- application.properties
- application.yml
- Spring Boot接受prop / xml / yml 三种配置文件形式，这三种配置文件内部有所不同，配置形式不同，除此之外，其实文件的功能和用处没什么特别之处。
  1. prop:配置文件结构
  2. yml：树状结构
  3. xml：标签结构

1. **spring.profiles.active**
   - Spring Profile参数，在启动时配置这个参数可以**激活当前环境的Profile**，如 --spring.profiles.active=dev 则可以激活的配置文件是 application-dev.propteies，以此来达到不同环境使用不同配置文件的目的，如application-dev.propteies ，application-prod.propteies；
2. **spring.profiles.include**
   - 这个配置同样可以配置在prop和yml中，其作用是**无条件的增量添加其他配置文件到系统中**。如我们添加 spring.profiles.include=cache,db 到配置文件中，则效果是，会自动的添加，application-cache.propteies和application-db.propteies 到环境中。
3. **spring.profiles.default**
   - spring.profiles.default 和 spring.profiles.active 一般是需要搭配使用的，在spring.profiles.active激活之后可以知道我们有多个环境了，如dev，prod，那么在没有指定的时候，默认使用的环境，就是由spring.profiles.default指定的。

##### 09：使用 Maven 指定 Profile【推荐】

1. < profile>：定义了各个环境的变量ID；
   1. maven启动时会配置自动选择使用哪个< profile>
   2. 打包命令：mvn package -Pdev来指定激活id为 dev 的profile节点, 这样, 开发环境配置文件就会被打包.
      - 开发：mvn package -Pdev (因为配置了默认激活dev部分, 所以也可以使用mvn package, 这与 mvn package -Pdev 效果相同)
      - 测试：mvn package -Ptest
      - 生产：mvn package -Pprod
2. < filters>：定义了**变量配置文件的地址**；
   1. < filter> 标签中指定的文件中$ {key}，会获取相应的值替代；
3. < resources>
   1. < directory>：表示编译所需的资源目录；
   2. < filtering>：表示是否开启替换资源文件中的属性, 设置为 true 才能实现动态替换；
   3. < excludes>：表示排除掉资源目录下的某文件或文件夹
   4. < includes>：表示包含资源目录下的文件；
   5. < targetPath>：表示该资源标签下的资源打包编译后的保存路径,"." 表示当前目录；

##### 10：导入其他配置文件【重要】

1. **Spring可以通过注解@Value(“${属性名key}”)**

   - 通过全限定名加载对应的配置属性，然后将属性值赋值给注解对应的实体属性；
   - 需要配合@PropertySource使用；

   ```java
   // application-dev.properties 中
   logback.root.level=DEBUG
   
   @Value(${logback.root.level})
   private String level;
   ```

2. **@ConfigurationProperties**(prefix = “xxx”)：

   - 该注解有一个prefix属性，通过指定的前缀，绑定配置文件中的配置，该注解可以放在类上（对应的属性名需要与定义的key相同），也可以放在方法上；
   - 当注解作用于方法上时，如果想要有效的绑定配置，那么该方法需要有@Bean注解且所属Class需要有@Configuration注解，读写分离场景；
   - 

   ```java
   @Configuration
   public class DruidDataSourceConfig {
       /**
        * DataSource 配置
        * @return
        */
       @ConfigurationProperties(prefix = "jdbc.datasource.read")
       @Bean(name = "readDataSource")
       public DataSource readDruidDataSource() {
           return new DruidDataSource();
       }
   
       /**
        * DataSource 配置
        * @return
        */
       @ConfigurationProperties(prefix = "jdbc.datasource.write")
       @Bean(name = "writeDataSource")
       @Primary
       public DataSource writeDruidDataSource() {
           return new DruidDataSource();
       }
   }
   
   @Component
   @ConfigurationProperties(prefix = "jdbc")
   public Class JdbcProperties {
   	private String url;
   	private String driverClassname;
   	private String username;
   }
   
   // dataSource.properties
   {
     jdbc.driverClassName=com.mysql.jdbc.Driver
     jdbc.url=jdbc:mysql://127.0.0.1:3306/peter?useUnicode=true&characterEncoding=utf-8&useSSL=false
     jdbc.username=root
     jdbc.password=123456
       
     // map 和 list
     data.nameMap.key1="value1"
     data.nameMap.key2="value1"
     data.list[0]="value1"
     data.list[1]="value2"
   }
   ```

3. **@PropertySource**：来引入定义属性文件的位置

   - @PropertySource(value= {"classpath:**/*.properties"})
   - 使用在需要获取 *.propesties  中值的类上，一般与@Value，@ConfigurationProperties一起使用；

   ```java
   // 放在springBoot 启动类下，加载properties文件
   @Bean
   public static PropertySourcesPlaceholderConfigurer
       propertySourcesPlaceholderConfigurer() throws IOException {
       val result = new PropertySourcesPlaceholderConfigurer();
       result.setLocations(new PathMatchingResourcePatternResolver()
                           .getResources("classpath*:**/*.properties"));
       result.setIgnoreUnresolvablePlaceholders(true);
       return result;
   }
   ```

4. **多环境配置文件**：application-{profile}.properties 格式，其中{profile}对应你的环境标识，比如：

   - application-dev.properties：开发环境
   - application-beta.properties：测试环境
   - application-prod.properties：生产环境
   - 在application.properties文件中通过spring.profiles.active=dev属性来设置，其值对应{profile}值，配置文件会被加载



