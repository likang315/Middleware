### Mysql 的体系结构

![](G:\Java\Mysql，InnoDB\InnoDB\mysql 体系结构.png)

- 数据库驱动
- ​管理服务和工具组件
- SQL 接口组件
- 查询分析器
- 优化器
- 缓冲组件
- 插件式存储引擎
- 物理文件

###### 存储引擎是基于表的，不是基于数据库的



## 数据库读

### 1：查询语句的执行过程

１：客户端通过**TCP连接**发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配

２：通过**命令分发器查询**是什么语句，若是select语句，验证用户查询权限，查询缓存

建立连接后客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条select语句，如果是，在开启查询缓存的情况下，先在查询缓存中查找该SQL是否完全匹配，如果完全匹配，验证当前用户是否具备查询权限，如果权限验证通过，直接返回结果集给客户端，该查询也就完成了。如果不匹配继续向下执行								（其实说白了大概就是拿着你的SQL和原始缓存的SQL比对）

3：如果在查询缓存中未匹配成功，则将语句交给**分析器作语法分析**，MySQL需要知道到底要查哪些东西，如果语法不对，就会返回语法错误中断查询

4：将语句传递给**预处理器**，检查数据表和数据列是否存在，解析别名看是否存在歧义等

5：语句解析完成后，将语句传递给**优化器进行优化**（通过索引选择最快的查找方式）**，并生成执行计划**

6：**查询执行引擎** ：开表，交给执行器去具体执行该语句，在执行之前，会先检查该用户是否具有查询权限，如果有，继续执行该语句。执行器开始执行后，会逐渐将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端

###### 关闭表-->关闭线程-->关闭连接(四挥)



### 2：SQL解析的开销

​	SELECT	id,name,price FROM products WHERE id IN	(1,2,3,4,......	30000);              1-2(S) 
​	SELECT	id,name,price FROM products WHERE id = 1;				     2-3(S) 
​	SELECT	id,name,price FROM products WHERE id = 30000;				     2-3(S)
​	SELECT	id,name,price FROM products WHERE id =1	or id=2	…or id	= 30000;	     8-10(S)

### 3：数据库查询开销

​	如果你的查询条件索引不是主键：辅助索引(存储索引字段到主键的映射关系)-->回表-->聚集索引

### 4：数据库的大字段

​	content varchar(2046) NOT NULL 

查询开销大，会使 mysql 数据库的缓存失效，建议分表操作，把大字段单独存储一个表
查询影响大，严重时会触发热页换出

### 5：MySQL自带的 cache

​	**大小：256KB ,最大存储16页(16 X 16)**
​	MySQL是以页面作为最小缓存单位，读每次返回一页的数据

  只要符合条件的数据都应该上缓存
	1：**修改不频繁的数据**
	2：查询频率较高，带有明显**热点请求的数据**
	3：非实时的数据，**一致性要求不严苛的数据**
	

### 6：缓存造成的问题

​	1：缓存命中：命中率低
​	2：缓存穿透：cache中没有到磁盘中寻找
​	3：缓存失效（雪崩）：LAR算法，清除长时间未使用的页
​	4：缓存和DB的不一致性：cache和磁盘中的数据不一致

### 7：使用别的cache

​	MySQL cache VS redis 性能不同：Redis的缓存空间大
​	MySQL cache VS redis 命中对比：命中率，使用LAU算法，热点页置换



## 数据库写

１：客户端通过**TCP连接**发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配

 2：建立连接后客户端发送一条语句，mysql收到该语句后，通过**命令分发器判断其是否是一条更新语句**，如果是，则直接发送给分析器做语法分析。

 3：**分析器阶段**，MySQL需要知道到底要查哪些东西，如果语法不对，就会返回语法错误中断查询

 4：将语句传递给**预处理器**，检查数据表和数据列是否存在，解析别名看是否存在歧义等

 5：语句解析完成后，将语句传递给**优化器进行优化**（通过索引选择最快的查找方式），**并生成执行计划**

 6：执行器根据生成的执行计划去**open table**，此时会先去查看该表上**是否有元数据（MDL）排他锁**，如果有元数据排他锁，则事物被阻塞，进入等待状态，等元数据锁被释放，继续执行。如果无元数据锁或者是有元数据共享锁，则该事务在表上加元数据共享锁

 7：进入引擎层（默认innodb），去 **innodb_buffer_pool** 里面的 d**ata dictionary 得到表得相关信息**

 8：根据表信息去innodb_buffer_pool里面的**lock info查看是否有相关的锁信息**，如果有则等待（因为要加排它锁），如果没有则加排它锁，更新lock info

 9：读取相关数据页到innodb_buffer_pool中（如果数据页本身就在缓存中，则不用从硬盘读取）

10：将页中的**原始数据（快照）保存到undo log buffer**中

11：在innodb_buffer_pool中将相关**页面更新，该页变成脏页**（脏页会以相关参数定义的规则进行刷盘操作写入所属表空间中）

12：**页面修改完成后，会把修改后的物理页面保存到redo log buffer中**，（redo log buffer会以相关参数定义的规则进行刷盘操作写入到redo tablespace中）

13.如果**开启bin log，则更新数据的逻辑语句也会记录在bin log_cache中**

15：便是**事务的commit**或者rollback操作

16：执行 commit 操作后，由于要**保证redo log与bin log的一致性，redo log采用2阶段提交方式**

17：将**undo log buffer及redo log buffer刷盘**（innodb_flush_log_at_trx_commit=1），并将该事务的**redo log标记为prepare 状态**

18：**将 bin log_cache 数据刷盘**（sync_binlog=1）

19：**待bin log落盘完成，再将redo log中该事务信息标记为commit**，释放相关锁资源，此时一个更新事务的操作已经完成，返回给客户端成功更新提示

20：标记**undo log中该事务修改页的原始快照信息为delete**，当无其他事务引用该原始数据时(MVCC)，再将其删除

21：如果此时**触发了脏页刷盘**操作，会先将脏页写入到double write buffer中，后再写到其所在表空间的相应位置



### 9：数据库写负载的连锁反应

​	1：大量数据写入时，DB禁止一切写操作,强制刷盘
​	2：热点数据的频繁写入，严重的 mutex (互斥锁)争用，数据库雪崩效应

   数据库选择：关系型数据库不适合频繁的更新的场景，数据持久化的压力、数据库锁(mutex)竞争压力

### 10：死锁和锁超时

​	InnoDB锁超时默认需要等待 5s 超时,死锁马上就被发现，然后被  DB 自动回滚
​	

### 11：单机服务器的局限

​	常见的拆分方案

###### 	• 读写分离，只读表和会被写的表分离

###### 	• 分布式

​		垂直拆分
​			把新功能逻辑放到独立的新库里去
​		水平拆分
​			数据库存储出现瓶颈，就分表存储

### 12：分布式数据库的困扰

​	1：业务处理
​		复杂SQL支持不了，多表查询范围
​		SQL返回结果的不准确性
​	2：分布式事务
​		分布式事务的实现
​		分布式事务的性能

### 13：分布式事务

​	采用：两阶段提交，存在组织者和参与者
​	第一阶段：组织者通知所有参与者约定时间
​	第二阶段：组织者通知所有参与者可以提交

### 14：数据库并发场景

######  1：【读多写少】：可以把锁去掉，最大化并发，但带来的数据完整性的破坏，无缓存，但会产生脏读

######  2：【写多读少】，【超高并发】：一条记录一个锁，把锁的粒度减小

######  3：可以通过签名的方式保证数据的完整性，实现无锁缓存



### 15：分库分表操作

##### 垂直划分：基于数据库中的 "列" 进行

把关联度较低的字段，或者大字段放入另一个表中

##### 水平划分：将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果

1：按照时间区间（早上，下午）或ID区间来切分

2：一般采用 hash 取模 mod 的切分方式







