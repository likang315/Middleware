### Lock

------

[TOC]

##### 01：数据库并发问题

1. **更新丢失：**双写，加行锁（独享锁），必须等待事物执行完成之后，另一个事物才可以进行；
   1. 回滚丢失：一个事务写的时候成功的时候，另一个事务写失败了，导致了回滚，读已提交解决
   2. 覆盖丢失：一个成功的事务，覆盖了另一个成功的事务的结果，可重复读解决
2. **脏读：**一个事物读到了另一个事物未提交的数据（脏数据）；
   - 读已提交解决；
3. **不可重复读：**在第一个事物中两次读数据之间，由于第二个事物的修改，导致**两次读到的数据不一致**；
   - 一般来说，不可重复读是可以接受的，因为读到的是已经提交的数据；
4. **幻读：**同一个事物，**前后两次读取行数不一致**；
   - 在可重复读隔离级别下，**普通查询是快照读**，是不会看到别的事务插入的数据的，幻读只在**当前读**下才会出现；
   - 幻读专指新插入的行，读到原本存在行的更新结果不算。因为**当前读**的作用就是能读到所有已经提交记录的最新值；

##### 02：锁

- 数据库系统区别于文件系统的⼀个关键特性，用于管理对共享且可变资源的并发访问；
- InnoDB 会在行记录上加锁，同时也会在内部其他地方使用，保证并发性和一致性；

###### 两种标准的行级锁

1. 共享锁：事务读数据时，读锁，可重复加锁；
2. 排他锁：事务更新或删除一行数据时 ，写锁，默认时排它锁；
   - 此外, **InnoDB 支持多粒度锁定**，允许事务在行级别和表级别同时存在，因此引出了意向锁(Intention Lock)
   - 意向锁意味着事务希望在更细粒度上进行加锁（行锁）；

######  悲观锁、乐观锁

- 悲观锁：更新操作，加的都是悲观锁；
- 乐观锁：MVCC，通过版本号，比较当前版本如果对应上了，就更新数据，否则就不会更新成功；

###### 锁的分类（粒度上）

1. **表锁：**操作对象是数据表，没有走索引，全表扫描，加的是表锁；
   - MySQL 大多数锁策略都支持，是系统**开销最高但并发性最低**的一个锁策略。
   - 事务对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。
2. **行级锁：**操作对象是数据表中的一行记录；
   - InnoDB 行锁：是通过**给索引上的索引项加锁来实现的**，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁（自动加），否则，InnoDB将使用表锁；
   - 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是**访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的**
   - 行级锁对系统开销较大，但是处理高并发较好；
3. **间隙锁（Next-Key 锁）**
   - 当我们**用范围条件而不是相等条件检索数据**，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的**索引项加锁**
   - 对于键值**在条件范围内但并不存在的记录，叫做“间隙（GAP)”**，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）
   - 使用间隙锁的目的：
     1. 为了**防止幻读**，以满足相关隔离级别的要求，使用范围条件检索并锁定记录时，InnoDB这种**加锁机制会阻塞符合条件范围内键值的并发插入**；
     2. 为了满足其恢复和复制的需要

###### 加锁方式【悲观锁】

- 自动加锁：**在InnoDB中，insert, update, delete 等语句执行时都会自动加解锁**，修改操作的锁会持有到事务结束，效率高很多；
- 手动加锁：**select .... from table where 索引条件 for update**，在SQL语句中手动加锁；

##### 03：快照读和当前读

###### 隔离级别不同，读取方式不同

- READ COMMITTED 下，一致性非锁定读总是读取被锁定行的**最新一份快照（快照读）**，版本号；
- REPEATABLE READ 下，一致性非锁定读总是读取事务**开始时的行版本数据（当前读）**，手动加锁；

###### 一致性非锁定读 (consistent nonblocking read) 【快照读】

- 指 InnoDB 通过**多行版本控制的方式**来读取当前执行时间数据中的数据，如果当前数据正在执行修改操作，这时读取操作不会被阻塞，而是去读取⼀个**快照数据，通过Undo log 实现**，快照数据就是当前行数据的历史版本，有多个版本；

###### 一致性锁定读【当前读】

- InnoDB 支持两种一致性的锁定读加锁语句，显示加锁；
  - SELECT .... FROM table WHERE 索引条件 **FOR UPDATE**；
    - 对读取的行加锁之后，其他事物不能对已锁定的行加锁，是一种排他锁，其他线程来都被阻塞；
  - SELECT .... FROM table WHERE 索引条件 **LOCK IN SHARE MODE**；
    - 对读取的行加锁之后，**其他事物可以对被锁定的行加相同的锁**，共享锁；

###### 多版本并发控制技术（MVCC）

- MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞，对象 P 维护有多个版本，**每个版本会有一个读时间戳（Read TimeStamp, RTS）和 写时间戳（Write TimeStamp, WTS）**，事务 T 读对象 P 的最新版本，该版本早于事务 T 的读时间戳 RTS(Ti)；
- MVCC 优缺点
  - 代替了行锁，实现了对读的非阻塞（非锁定读），读不加锁，读写不冲突，缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作；

##### 04：死锁检测 (dead lock)

1. **超时检测：**
   -  设置一个阈值，当任意一方等待时间超过预设的阈值时, 其中⼀个事务回滚 ；
   -  InnoDB 锁超时默认时间是 **5s** ；
2. **wait-for-graph 主动检测：**
   - 通过“等待获取的锁” 和 “等待获取该锁的事务”之间，构造出⼀张**有向图，如果图中存在回路**, 就代表存在死锁, 一旦发现回路，会**选择undo log量最小的进行回滚**，另⼀个事务就得以继续执行，被回滚的事务会返回"dead lock"。
