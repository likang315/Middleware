### MySQL：底层原理

------

[TOC]

##### 01：MySQL 体系结构【八大组件】

![](https://github.com/likang315/Middleware/blob/master/09%EF%BC%9ASQL%E3%80%81MySQL/photos/mysql%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png?raw=true)

1. 数据库驱动：用于连接数据库，JDBC；
2. **数据库连接池**：管理数据库实例（IP：port），Druid；
4. **SQL 接口组件**：接受用户的SQL语句，并且返回用户需要查询的结果；
5. **语法分析器（Parse）**：SQL命令传递到解析器的时候会被解析器验证和解析，是个脚本；
6. **查询优化器**：SQL语句在查询之前会使用查询优化器对查询进行优化；
7. **缓冲组件**：查询缓存；
7. 管理服务和工具组件：系统管理和控制工具；
8. **插件式存储引擎**：存储引擎是基于表的，不是基于数据库的；

##### 02：查询语句的执行过程（六步）

1. 客户端通过**TCP连接**发送连接建立请求到 **mysql 连接器**，连接器会对该请求进行**权限校验及连接资源分配**；
2. 通过**命令分发器查询**是什么SQL语句，若是select语句，**验证用户查询权限，查询缓存**；
   - 建立连接后客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条select语句，如果是，验证当前用户是否具备查询权限，如果权限验证通过，在开启查询缓存的情况下，先在查询缓存中查找该SQL是否完全匹配（就是拿着你的SQL和原始缓存的SQL比对），如果完全匹配，直接返回结果集给客户端，如果不匹配继续向下执行；
3. 将SQL语句交给**查询分析器（Parse）作语法分析**，如果语法不对，就会返回语法错误中断查询；
4. 将SQL语句传递给**预处理器**，检查数据表和数据列是否存在，解析别名看是否存在歧义等；
5. SQL语句解析完成后，将语句传递给**优化器进行优化**（通过索引选择最快的查找方式），**并生成执行计划**；
6. 根据生成的执行计划去 open table，执行 SQL 语句，执行后会逐渐将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端；

- TCP连接—>命令分发器—>查询分析器—>预处理器—>优化器—>查询存储引擎—>开表—>执行语句—>关闭表—>关闭连接;

##### 03：SQL解析的开销

- SELECT	id,name,price FROM products WHERE id IN (1,2,3,4,......	30000);              1-2(S) 
- SELECT	id,name,price FROM products WHERE id = 1;				     2-3(S) 
- SELECT	id,name,price FROM products WHERE id = 30000;				     2-3(S)
- SELECT	id,name,price FROM products WHERE id =1 or id=2 …or id = 30000;	    8-10(S)

##### 04：大字段

- content text(2046)  NOT NULL 
- 查询开销大，会使 mysql 数据库的缓存失效，建议分表操作，把大字段单独存储一个表；
- 查询影响大，严重时会**触发热页换出**；

##### 05：InnoDB 自带的 cache

- 大小：256KB，最大缓存16页(16 X 16)
- MySQL是以页面作为最小缓存单位，读每次返回的是一页数据；

######   缓存数据的条件

1. 修改不频繁的数据
2. 查询频率较高，带有明显**热点请求**的数据
3. 非实时的数据，**一致性要求不严格**的数据

##### 06：MySQL cache VS Redis

- MySQL cache VS redis 性能不同：Redis 的缓存空间大；
- MySQL cache VS redis 命中对比：MySQL命中率低，使用LRU算法，热点页置换；

##### 07：更新SQL语句执行过程

1. 客户端通过**TCP连接**发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配；
2. 通过**命令分发器**判断其是否是一条更新语句，若是，校验用户有没有更新权限，则直接发送给分析器；
3. **分析器**，做语法分析，如果语法不对，就会返回语法错误中断执行；
4. 将语句传递给**预处理器**，检查数据表和数据列是否存在，解析别名看是否存在歧义等；
5. 将语句传递给**优化器进行优化**（通过索引选择最快的查找方式），**并生成执行计划**；
   - 前五步读写一样
6. 进入存储引擎层（默认Innodb），去 **innodb_buffer_pool** 里面的 data dictionary 得到表得相关信息；
7. 根据表信息去 innodb_buffer_pool 里面的**lock info 查看是否有相关的锁信息**，如果有则等待（因为要加互斥锁），如果没有则加互斥锁，更新 lock info；
8. 读取相关**数据页**从 innodb_buffer_pool 中（如果数据页本身就在缓存中，则不用从硬盘读取）；
9. 将页中的**原始数据（快照）保存到 undo log buffer** 回滚日志中；
10. 在 innodb_buffer_pool 中将**相关页面更新，该页变成脏页**（脏页会定时的刷盘写入到所属表空间中）；
11. 页面修改完成后，会把修改后的物理页面**保存到 redo log buffer [innodb_log_buffer] 中**，redo log buffer 会以相关参数定义的规则进行刷盘操作写入到 **redo log tablespace** 中；
12. 如果开启bin log，则更新数据的逻辑语句也会记录在**bin log_cache**中；
13. 执行 commit 操作后，由于**要保证redo log与bin log的一致性，redo log采用两阶段提交方式**；
14. 将**redo log 刷盘**（innodb_flush_log_at_trx_commit=1），并将该事务的**redo log 标记为 prepare 状态**；
15. **将 bin log_cache 数据刷盘**（sync_binlog=1），待bin log落盘完成，再将**redo log中该事务信息标记为commit**，释放相关锁资源，此时一个更新事务的操作已经完成，返回给客户端成功更新提示；
16. 标记**undo log buffer 中该事务修改页的原始快照信息标记为delete**，当无其他事务引用该原始数据时(MVCC)，再将其删除；

##### 08：写负载时连锁反应

1. 大量数据写入时，**DB禁止写操作**，强制刷盘；
2. 热点数据的频繁写入，严重的 mutex (互斥锁) 争用，**数据库雪崩效应**；
3. 数据库选择：关系型数据库不适合频繁的更新的场景，数据持久化的压力、数据库锁(mutex)竞争压力；

##### 09：分库分表操作

1. **垂直划分：**基于数据库中的 "列" 进行
   - 把关联度较低的字段，或者大字段放入另一个表中；
2. **水平划分：**将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果，涉及到分布式事务；
   - 按照时间区间（早上，下午）或ID区间来切分；
   - 一般采用 hash 取余 mod 的切分方式；

##### 10：分布式数据库的困扰

1. 业务处理
   - 复杂SQL支持不了，全局查询，拆分成局部查询处理；
   - SQL返回结果的不准确性；
2. 分布式事务
   - 分布式事务的实现
   - 分布式事务的性能

##### 11：分布式事务

- 采用：两阶段提交，存在组织者和参与者
  - 第一阶段：组织者通知所有参与者约定时间
  - 第二阶段：组织者通知所有参与者可以提交

##### 12：数据库并发场景

1. 读多写少：可以把**锁去掉**，最大化并发，但数据完整性被破坏，**没有缓存，但会产生脏读**；
   - 可以**通过签名的方式保证数据的完整性**，实现无锁缓存，校验签名，以确保消息的完整性；
2. 写多读少：一条记录一个锁，把**锁的粒度降低**；

##### 13：MySQL事务

​	MySQL中只有使用了 Innodb 数据库引擎才支持事务，事务默认自动提交的；

- BEGIN、START TRANSACTION; 显式地开启一个事务
- COMMIT; 提交事务，并使已对数据库进行的所有修改成为永久性的；
- ROLLBACK; 回滚结束用户的事务，并撤销正在进行的所有未提交的修改
- SET TRANSACTION；用来设置事务的隔离级别
- SET AUTOCOMMIT=0；禁止自动提交 
- SET AUTOCOMMIT=1；开启自动提交