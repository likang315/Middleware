### Kafka-Broker

------

[TOC]

##### 01：集群成员关系

- Kafka 使用 Zookeeper 来维护集群成员的信息。每个broker 都有一个**唯一标识符(brokerID)**，这个标识符可以在配置文件里指定，也可以自动生成。在broker 启动的时候，它通过**创建临时节点把自己的ID 注册到Zookeeper**。Kafka 组件订阅 **Zookeeper 的/brokers/ids 路径**（broker 在Zookeeper 上的注册路径），当有broker 加入集群或退出集群时，这些组件就可以获得通知。
- 在 broker 宕机、出现网络分区或长时间垃圾回收停顿时，broker 会从Zookeeper 上断开连接，此时**broker 在启动时创建的临时节点会自动从Zookeeper 上移除**。监听broker 列表的Kafka 组件会被告知该broker 已移除。
- 在关闭broker 时，它对应的节点也会消失，不过**它的 ID 会继续存在于其他数据结构中**。例如，主题的副本列表（下面会介绍）里就可能包含这些ID。在完全关闭一个broker 之后，如果**使用相同的ID 启动另一个全新的broker**，它会立即加入集群，并**拥有与旧broker相同的分区和主题**。

##### 02：集群控制器

- 集群控制器其实就是一个broker，只不过它**除了具有一般broker 的功能之外，还负责分区首领的选举**。里第一个启动的broker 通过在Zookeeper 里**创建一个临时节点/controller 让自己成为控制器**。其他broker 在启动时也会尝试创建这个节点，不过它们会收到一个**“节点已存在”的异常**，然后“意识”到控制器节点已存在，也就是说集群里已经有一个控制器了。**其他 broker 在控制器节点上创建Zookeeper watch 对象（观察者模式）**，这样它们就可以**收到这个节点的变更通知**。

###### 集群控制器选举

- Kafka 通过Zookeeper 的临时节点来选举控制器，并在节点加入集群或退出集群时通知控制器。
- 如果**控制器被关闭或者与Zookeeper 断开连接**，Zookeeper 上的临时节点就会消失。集群里的**其他broker 通过 watch 对象得到控制器节点消失的通知**，它们会尝试让自己成为新的控制器。**第一个在Zookeeper 里成功创建控制器节点的broker 就会成为新的控制器，其他节点会收到“节点已存在”的异常，然后在新的控制器节点上再次创建watch 对象。**每个新选出的控制器**通过 Zookeeper 的条件递增操作获得一个全新的、数值更大的controller epoch**。其他 broker 在知道当前 controller epoch 后，如果收到由控制器发出的包含较旧epoch 的消息，就会**忽略旧的**；
- 控制器**使用epoch 来避免“脑裂”**。“脑裂”是指两个节点同时认为自己是当前的控制器。

###### 分区首领选举

- 当控制器发现一个broker 已经离开集群（通过观察相关的Zookeeper 路径），它就知道，那些**失去首领的分区需要一个新首领**（这些分区的首领刚好是在这个 broker 上）。控制器遍历失去首领的分区，并确定谁应该成为新首领（简单来说就是**分区副本列表里的下一个 同步的 副本**），然后向所有包含新首领或现有跟随者的broker 发送请求。该请求消息包含了**谁是新首领以及谁是分区跟随者的信息**。随后，新**首领开始处理来自生产者和消费者的请求，而跟随者开始从新首领那里复制消息**。

###### 群组协调器选举

- 第一个加入群组的消费者将成为”群主”，选举时选出第一个HashMap对应的成员，基本是随机选取的；

##### 03：同步（复制）

- 它可以在个别节点失效时，保证 Kafka 的可用性和持久性。
- Kafka 使用主题来组织数据，**每个主题被分为若干个分区，每个分区有多个副本**。那些副本被保存在broker 上，**每个broker 可以保存成百上千个属于不同主题和分区的副本**；

###### 首领副本（Leader）

- 每个分区都有一个首领副本。为了保证一致性，**所有生产者请求和消费者请求都会经过这个副本**。

###### 跟随者副本（Follower）

- 首领以外的副本都是跟随者副本。**跟随者副本不处理来自客户端的请求，它们唯一的任务就是从首领那里同步消息，保持与首领一致的状态**。如果首领发生崩溃，其中的一个跟随者会被提升为新首领。
- 首领的另一个任务是弄清楚**哪个跟随者的状态与自己是一致的**。跟随者为了保持与首领的状态一致，在有新消息到达时尝试从首领那里复制（同步）消息，不过有各种原因会导致同步失败，但是最终会保持一致；首领通过查看每个跟随者请求的最新偏移量，首领就会知道每个跟随者复制的进度。如果跟随者在10s 内没有请求任何消息，或者虽然在请求消息，但在10s 内**没有请求最新的数据，那么它被认为是不同步的**。如果一个副本无法与首领保持一致，在首领发生失效时，它就**不可能成为新首领**—毕竟它没有包含全部的消息。相反，**持续请求得到的最新消息副本被称为同步的副本**。在首领发生失效时，只有同步副本才有可能被选为新首领。

###### 首选首领

- 除了当前首领之外，每个分区都有一个首选首领——**创建主题分区时选定的首领就是分区的首选首领**。之所以把它叫作首选首领，是因为**在创建分区时，需要在broker 之间均衡首领**，因此，我们希望首选首领在成为真正的首领时，broker 间的负载最终会得到均衡。
- 默认情况下，Kafka 的auto.leader.rebalance.enable 被设为true，它会检**查首选首领是不是当前首领**，如果不是，并且该副本是同步的，那么就会**触发首领选举**，让首选首领成为当前首领。
- 分区的副本清单里的第一个副本一般就是首选首领；

##### 04：处理请求

- broker 的大部分工作是处理客户端、分区副本和控制器发送给分区首领的请求，按照请求到达的顺序来处理它们，这种顺序保证**保存的消息是有序的**。

###### Kafka 处理请求的流程

1. broker 会在它所监听的每一个端口上运行一个 **Acceptor 线程**，这个线程会创建一个连接，并把它交给**Processor 线程**去处理；
2. Processor 线程（也被叫作“网络线程”）的数量是可配置的。网络线程负责从客户端获取请求消息，把它们放进请求队列；
3. **IO 线程**负责处理他们，然后从响应队列获取响应消息，把它们发送给客户端；
4. ![kafka-process-req](/Users/likang/Code/Git/Middleware/05：MQ/photos/kafka-process-req.png)

###### 客户端如何知道把请求发送给分区的首领副本？

- 客户端使用了另一种请求类型，也就是**元数据请求**。这种请求包含了**客户端感兴趣的主题列表**。服务器端的响应消息里指明了这些**主题所包含的分区、每个分区都有哪些副本，以及哪个副本是首领**。元数据请求可以发送给任意一个broker，因为**所有broker 都缓存了这些信息**。
- 一般情况下，**客户端会缓存这些信息**，并直接往目标broker 上发送生产请求和获取请求。它们需要时不时地通过**发送元数据请求来刷新这些信息**（刷新的时间间隔通过metadata.max.age.ms 参数来配置），从而知道元数据是否发生了变更；

###### 生产请求

- **生产者发送的请求**，它包含客户端要写入broker 的消息。

###### 获取请求

- 在消费者和跟随者副本需要**从broker 读取消息时发送的请求**。















