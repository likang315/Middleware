### 事件（Event）

------

[TOC]

##### 01：事件

- Redis 服务器是一个事件驱动程序， 服务器需要处理两类事件；
- 文件事件：用于处理 Redis 服务器和客户端之间的网络IO的抽象；
- 时间事件：用于处理定时任务的的抽象；

##### 02：文件事件

- Redis 基于 **Reactor 模式**开发了自己的网络事件处理器： 这个处理器被称为**文件事件处理器( file event handler)**。
- 文件事件处理器使用 **IO 多路复用( multiplexing )** 程序来同时监听多个套接字， 并根据套接字目前执行的任务来为**套接字关联不同的事件处理器**。
- 当被监听的套接字准备好执行连接应答（ accept )、读取（ read )、写人( write )、关闭( close ) 等操作时， 与操作相对应的文件事件就会产生， 这时**文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。**

###### 文件事件处理器的构成

- 文件事件处理器分为四个部分
  -  套接字；
  - I/0 多路复用技术；
  - 文件事件分派器(dispatcher )；
  - 事件处理器；
- 文件事件是对套接字操作的抽象，每**当一个套接字准备好执行连接应答(accept )、写人、读取、关闭等操作时**，就会产生一个文件事件。因为一个服务器通常会连接多个套接字， 所以多个文件事件有可能会并发地出现。
- I/0 多路复用技术：负责**监听多个套接字**，并向文件事件分派器**传送产生了事件的套接字**。尽管多个文件事件可能会并发地出现， 但I/0 多路复用程序总是会将所有产生事件的套接字**都放到一个队列里**面， 然后通过这个队列， 以有序( sequentially ) 、同步(synchronously)、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（ 该套接字为事件**所关联的事件处理器执行完毕**）， I/0 多路复用程序才会继续向文件事件分派器传送下一个套接字；

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/event_io.png" alt="event_io" style="zoom:90%;" />

###### I0 多路复用程序的实现

- Redis 为每个I/0 多路复用函数库实现了相同的API , 所以l/0 多路复用程序的底层实现是可以互换，在实现源码中用 #include 宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I/0 多路复用函数库来作为Redis 的I/0 多路复用程序的底层实现。

###### 事件的类型

- I/0 多路复用程序可以监听多个套接字的ae.h/AE_READABLE 事件和ae.h/AE_WRITABLE 事件
  - 当**套接字变得可读时**（客户端对套接字执行write操作，或执行close操作），或有新的可应答( acceptable ) 套接字出现时，客户端对服务器的监听套接字执行connect 操作， 套接字产生AE_READABLE 事件。
  - 当**套接字变得可写时**（客户端对套接字执行read 操作），套接字产生AE_WRITABLE 事件;
  - 可读、可写操作时相对于服务器而言的；
- I/0 多路复用程序允服务器同时监听套接字的AE_READABLE 事件和AE_WRITABLE事件，如果一个套接字同时产生了两种事件，那么文件事件分派器会优先处理AE_READABLE 事件，等到AE_READABLE 事件处理完之后，才处理AE_WRITABLE事件。

##### 03：文件事件处理器

- Redis为文件事件编写了多个处理器   些事件处理器分别用于实现不同的网络需求；

###### 连接应答处理器【监听套接字】

- networking.c/acceptTcpHandler 函数是Redis的连接应答处理器，这个处理器用于对连接 服务器监听套接字的客户端行为应答，具体实现为sys/socket.h/accept函数的包装。
- 当Redis 服务器进行初始化的时候 ，程序会**将这个连接应答处理器和服务器监听套接字的AE_READABLE 事件关联起来**，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，**套接字就会产生AE_READABLE 事件**，引发连接应答处理器执行相应的套接字应答到操作；

###### 命令请求处理器【客户端套接字】

- networking.c/readQueryFromClient 函数是Redis 的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令 求内容，具体实现为unistd.h/read 函数的包装。
- 当一个客户端通过连接应答处理器成功接到服务器之后 ，服务器会将客户端套接字的AE_READABLE 事件和命令请求处理器关联起来，**当客户端向服务器发起命令请求的时候，套接字就会产生AE_READABLE 事件，引发命令请求处理器执行**，并执行相应的套接字读入操作；

###### 命令回复处理器

- networking.c/sendReplyToClient 函数是Redis 的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过接字返回给客户端，具体实现为unistd.h/write 函数的包装。
- 当服务器有命令回复需要传送给客户端的时候，**服务器会将客户端套接字的AE_WRITABLE 事件和命令回复处理器关联起来  当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE 事件，引发命令回复处理器执行**，并执行相应的套接字写入操作。当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE 事件之间的关联。

##### 04：时间事件

- 时间事件分为两类：
  - 定时事件：一段程序在指定的时间之后执行一次。
  - 周期性事件：一段程序每隔指定时间就执行一次。
- 一个时间事件三个属性组成：
  1. Id：服务器为时间事件创建的全局唯一ID标号，ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID 号大。
  2. when: 毫秒精度的UNIX 时间戳，记录了实际那事件的到达 ( arrive ) 时间。
  3. timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。
- 判断一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值，如果事件处理器返回回 ae.h/AE_NOMORE , 那么该事件为定时事件，事件在到一次之后就会被删除，之后不再到达。
- 如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性事件，当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到，并以这种方式一直更新并行下去。

###### 实现

- 服务器将所有时间事件都放在一个链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。（已到达：指时间事件的when 属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳）。
- 不会影响性能，因为正常情况下只有一个时间事件（severCron函数），几乎将链表退化成一个指针使用；
  - 定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行； 


##### 04：事件的调度与执行

- 因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应处理文件事件，何时又应处理时间事件；

- 事件的调度和执行由ae.c/aeProcessEvents 函数负责；

- ```c++
  def aeProcessEven七s ( ) :
  # 获取到达时间离当前时间最接近的时间事件
  七ime_event = aeSearchNearestTimer( )
  # 计算最接近的时间事件距离到达还有多少毫秒
  remaind_ms = time_event.when - unix_ts_now ( )
  # 如果事件巳到达，那么remaind_ms 的值可能是负数，将它设定为0
  if rernaind_rns < 0 :
  	rernaind_ms = 0
  # 根据remaind_ms 的值  创建timeval 结构
  timeval = create_timeval_with_ms(remaind_ms)
  # 阻塞并等待文件事件产生,最大阻塞时间由传入的 timeval 结构决定
  # 如果remaind_ms的值为0，那么aeApiPoll调用之后马上返回，不阻塞
  aeApiPoll（timeval)
  # 处理所有巳产生的文件事件
  processFileEvents ()
  # 处理所有已到 的时 事件
  processTimeEvents ()
  ```



