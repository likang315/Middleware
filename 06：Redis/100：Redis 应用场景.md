### Redis 应用场景

------

[TOC]

##### 01：缓存

- 相比基于内存的 Redis，基于磁盘存储的关系型数据库读取⽤时会⾮常⻓，主要有⼀下⼏个原因:
  1. Redis 的数据存储在内存中，RDS 的数据主要存储于磁盘；
  2. Redis 的查询⽅式是 Hash，效率接近于 O(1)，⽽ RDS 的查询⽅式是 B+Tree；
  3. Redis 只缓存热点数据，并且存在过期时间和内存淘汰，注定数据量⼩, ⽽ RDS 需要存储全量数据；

###### 缓存策略

- Cache Aside（旁路缓存）
  - 写策略：先更新数据库中的数据，再删除缓存中的数据；
  - 读策略：
    - 如果读取的数据命中了缓存，则直接返回数据；
    - 如果读取的数据没有命中缓存，则从数据库中读取数据，然后**将数据回写到缓存**，并且返回给用户。
- Read/Write Through（读穿 / 写穿）策略
  - 应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互；

##### 02：缓存雪崩、缓存击穿、缓存穿透

- **缓存雪崩**：当**缓存服务器宕机或者大量缓存集中在某一个时间段失效**，会给后端系统(比如DB)带来很大压力；
- **缓存击穿**：跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，**而缓存击穿是一个热点的Key失效**，有大并发集中对其进行访问，突然间这个Key失效了，导致大量请求全部打在数据库上，导致数据库压力倍增；
  - 微信公众号获取token；
- **缓存穿透**：发送的请求**传进来的key是不存在Redis中的**（永远不存在），那么就查不到缓存，查不到缓存就会去数据库查询，导致数据库压力倍增，这些请求**像“穿透”了缓存**一样直接打在数据库上；
  - 这和缓存击穿有根本的区别，区别在于**缓存穿透的情况是传进来的key在Redis中是不存在的**。

###### 解决雪崩

- 惰性删除、定期删除【贪心策略】；
- 熔断机制；

###### 解决击穿

1. 业务允许的情况下，**热点key永不过期**；

2. **redis 使用分布式锁**，SETNX，是「SET if Not Exists」的缩写，也就是只有不存在的时候才设置，只有获得所得线程才可以查询数据库；

3. ```java
   public String get(key) {
       String value = redis.get(key);
       // 代表缓存值过期
       if (value == null) {
           // 设置3min的过期时间，防止del操作失败的时候，下次缓存过期一直不能load db
           if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {
               // db 获取value
               value = db.get(key);
               redis.set(key, value, expire_secs);
               redis.del(key_mutex);
           } else {
               // 代表同时其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
               sleep(50);
               // 重试
               get(key);
           }
       } else {
         	return value;      
       }
   }
   ```

###### 解决穿透

1. 布隆过滤器提前拦截；
   - 通过布隆过滤器查询元素存在不存在，**在查询的时候先去布隆过滤器查询 key 是否存在**，如果不存在就直接返回；
   - 由一个固定大小的二进制向量或者位图（bitmap）和一系列映射函数组成的； 
     - 如果这些点有任何一个 0，则被查询变量一定不在；
     - 如果都是 1，则被查询变量很**可能存在**，因为映射函数本身就是散列函数，**散列函数是会有碰撞的**；
2. 把无效的Key存进Redis中；
   - 如果Redis查不到数据，数据库也查不到，我们**把这个Key值保存进Redis，设置value="null"**，这种处理方式肯定是有问题的，假如**传进来的这个不存在的Key值每次都是随机的**，那存进Redis也没有意义。

##### 03：缓存一致性

- Redis 和 MySQL 同时存储数据，保证数据一致性；

###### 四种情况

- 先更新缓存，再更新数据库
- 先更新数据库，再更新缓存
- 先删除缓存，再更新数据库
- 先更新数据库，再删除缓存

###### 一致性解决方案

- 延迟双删
  - 先删除缓存，再更新数据库，由于网络抖动，数据库延迟删除，延迟期间新请求会重新把数据库数据缓存下来，需要使用延迟消息（sleep）再次删除缓存；
- MQ 异步删除
  - 先更新数据库，再删除缓存，若删除失败，异步发送删除消息到 MQ，消费者重新删除进行兜底；
  - redis 删除失败，通过监听 bin log ，再次删除缓存进行兜底；
- 分布式事务
  - 使用分布式事务保证原子性；

##### 04：分布式锁

- 分布式锁的本质是**在 Redis 中 设置⼀个标识，当其他进程试图来访问的时候，发现已经有标识, 代表该资源已被锁住**, 就需要放弃或者重试；

- SETNX：（ET if Not eXists）

  - 语义：key存在的情况下，不操作redis内存；也就是返回值是0；

  - ```java
    SET lock_key value NX PX 10000
    ```
  
- 使⽤ **setnx(set if not exists) 指令，** 只允许被⼀个客户端占领，当使⽤完毕后，再调⽤ del 指令释放。

- 有⼀个问题，如果逻辑执⾏中**出现了异常，可能会导致 del 指令没有调⽤**，锁永远就没有机会得到释放，因此在拿到锁之后, 再**给锁加上⼀个过期时间**，即使出现异常也可以保证 5 秒之后锁⾃动释放，但是如果在加锁和释放锁之间的逻辑执⾏太⻓， 以⾄于超出了锁的过期时间，就会**导致多个线程重新获取这把锁，导致并发异常**，为了避免这个问题，需要**给锁重新续期**。

###### 分布式锁加锁 + 释放锁

1. 加锁 + 设置过期时间，两步，第一步刚成功宕机了，造成死锁；
   - **SET NX EX**  命令两个参数解决；
     - NX 参数：
       - 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；
       - 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。
     - EX  参数
       - 过期时间，单位秒；
2. 获得锁执行任务，任务未执行完，锁到期释放了，造成多个线程获得锁；
   - **Watchdog（看门狗）**
      - 自动延期：加锁时，若未设置过期时间，自动延期30s；
      - Config.lockWatchdogTimeout：30s；
3. 释放锁
   -  Lua 脚本来保证解锁的原子性，两步，判断**是否加锁客户端 + 删除 key**；


###### 实现分布式锁的缺点

1. 超时时间不好设置（过长 + 过短）；
2. 不可靠的，主从复制，从节点未来得及同步锁信息；

###### 实现可靠的分布式锁

- Redlock（红锁）
  - 让客户端和多个独立的 Redis 节点（5 个）依次请求申请加锁，如果**客户端能够和半数以上的节点成功地完成加锁操作**，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。
  - **加锁成功的条件**
    1. 客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁；
    2. 客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。


##### 05：布隆过滤器

- 使用了 m 个哈希函数，每个字符串跟 m 个bit对应，从而降低了冲突的概率。
- 利用了 BitSet 特性；

##### 06：延迟队列

- 利用 SortedSet 特性，score 存储当前时间戳，死循环获取时间戳最小的任务，若小于当前时间执行；
- 若长时间没有任务执行，休眠1s，防止qps过大；

##### 07：限流器

- 设置并发大小，设置拒绝策略；
