### Redis Client

------

[TOC]

##### 01：redis 客户端简介

- Redis服务器是典型的一对多服务器程序，一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令 请求，服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。
- 通过使用由I/0 多路复用技术实现的文件事件处理器，Redis服务器使用单线程（6.0一下）单进程的方式来处理命令请求请求与多个客户端进行网络通信。
- Redis服务器状态结构的clients属性是一个链表，这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批 操作或者查找某个指定的客户端，都可以遍历clients 链表来完成。

###### CLIENT LIST 命令

- 查看所有连接到服务器的客户端信息和统计数据

- ```c
  redis 127.0.0.1:6379> CLIENT LIST
  ```

###### RedisClient

```c
struct redisServer {
    // 一个链表，保存了所有客户端
    list* clients;
}

typedef struct redisClient {
    # 记录IP 和port
    sds addr;
    // 记录了客户端正在使用的套接字描述符
	int fd;
    // 记录客户端的角色，以及客户端目前所处的状态
    int flags;
    // 用于保存客户端发送的命令请求
    sds querybuf;
    // 命令参数
    robj **argv;
    // 参数个数
    int argc;
    // 指向了请求命令的实现方法
    struct redisCommand *cmd;
    // 请求命令的短回复
    char buf[REDIS_REPLY_CHUNK_BYTES];
    // 短回复所占用空间
    int bufpos;
    // 请求命令的长回复
    list *reply;
    // 验证身份是否通过
    int authenticated;
    // 时间属性
    time_t ctime;
	time_t lastinteraction;
	time_t obuf_soft_limit_reached_time;
    ...
} redisClient;
```

##### 02：客户端属性

###### 套接字描述符

- 伪客户端( fake client ) 的 **fd属性** 的值为 -1，伪客户端处理的命令请求来源于AOF文件或 Lua 脚本，不是网络，所以这种客户端不需要套接字连接，自然也不需要记录套接字描述符；
- 普通客户端的 fd 属性的值为大于 -1 的整数，普通客户端使用套接字来与服务器进行通信，所以服务器会用fd 属性来记录客户端套接字的描述符。
- CLIENT list ：查看连接redis 服务器的所有客户端；

###### 名字

- flags 属性的值可以是**单个标志，也可以是多个标志**的二进制；
- 每个标志使用一个常量表示，一部分标志记录了客户端的角色；
  - **REDIS_MASTER：** 标志表示客户端代表的是一个主服务器， **REDIS_SLAVE** 标志表示客户端代表的是一个从服务器。
  - 在主从服务器进行复制操作时， 主服务器会成为从服务器的客户端， 而从服务器也会成为主服务器的客户端。 
  - **REDIS_PRE_PSYNC：** 标志表示客户端代表的是一个版本低于 Redis 2.8 的从服务器， 主服务器**不能使用 PSYNC 命令与这个从服务器进行同步**。 这个标志只能在 `REDIS_SLAVE` 标志处于打开状态时使用。
  - **REDIS_LUA_CLIENT：**标识表示客户端是**专门用于处理 Lua 脚本里面包含的 Redis 命令的伪客户端**。
- 另外一部分标志则记录了客户端目前所处的状态：
  - **REDIS_MONITOR：**标志表示客户端正在执行 MONITOR 命令。
  - **REDIS_UNIX_SOCKET：** 标志表示服务器使用 UNIX 套接字来连接客户端。
  - `REDIS_BLOCKED` 标志表示客户端正在被 BRPOP 、 BLPOP 等命令阻塞。
  - `REDIS_UNBLOCKED` 标志表示客户端已经从 `REDIS_BLOCKED` 标志所表示的阻塞状态中脱离出来， 不再阻塞。 
  - **REDIS_MULTI：** 标志表示客户端正在执行事务。
  - `REDIS_DIRTY_CAS` 标志表示事务使用 WATCH 命令监视的数据库键已经被修改， `REDIS_DIRTY_EXEC` 标志表示事务在命令入队时出现了错误， 以上两个标志都表示事务的安全性已经被破坏， 只要这两个标记中的任意一个被打开， EXEC 命令必然会执行失败。 这两个标志只能在客户端打开了 `REDIS_MULTI` 标志的情况下使用。
  - **REDIS_CLOSE_ASAP：** 标志表示客户端的输出缓冲区大小超出了服务器允许的范围， 服务器会在下一次执行 `serverCron` 函数时关闭这个客户端， 以免服务器的稳定性受到这个客户端影响。 积存在输出缓冲区中的所有内容会直接被释放， 不会返回给客户端。
  - **REDIS_CLOSE_AFTER_REPLY：** 标志表示有用户对这个客户端执行了 CLIENT_KILL 命令， 或者客户端发送给服务器的命令请求中包含了错误的协议内容。 服务器会将客户端积存在输出缓冲区中的所有内容发送给客户端， 然后关闭客户端。
  - **REDIS_ASKING：**标志表示客户端向集群节点（运行在集群模式下的服务器）发送了 ASKING 命令。
  - **REDIS_FORCE_AOF：** 标志强制服务器将当前执行的命令写入到 AOF 文件里面， `REDIS_FORCE_REPL` 标志强制主服务器将当前执行的命令复制给所有从服务器。 执行 PUBSUB 命令会使客户端打开 `REDIS_FORCE_AOF` 标志， 执行 SCRIPT_LOAD 命令会使客户端打开 `REDIS_FORCE_AOF` 标志和 `REDIS_FORCE_REPL` 标志。

###### 输入缓冲区

- 用于保存客户端**发送的命令请求**；
- 将命令转换成SDS存储，输入缓冲区的大小会根据输入内容动态地缩小或者扩大， 但它的最大大小不能超过 1 GB ， 否则服务器将关闭这个客户端。

###### 命令与命令参数

- 在服务器将客户端发送的命令请求保存到客户端状态的 `querybuf` 属性之后， 服务器将对命令请求的内容进行分析， 并将得出的**命令参数以及命令参数的个数**分别保存到客户端状态的 `argv` 属性和 `argc` 属性：
- **argv：** 属性是一个数组， 数组中的每个项都是一个字符串对象： 其中 `argv[0]` 是要执行的命令， 而之后的其他项则是传给命令的参数。
- **argc：** 属性则负责记录 `argv` 数组的长度。

###### 命令的实现函数

- 当服务器从协议内容中分析并得出 `argv` 属性和 `argc` 属性的值之后， 服务器**将根据项 `argv[0]` 的值， 在命令表中查找命令所对应的命令实现函数**。
- 当程序在命令表中成功找到 `argv[0]` 所对应的 `redisCommand` 结构时， 它会将**客户端状态的 `cmd` 指针指向这个结构**，服务器就可以使用 `cmd` 属性所指向的 `redisCommand` 结构， 以及 `argv` 、 `argc` 属性中保存的命令参数信息， 调用命令实现函数， 执行客户端指定的命令。

###### 输出缓冲区

- 执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面， **每个客户端都有两个输出缓冲区可用， 一个缓冲区的大小是固定的， 另一个缓冲区的大小是可变的**，当 `buf` 数组的空间已经用完， 或者回复因为太大而没办法放进 `buf` 数组里面时， 服务器就会开始使用可变大小缓冲区。
  - 固定大小的缓冲区用于保存那些长度比较小的回复， 比如 `OK` 、简短的字符串值、整数值、错误回复，等等。
  - 可变大小的缓冲区用于保存那些长度比较大的回复， 比如一个非常长的字符串值， 一个由很多项组成的列表， 一个包含了很多元素的集合， 等等。
- 客户端的固定大小缓冲区由 `buf` 和 `bufpos` 两个属性组成：
  - **buf：**是一个大小为 `REDIS_REPLY_CHUNK_BYTES` 字节的字节数组
  - **bufpos:** 属性则记录了 `buf` 数组目前已使用的字节数量。
- 可变大小缓冲区由 **reply** 链表和一个或多个字符串对象组成：

###### 身份验证

- 客户端状态的 `authenticated` 属性用于记录客户端是否通过了身份验证；
- 如果 `authenticated` 的值为 `0` ， 那么表示客户端未通过身份验证； 如果 `authenticated` 的值为 `1` ， 那么表示客户端已经通过了身份验证。
- `authenticated` 属性仅在服务器启用了身份验证功能时使用： 如果服务器没有启用身份验证功能的话， 那么即使 `authenticated` 属性的值为 `0` （这是默认值）， 服务器也不会拒绝执行客户端发送的命令请求。

###### 时间相关的属性

- **ctime：** 属性记录了**创建客户端的时间**， 这个时间可以用来计算客户端与服务器已经连接了多少秒；
- **lastinteraction：** 属性记录了客户端与服务器**最后一次进行互动（interaction）的时间**；
- **obuf_soft_limit_reached_time：** 属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间；

##### 03：客户端的创建与关闭

###### 创建普通客户端

- 如果客户端是通过 网络连接与服务器进行连接的普通客户端，那么在客户端使用connect 函数连接到服务器时，服务器就会 调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构 client 链表的末尾。

###### 关闭普通客户端

1. 如果**客户端进程退出或被杀死**，那么客户端与服务器之间的网络接将被关闭，从而造成成客户端关闭。
2. 如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会服务器关闭。
3. 如果客户端成为了CLIENT KI LL命令的目标，那么它也会被关闭。
4. 如果用户为服务器设置了 timeout 配置选项，那么当**客户端的空转时间超过 timeout时**，那么客户端将关闭。
   - 例外情况
   - 如果客户端是主服务器，从服务器正在 BLPOP 等命令阻塞，或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令   ，那么即使客户端的空转时间超过了 timeout 值，客户端也不会被服务器关闭；
5. 如果客户端发送的命令请求的大小超过了**输入缓冲区的限制大小**（默认为 1GB )，那么这个客户端也会被服务器关闭。
6. 如果服务器发送给客户端的命令回复的大小超过了**输出缓冲区的限制大小**，那么这个客户端会被服务器关闭。
   - 服务器会时刻检查客户端的输出缓冲区的大小，并在缓冲区的大小超出范围时，执行相应的限制操作。【两种】
   - **硬性限制(hard limit ) :** 如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。
   - **软性限制(soft limit ) :** 如果输出缓冲区的大小超了软性限制所设置的大小， 但还没超出硬性限制，那么服务器将使用客户端状态结构的 **obuf_soft_limit_reached_time** 属性记录下客户端到达软性限制的起始时间，之后服务器会继续监视客户端，如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端，相反地，客户端就不会被关闭，并且obuf_soft_limit_reached_time会被清零。
   - client_output_buffer_limit：为客户端设置硬性、软性大小及时间。

###### AOF 伪客户端

- 服务器在载入AOF 文件时，会创建**用于执行AOF 文件包含的Redis 命令的伪客户端**，并在载入完成之后，关闭该伪客户端。

###### lua 脚本的伪客户端

- 服务器会在**初始化时创建负责执行 Lua 脚本中包含的Redis 命令的伪客户端**，并将这个伪客户端关联在服务器状态结构的 lua_client 属性中。
- lua_client 伪客户端**在服务器运行的整个生命期中会一直存在**，只有服务器被关闭时，该客户端才会关闭。






