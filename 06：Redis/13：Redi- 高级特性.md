### Redis 特性

------

[TOC]

##### 01：Redis 版本

| Redis 6.0     | 2020年4月1日  | 支持多个数据类型的隔离模块、Stream数据类型和Consumer group等 |
| ------------- | ------------- | ------------------------------------------------------------ |
| Redis 5.0     | 2018年10月1日 | 支持RDB增量持久性                                            |
| **Redis 4.0** | 2017年8月1日  | 支持模块化编程、更好的集群管理工具                           |
| **Redis 2.8** | 2014年4月1日  | 支持lua脚本、支持更多的数据类型（如sorted set、HyperLogLog） |
| Redis 1.0     | 2009年3月15日 | 支持基本的键值存储和简单的持久化                             |

##### 02：非阻塞删除（lazyfree）

- 一个单线程模型的服务，当执行一些耗时的命令时，比如使用DEL**删除一个大key，会造成redis阻塞，影响redis性能，**甚至导致集群发生故障转移。因此，redis 4.0 开始引入。
- **lazyfree 机制：**将删除键或数据库的操作放在**后台线程里执行，删除对象时只是进行逻辑删除**，从而尽可能地避免服务器阻塞。

###### 主动删除键使用 lazyfree

- **UNLINK**：与DEL一样删除key功能的lazy free实现。
  - UNLINK 在删除集合类型键时，如果集合键的元素个数大于 64 个，主线程中只是把待删除键从数据库字典中摘除，会把真正的内存释放操作，给单独的bio来操作。如果元素个数较少（少于64个）或者是String类型，也会在主线程中直接删除。
- **flushall/flushdb async**：添加了async异步清理选项，使得redis在清空数据库时都是异步操作。
  - 实现逻辑是为数据库新建一个新的空的字典，把原有旧的数据库字典给后台线程来逐一删除其中的数据，释放内存。

###### 被动删除键使用 lazyfree

- 目前有4种场景，每种场景对应一个配置参数； 默认都是关闭。
  1. lazyfree-lazy-eviction
  2. slave-lazy-flush
  3. lazyfree-lazy-expire
     - 建议开启；
  4. lazyfree-lazy-server-del
     - 建议开启；内部删除选项，针对有些指令在处理已存在的键时，会带有一个隐式的DEL键的操作。

###### lazyfree 监控

- **lazyfree_pending_objects**，表示在 redis 执行 lazyfree 操作时，等待被实际回收内容的键个数。













##### Redis 事务

1. 批量操作在发送 EXEC 命令前被**放入队列缓存**；
2. **收到 EXEC 命令后进入事务执行**，事务中任意命令执行失败，其余的命令依然被执行，没有原子性；
3. 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中，隔离性；
4. 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 **Redis 事务的执行并不是原子性的**； 
   - Multi：标记一个事务块的开始
   
   - Exec： 执行所有事务块内的命令
   
   - discard ：取消事务，放弃执行事务块内的所有命令
   
   - watch key [key ...]：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
   
   - unwatch： 取消 WATCH 命令对所有 key 的监视
   
   - ```shell
     127.0.0.1:6379> multi
     OK
     127.0.0.1:6379> set a 3
     QUEUED
     127.0.0.1:6379> lpop a
     QUEUED
     127.0.0.1:6379> exec
     1) OK
     2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
     ```

##### 07：管道技术

- Redis 是一种基于客户端-服务端模型以及请求/响应协议的TCP服务

1. **客户端进程**调⽤ write 将消息写到**操作系统内核为 socket 分配的发送缓冲 send buffer**
2. 客户端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到服务端⽹卡
3. 服务端操作系统将⽹卡中的数据放到内核为 socket 分配的**接受缓冲 recv buffer**
4. 服务端进程**调⽤ read 将消息从接受缓冲取出并进⾏处理**
5. **服务端进程**调⽤ write 将执⾏结果写到内核为 socket 分配的发送缓冲 send buffer
6. 服务端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到客户端⽹卡
7. 客户端操作系统将⽹卡中的数据放到内核为 socket 分配的**接收缓冲 recv buffer**
8. 客户端进程调⽤ read 将消息从接收缓冲取出并返回给上层业务逻辑进⾏处理

###### 管道优势

- write 操作只需要**将数据写到本机操作系统内核的 send buffer 就返回,** 剩下的操作交由操作系统内核
  异步将数据发送到⽬标服务器;
- read 操作**只需要将数据从本机操作系统内核的 recv buffer 读取出来即可,** 但如果缓冲是空的, 就需要
  等待数据的到来, 这是 read 操作真正耗时的地⽅;
- 对于管道来说, 连续的 read 操作⼏乎不会耗时, **只有第⼀个 read 操作会等待⼀个⽹络的来回开销**, 然
  后所有的响应消息就都**已经回送到内核的接受缓冲**了, 后续的 read 操作直接就可以从缓冲拿到结果, 瞬
  间就返回了；



##### 08：Redis 6.0

- Redis 6.0 之前本身是单线程，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”；
- 使用Redis时，几乎不存在CPU成为瓶颈的情况，Redis 主要受限于内存和网络开销。

###### 阻塞IO

当使⽤ **socket** 的读写⽅法时, 默认是阻塞的, ⽐如 read ⽅法传⼊参数 n, 代表最多读取 n 个字节后再返回, 如果⼀个字节都没有，那么线程就会阻塞, 直到新的数据到来或者连接关闭才返回. ⽽ write ⼀般不会阻塞, 除⾮内核为 socket 分配的写缓冲区已经满了. socket 线程就会阻塞直到缓冲区有空闲空间。

###### 非阻塞IO

⾮阻塞 **IO 在套接字上提供了⼀个选项 Non_blocking,** 当这个选项打开的时候, 读写⽅法不会阻塞, **能读多少读多少, 能写多少写多少.** 能读多少取决于**内核为 socket 分配的读缓冲区内数据**, 能写多少取决于写缓冲区的空闲空闲字节数. **读写⽅法都会通过返回值来告知调⽤⽅实际读写了多少字节**，⾮阻塞 IO 意味着线程在读写 IO 的时候不必再阻塞, 读写可以瞬间完成然后线程继续其他任务；

###### 多线程 Redis

- 因为读写网络的 read/write 系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗，因此**提高网络 IO 性能**或者**使用多线程充分利用多核**，来优化redis性能；

- 多线程**默认是禁用的**，只使用主线程。如需开启需要修改redis.conf配置文件

- 开启多线程后，还需要**设置线程数**，否则是不生效的。同样修改redis.conf配置文件，和核数对应；

- ```sh
  io-threads-do-reads yes
  io-threads 4
  ```

- Redis的多线程部分**只是用来处理网络数据的读写和协议解析**，执行命令仍然是单线程顺序执行，并不存在并发安全问题；

