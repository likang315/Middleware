### Redis 对象

------

[TOC]

##### 01：对象（数据类型）

- Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了**一个对象系统**， 这个系统包含**字符串对象、列表对象、哈希对象、集合对象和有序集合对象**这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。
- 使用对象的好处是， 可以**针对不同的使用场景， 为对象设置多种不同的数据结构实现**， 从而优化对象在不同场景下的使用效率【内存，读取效率】。

##### 02：对象的类型与编码【重要】

- 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象**用作键值对的键**（键对象）， 另一个对象**用作键值对的值**（值对象）。

###### Redis 中的每个对象都由**一个 `redisObject` 结构**表示

- ```c
  typedef struct redisObject {
      // 数据类型
      unsigned type:4;
      // 编码
      unsigned encoding:4;
      // 指向底层实现数据结构的指针
      void *ptr;
      // 引用计数 & 共享对象
      int refcount;
      // 该对象最后一次被命令程序访问的时间
      unsigned lru:22;
  } robj;
  ```

###### 对象的Type 属性【对应Type命令】

- | 类型常量       | 对象的名称   |
  | :------------- | :----------- |
  | `REDIS_STRING` | 字符串对象   |
  | `REDIS_LIST`   | 列表对象     |
  | `REDIS_HASH`   | 哈希对象     |
  | `REDIS_SET`    | 集合对象     |
  | `REDIS_ZSET`   | 有序集合对象 |

  对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：

  - 当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；
  - 当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”；

###### 编码和底层实现

- 对象的 `ptr` 指针指向对象的底层实现数据结构， 而这些**数据结构由对象的 `encoding` 属性**决定。

- 不同类型和编码的对象【使用 **OBJECT ENCODING key** 命令可以查看一个值对象的编码】

- | 对象           | 编码（数据结构常量）         | 说明                                                 |
  | :------------- | :--------------------------- | :--------------------------------------------------- |
  | `REDIS_STRING` | `REDIS_ENCODING_INT`         | 使用整数值实现的字符串对象。                         |
  | `REDIS_STRING` | `REDIS_ENCODING_EMBSTR`      | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |
  | `REDIS_STRING` | `REDIS_ENCODING_RAW`         | 使用简单动态字符串实现的字符串对象。                 |
  | `REDIS_LIST`   | **`REDIS_ENCODING_ZIPLIST`** | 使用压缩列表实现的列表对象。                         |
  | `REDIS_LIST`   | `REDIS_ENCODING_LINKEDLIST`  | 使用双端链表实现的列表对象。                         |
  | `REDIS_HASH`   | **`REDIS_ENCODING_ZIPLIST`** | 使用压缩列表实现的哈希对象。                         |
  | `REDIS_HASH`   | `REDIS_ENCODING_HT`          | 使用字典实现的哈希对象。                             |
  | `REDIS_SET`    | `REDIS_ENCODING_INTSET`      | 使用整数集合实现的集合对象。                         |
  | `REDIS_SET`    | `REDIS_ENCODING_HT`          | 使用字典实现的集合对象。                             |
  | `REDIS_ZSET`   | **`REDIS_ENCODING_ZIPLIST`** | 使用压缩列表实现的有序集合对象。                     |
  | `REDIS_ZSET`   | `REDIS_ENCODING_SKIPLIST`    | 使用跳跃表和字典实现的有序集合对象。                 |

##### 03：字符串对象

- **字符串对象的编码可以是 `int` 、 `raw` 或者 `embstr` 。**
- 如果一个字符串对象保存的是整数值， 并且这个整数值可以用 `long` 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 `ptr` 属性里面（将 `void*` 转换成 `long` ）， 并将字符串对象的编码设置为 `int` 。
  - 值存储在了指向数据结构的指针；
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度**大于 44字节**， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw；
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度**小于等于 `44` 字节**， 那么字符串对象将使用 `embstr` 编码的方式来保存这个字符串值。
  - **`embstr` 编码**：是专门用于**保存短字符串的一种优化编码方式。**这种编码和 `raw` 编码一样， 都使用 `redisObject` 结构和 `sdshdr` 结构来表示字符串对象， 但 `raw` 编码会调用**两次内存分配函数**来分别创建 `redisObject` 结构和 `sdshdr` 结构， 而 `embstr` 编码则通过**调用一次内存分配函数来分配一块连续的空间**， 空间中依次包含 `redisObject` 和 `sdshdr` 两个结构。
- 一般用 `long、double` 类型表示的**浮点数在 Redis 中也是作为字符串值来保存的**，如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存，用的时候在反转回来。

###### 编码的转换

- `int` 编码的字符串对象和 `embstr` 编码的字符串对象在条件满足的情况下， 会被转换为 `raw` 编码的字符串对象。
  - 追加字符串或者修改时，自动变化；

##### 04：列表对象

- **列表对象的编码可以是 `ziplist` 或者 `linkedlist` 。**
- `ziplist` 编码的列表对象使用压缩列表作为底层实现， 每个**压缩列表节点（entry）保存了一个列表元素**。
-  `linkedlist` 编码的列表对象使用双向链表作为底层实现， 每个**双向链表节点（node）都保存了一个列表元素。**
  - 列表对象元素是字符串对象；
- <img src="https://github.com/likang315/Middleware/blob/master/06：Redis/photos/linkedlist_str.png?raw=true" style="zoom:60%;" />

###### 编码转换

- 当列表对象可以同时满足以下两个条件时， 列表对象使用 `ziplist` 编码，不满足时列表对象需要使用 `linkedlist` 编码。
  1. 列表对象保存的所有字符串元素的长度都小于 `64` 字节；
  2. 列表对象保存的**元素数量**小于 `512` 个；

##### 05：哈希对象

- **哈希对象的编码可以是 `ziplist` 或者 `hashtable` 。**
- `ziplist` 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：
  - 保存了同一键值对的两个节点总是紧挨在一起， **保存键的节点在前， 保存值的节点在后**；
- `hashtable` 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存;

###### 编码转换

- 当哈希对象同时满足以下两个条件时， 哈希对象使用 `ziplist` 编码，不能满足这两个条件时，使用 `hashtable` 编码。
  - 哈希对象保存的所有键值对的键和值的字符串长度都小于 `64` 字节；
  - 哈希对象保存的**键值对数量**小于 `512` 个；

##### 06：集合对象

- **集合对象的编码可以是 `intset` 或者 `hashtable` 。**
- `intset` 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。 
-  `hashtable` 编码的集合对象使用字典作为底层实现， **字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 `NULL`** 
- <img src="https://github.com/likang315/Middleware/blob/master/06%EF%BC%9ARedis/photos/intset_set_obj.png?raw=true" style="zoom:60%;" />

###### 编码的转换

- 当集合对象可以同时满足以下两个条件时，使用 `intset` 编码，不能满足这两个条件的集合对象使用 `hashtable` 编码。
  1. 集合对象保存的所有元素都是整数值；
  2. 集合对象保存的元素数量不超过 `512` 个；

##### 07：有序集合对象（sorted-set）

- **有序集合的编码可以是 `ziplist` 或者 `skiplist` 。**

- `ziplist` 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用**两个紧挨在一起的压缩列表节点来保存**， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。

- `skiplist` 编码的有序集合对象**使用 `zset` 结构作为底层实现， 一个 `zset` 结构同时包含一个跳跃表和一个字典**；

  - ```c
    typedef struct zset {
        zskiplist *zsl;
        dict *dict;
    } zset;
    ```

- `zset` 结构中的 **`zsl` 跳跃表按分值从小到大保存了所有集合元素**， 每个跳跃表节点都保存了一个集合元素，跳跃表节点的 `object` 属性保存了元素的成员， 而跳跃表节点的 `score` 属性则保存了元素的分值。 通过这个跳跃表， 程序可以**对有序集合进行范围型操作**， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。

- `zset` 结构中的 **`dict` 字典为有序集合创建了一个从成员到分值的映射**， 字典中的每个键值对都保存了一个集合元素： **字典的键保存了元素的成员， 而字典的值则保存了元素的分值**。 通过这个字典， 可以**用 O(1) 复杂度查找给定成员的分值**， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。

###### 为什么有序集合需要同时使用跳跃表和字典来实现？

- 字典保证根据元素查询分值复杂度：O(1)，跳表保证有序遍历复杂度： O(log n) ；

<img src="https://github.com/likang315/Middleware/blob/master/06%EF%BC%9ARedis/photos/zset.png?raw=true" style="zoom:60%;" />

###### 编码的转换

- 当有序集合对象同时满足以下两个条件时， 使用 `ziplist` 编码，不能满足这两个条件时，将使用 `skiplist` 编码。
  1. 有序集合保存的元素数量小于 `128` 个；
  2. 有序集合保存的所有元素成员的长度都小于 `64` 字节；

##### 08：类型检查与多态命令

- Redis 中用于操作键的命令基本上可以分为两种类型
  1. 可以对任何类型的键执行；
  2. 只能对特定类型的键执行；

###### 类型检查的实现

- 类型特定命令所进行的类型检查是通过 `redisObject` 结构的 `type` 属性来实现的：
  - 在执行一个类型特定命令之前， 服务器会先检查**输入数据库键的值对象是否为执行命令所需的类型**， 如果是的话， 服务器就对键执行指定的命令，否则， 服务器将拒绝执行， 并向客户端返回一个类型错误。

###### 多态命令的实现

- 根据值对象的编码方式， 选择正确的命令实现代码来执行命令。
- 例：
  - 列表对象有 `ziplist` 和 `linkedlist` 两种编码可用， 其中前者使用**压缩列表 API** 来实现列表命令， 而后者则使用**双向链表 API** 来实现列表命令。

##### 09：内存回收

- 因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个**引用计数法**实现的内存回收机制， 通过这一机制， 程序可以通过**跟踪对象的引用计数信息**， 在适当的时候自动释放对象并进行内存回收。
- 每个对象的引用计数信息由 `redisObject` 结构的 `refcount` 属性记录：
  - int refcount;

##### 10：共享对象

-  对象的 refcount 属性，除了用于实现引用计数内存回收机制之外，还带有**对象共享**的作用。
- 在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：
  1. 将数据库键的值指针指向一个现有的值对象；
  2. 将被共享的值对象的引用计数增一。
- 目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了**从 `0` 到 `9999` 的**所有整数值， 当服务器需要用到值为 `0` 到 `9999` 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。
- <img src="https://github.com/likang315/Middleware/blob/master/06：Redis/photos/shared-memory.png?raw=true" style="zoom:60%;" />

##### 11：对象的空转时长

-  `redisObject` 结构包含的最后一个属性为 `lru` 属性， 该属性记录了对象最后一次被命令程序访问的时间
  - unsigned lru:22;
- **删除无用的 key**：OBJECT IDLETIME 命令可以**获取给定键的空转时长**， 这一空转时长就是通过将当前时间减去键的值对象的 `lru` 时间计算得出。



