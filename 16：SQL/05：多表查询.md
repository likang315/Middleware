### 多表查询

------

[TOC]

##### 01：多表查询

###### 笛卡尔积

- 直接用 JOIN  将两个表的数据简单连接到一起；

###### 内连接

- INNER JOIN  ... ON 连接条件
  - 只有符合的才出现在结果集里，没有匹配上（某个表为NULL，使用外连接）会剔除；
  - 如果两个表的列名相同可以使用 USING 代替 ON
  - INNER JOIN ... USING(fieldName)

###### 连接多张表

- 多表的连接视为“滚雪球” ，前两个表形成一个开始滚动的“雪球”，而之后的每个表都在“雪球” 滚动时依附在上面。
- 中间结果表再去连接其他表；

###### 将子查询结果作为查询表

- INNER JOIN （SELECT * FROM tableName）a

###### 自连接

- 不仅可以在同一查询中多次包含同一个表，还可以对表自身进行连接。

- 同一张人员表表，存储了上下级关系；

- ```sql
  SELECT e.fname, e.l name, e mgr.fname mgr_fname, e_mgr.l name mgr_l name
  FROM employee e INNER JOIN employee e_mgr ON e.superior_emp_id = e mgr.emp_id;
  ```

###### 相等连接和不等连接

- ON a.start_time >= b.start_time;
  - 查询的两个表可能并**没有外键关联**；
- ON a.id != b.id
  - 对表自身使用不等连接；

###### 连接条件和过滤条件

- ON 子句使用连接条件，WHERE 使用过滤条件，可以灵活的放置条件的位置；

##### 02：外连接

P140

















##### 11：多表查询

​	从多张表中查询信息，关联查询的重点与这些表中的记录的对应关系，这个关系也称**连接条件**，N张表就有N-1个连接条件；

- 当两张表有相同字段时，SELECT子句中必须明确指定该字段来自那张表，在关联查询中，表名也可以有别名，在表名其后直接写，可以简化语句的复杂度
- 关联查询要添加连接条件，否则会产生**笛卡尔积它是一个无意义的结果集**，它的记录数是与**所有参与查询的表的记录数乘积的结果**，可能会出现内存溢出；
- SELECT e.id,e.name FROM emp e INNER JOIN dep d ON e.dep_id=d.dep_id；

##### 12：关联查询【连接查询】

![](https://github.com/likang315/Middleware/blob/master/Mysql%EF%BC%8CInnoDB/InnoDB/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png?raw=true)

###### 内连接：获取两个表中字段匹配关系的记录，可以省略 INNER 使用 JOIN，效果一样

- FROM 表名1 表1对象 INNER JOIN 表2名 表2对象 ON 连接条件 WHERE 过滤条件
- select e.id,d.dname as dep_name,e.name,e.sex,e.age FROM emp e **INNER JOIN** dep d **ON e.dep_id=d.id;**
- 会自动优化成小表驱动大表，大表加索引提高查找速度；

###### 外链接：所有数据都显示

- **左外连（LEFT JOIN）**：以JOIN左侧作为驱动表，获取左表所有记录，即使右表没有对应匹配的记录的字段值，用NULL 填充
- select e.id,d.dname as dep_name,e.name,e.sex,e.age from emp e **LEFT JOIN** dep d **ON** e.dep_id=d.id;
- **右外连（RIGHT JOIN）**：与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录的字段值，用NULL填充
- select e.id,d.dname as dep_name,e.name,e.sex,e.age from emp e **RIGHT JOIN** dep d **ON** e.dep_id=d.id;

