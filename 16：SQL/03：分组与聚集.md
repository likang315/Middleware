### 分组与聚集

------

[TOC]

##### 01：分组

- 将结果集按照指定的**字段值相同的记录分为一组**，常和聚集函数联用；

- 如果在以某字段为根据进行了分组之后，select 那个字段得到的不是这个字段的信息，而是这个字段的分组信息，如果不与聚合函数联合使用，**只显示该组第一条记录**；

- 使用SELECT查询的列，在使用分组的语句中**要不包含在group by 字段中，要不包含在聚合函数中**。不然查询会报错。

- **GROUP  BY**

  - 对数据进行分组；
  - 由于group by 是在where 子句之后运行的，因此无法对 where子句增加过滤条件（过滤时间不对），必须使用HAVING 子句使用分组过滤条件；

- **HAVING**

  - 对分组结果进行过滤

  - ```sql
    SELECT stu_id, count(*)
    FROM student
    GROUP BY stu_id
    HAVING count(*) > 0 
    ```

##### 02：聚集函数

- 聚集函数对每个分组的结果进行特定的操作；

###### 函数

- max()：返回集合中的最大值；

- min()：返回集合中的最小值；

- avg()：返回集合中的平均值；

- sum()：返回集合中的所有值的和；

- count()：返回集合中值的个数；

- ```sql
  SELECT stu.class_id, max(math) AS math, min(chinese) AS chinese, count(*)
  FROM local_student_info stu
           LEFT JOIN local_student_score s ON stu.stu_global_key = s.stu_global_key
  GROUP BY class_id
  ```

###### 隐式和显示分组

- 隐式分组：在需要分组的字段上，指定某个组的值，不使用GROUP BY；
- 显示分组：使用GROUP BY；

###### 对独立的值计数

- 139











##### 03：产生分组

- 

##### 04：分组过滤条件

- 









##### 06：GROUP BY：分组

- ```sql
  select stu.name, avg(s.math) as math, avg(s.chinese) as chinese
  from score s INNER JOIN student stu
  ON stu.id = s.student_id
  group by stu.name;
  ```

  - score 表中可能会有多条一个学生的成绩，求平均
    - 先找到联表中符合限定条件的信息；
    - 以group by 后的字段作为分组key；
    - 进行聚合计算，最终显示也是key，字段名；

- **多列分组**：按照多列（字段A+字段B）合并后的值进行分组；

- **HAVING 条件表达式**：用来限制分组后的显示，符合条件表达式的结果将被显示；

  - HAVING   COUNT(sex) >= 1;

- **WITH ROLLUP**：将会加上一条记录，这一条记录是上面所有记录的总和。

