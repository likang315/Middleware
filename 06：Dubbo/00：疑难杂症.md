### 疑难杂症

------

[TOC]

##### 01：那为什么要有 RPC，HTTP 不好么 ？

- 因为 RPC 和 HTTP 就**不是一个层级**的东西，所以严格意义上这两个**没有可比性**，HTTP 只是传输协议，RPC 对比的是**本地过程调用**，是**用于分布式系统之间的通信**，它可以用 HTTP 来传输，也可以基于 TCP 自定义协议（Dubbo，Hession）传输。

##### 02：服务暴露流程 ？

1. 服务的暴露起始于 Spring IOC 容器初始化完毕之后，会根据配置参数组装成 URL， 然后根据 URL 的参数来进行本地或者远程调用；
2. 会通过 `proxyFactory.getInvoker`，**利用 javassist 来进行动态代理**，封装真的实现类，然后再通过 **URL 参数**选择对应的协议来来进行 **protocol.export**；
3. 在第一次暴露的时候会调用 createServer 来创建 Server，默认是 NettyServer。
4. 然后将 export 得到的 **exporter 存入一个 Map 中**，供之后的远程调用查找，然后会**向注册中心注册提供者的信息**。

##### 03：服务引入流程 ？

- 服务的引入的方式有两种，第一种是饿汉式，第二种是懒汉式。
  1. 饿汉式就是spring加载完毕就会引入，懒汉式是只有当这个服务被注入到其他类中时启动引入流程，默认是懒汉式；
  2. 先根据配置参数**组装 URL** ，一般而言我们都会配置的注册中心，所以会构建 Directory 向注册中心注册消费者的信息，并且订阅提供者、配置、路由等节点。
  3. 得知提供者的信息，会创建 Invoker ，期间会包含 NettyClient，来进行远程通信，最后**通过 Cluster 来包装 Invoker**，集群容错默认是 FailoverCluster，最终返回代理类；

##### 04：服务调用的流程 ？

1. 调用某个接口的方法会调用之前生成的**代理类**，然后会从 **cluster 中经过路由的过滤、负载均衡机制选择一个 invoker 发起远程调用**，此时会记录此请求和请求的 ID 等待服务端的响应。
2. 服务端接受请求之后会通过参数**找到之前暴露存储的 map，得到相应的 exporter** ，然后最终调用真正的实现类，再组装好结果返回，这个**响应会带上之前请求的 ID**；
3. 消费者收到这个响应之后会**通过 ID 去找之前记录的请求**，然后找到请求之后**将响应塞到对应的 Future 中，唤醒等待的线程**，最后消费者得到响应；

##### 05：什么是SPI ？【服务发现】

- SPI 是 Service Provider Interface，主要用于框架中，**框架定义好接口**，不同的使用者有不同的需求，因此需要有不同的实现，而 **SPI 就通过定义一个特定的位置**，Java SPI 约定在 Classpath 下的 META-INF/services/ 目录里创建一个**以服务接口命名的文件**，然后**文件里面记录的是此 jar 包提供的具体实现类的全限定名**。

##### 06：为什么 Dubbo 不用 JDK 的 SPI，而是要自己实现 ?

- 因为 Java SPI 在查找扩展实现类的时候**遍历 SPI 的配置文件并且将实现类全部实例化**，假设一个实现类初始化过程比较消耗资源且耗时，但是你的代码里面又用不上它，这就产生了**资源的浪费**。所以 Dubbo 就自己实现了一个 SPI，**给每个实现类配了个名字**，通过名字去文件里面找到**对应的实现类全限定名然后加载实例化**，按需加载。

##### 07：Dubbo 为什么默认用 Javassist ？

1. JDK动态代理仅支持 interface 代理的桎梏，因为动态生成的代理类的继承自 Proxy，Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理；
2. Javassist 非常快，并且生成字节码方便；

##### 08：如果让你设计一个 RPC 框架，如何设计 ？

1. 首先需要**实现高性能的网络传输**，可以采**用 Netty 来实现**，不用自己重复造轮子；
2. **自定义传输协议**，毕竟远程交互都需要遵循一定的协议，然后还需要**定义好序列化协议**，网络的传输毕竟都是二进制流传输的。
3. **可以搞一套描述服务的语言**，即 IDL（Interface description language），让所有的服务都用 IDL 定义，再由框架转换为特定编程语言的接口，这样就能**跨语言**。
4. **实现代理：**工业级的话首先得易用，所以框架需要把上述的细节**对使用者进行屏蔽**，让他们感觉不到本地调用和远程调用的区别；
5. **实现集群功能：** 服务发现、注册等功能；
6. **监控机制：**最后还需要一个完善的监控机制，**埋点上报调用情况**等等，便于性能调优；

##### 09：谈谈Dubbo底层的通信原理 ？

- Dubbo底层通信，默认采用**高性能的Netty通信框架**，实现网络通信，Netty是一个高性能的**NIO通信框架，利用多路复用技术**，并且在Netty在此基础之后，又增加了**主从线程池来**进行优化，结合这两方面进行讲解即可。

##### 10：



