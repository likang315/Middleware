### Java 并发机制的底层实现

------

[TOC]

##### 01：volatile 的内存语义

- 更轻量级的变量同步机制，它不会引起线程上下文的切换，但是 volatile 变量的同步性较差，而且其使用也更容易出错；

- ```java
  private transient volatile Node tail;
  ```

1. **保证可见性，不保证原子性**；
   - volatile 变量更新时，JVM会把该**线程本地内存中缓存的变量强制刷新到主内存中去**，这个写操作会导致其他线程中缓存的此变量无效。
   - 不能保证 **i++** 是原子性的，本质上还是Java中对基本数据类型的变量的读取和赋值操作是原子性操作，而i++不是。
2. **禁止指令重排序**
   - 用 volatile 修饰的共享变量，在编译时，会在指令序列中插入**内存屏障（lock）**来禁止指令重排序;
   - 读多写少的场景下，或者做状态标志，主要是写操作的时候改变；
   - 一定程度上保证的有序性；

##### 02：内存屏障

- 被volatile关键字修饰时，编译时会多出一个 **lock 汇编指令**，lock 汇编指令实际上就是内存屏障，能降到低风险；


1. 它确保指令重排序时**不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面**
2. 它会**强制的将对缓存的修改操作立即写入主存**，导致其他CPU中对应的缓存变量无效，执行写操作时，需要重新执行写操作；

##### 03：volatile 的使用优化

​	JUC中新增一个队列集合类LinkedTransferQueue<E>，它在使用volatile变量时，用一种追加字节的方式（将共享变量追加到64字节）来优化队列出队和入队的性能；

- 如果队列的头节点和尾节点都**不足64字节**的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在**缓存一致性机制**的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。
- LinkedTransferQueue 使用**追加到64字节的方式来填满高速缓冲区的缓存行**，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定，主要取决于处理器的缓存行的大小。

##### 04：volatile 的优势

​	由于volatile仅仅保证对**单个volatile变量的读/写具有原子性**，而锁的互斥执行的特性可以确保**对整个临界区代码的执行具有原子性**。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势；

##### 05：示例

```java
// 状态标记量
private volatile boolean flag = false;
while (!flag) {
    doSomething();
}

public void setFlag() {
    flag = true;
}
```

##### 06：指令重排序

​	指编译器和处理器为了**优化程序性能而对指令序列进行重新排序**的一种手段;

###### 3种重排序

1. 编译器优化的重排序
   - 编译器在不改变**单线程程序语义**的前提下，可以重新安排语句的执行顺序;
2. 指令级并行的重排序
   - 指令级并行技术：将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
   - 数据依赖性：
     - 写后读
     - 写后写
     - 读后写
   - 编译器和处理器不会改变**存在数据依赖关系**的两个操作的执行顺序;
   - **数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑**
3. 内存系统的重排序
   - 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作，看上去可能是在乱序执行；

###### 重排序可能导致多线程程序之间出现可见性问题

1. 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排;
2. 对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障来禁止特定类型的处理器重排序;

##### 07：Happens Before 规则

​	若两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行，happens-before仅仅要求前一个操作的执行结果，对后一个操作可见，且前一个操作按顺序排在第二个操作之前；

- 程序顺序规则：**一个线程中的每个操作**，happens-before于该线程中的任意后续操作；
- 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁；
- volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读；
- 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C；

##### 08：as-if-serial（仿佛串行）

- 不管怎么重排序，（单线程）程序的执行结果不能被改变；
- 两数相乘；

##### 09：重排序对多线程的影响

- 在单线程程序中，对**存在控制依赖的操作重排序**，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因），但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果；

