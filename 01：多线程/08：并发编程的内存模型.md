### 并发编程的内存模型

------

[TOC]

##### 01：概述

- 多线程并发访问同一资源时，就会形成“抢”的现象，由于线程切换实际不确定，可能导致执行代码顺序的混乱，严重时会导致系统瘫痪，例：上厕所、上锁
- 线程安全的核心：**对共享且可变状态的资源访问进行管理**，例：加锁、final、volitile

##### 02：线程同步和异步

- 同步执行：多个线程排队有序执行
- 异步执行：多个线程可以同时进行

##### 03：并发编程的三个特性

1. **原子性：**在一个原子操作中，cpu 不可以在中途暂停然后再调度，即**不可被中断的操作**；
2. **有序性：在本线程内观察，所有操作都是有序的**；
3. **可见性：**指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即得到修改的值；
   - 当一个变量被 volatile 修饰后，当**一个线程在私有内存中修改此共享变量后**，共享变量会立即被更新到主内存中，同时使其他线程缓存的此变量无效，其他线程读取共享变量时，会直接从主内存中读取；
   - synchronized和Lock都可以保证可见性
     - 锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性；

##### 04：顺序一致性

​	一个线程在写一个变量，另一个线程在读同一个变量，而且写和读没有**通过同步来排序**，当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果；如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。

- JMM对**正确同步的多线程程序**的内存一致性做了保证，如果程序是正确同步的，**程序的执行将具有顺序一致性；**

##### 05：顺序一致性内存模型

​	顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个**线程必须按照程序的顺序来执行内存读/写操作**。在任意时间点**最多只能有一个线程可以连接到内存**。当多个线程并发执行时，图中的开关装置能把**所有线程的所有内存读/写操作串行化**（即在顺序一致性模型中，所有操作之间具有全序关系）

- 因为顺序一致性内存模型中的每个操作必须立即对任意线程可见，而JMM模型就没有这个保证；（主内存和工作内存）

![](https://github.com/likang315/Middleware/blob/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png?raw=true)

##### 06：顺序一致性模型保证所有对内存的读/写操作都具有原子性

- 总线事务包括读事务（Read Transaction）和写事务（WriteTransaction）
  - 读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读/写内存中一个或多个物理上连续的字。这里的关键是，**总线会同步（总线仲裁）试图并发使用总线的事务**。在一个处理器执行总线事务期间，总线会禁止其他的处理器和I/O设备执行内存的读/写；

##### 07：锁的内存语义

​	锁是并发编程中最重要的同步机制。锁除了让**临界区互斥执行**外，还可以让释放锁的线程向获取同一个锁的线程发送消息；

- 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中；
- 当线程获取锁时，JMM会把该线程对应的本地内存置为无效，重写读取；
- 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息（共享内存）；

###### 锁释放-获取的内存语义的实现

1. 利用volatile变量的写-读所具有的内存语义
2. 利用CAS所附带的volatile读和volatile写的内存语义

##### 08：final域的内存语义

​	final域与锁和volatile相比，对final域的读和写更像是普通的变量访问，通过**内存屏障**来实现；

###### 对于final域，编译器和处理器遵守两个重排序规则

1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序；
2. 初次读一个包含final域的对象的引用，与随后再次读这个final域，这两个操作之间不能重排序；

###### final修饰引用数据类型

- 在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序



