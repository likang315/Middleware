### Synchronized 原理与应用

------

[TOC]

##### 01：synchronized

​	Java 中的关键字，是一种**同步锁，为重量级可重入锁**，即当前线程可以获取**特定对象**的监视器锁。

###### 作为锁的对象

- 对于静态同步方法，锁是当前**类的Class对象**；
- 对于同步方法，锁是**方法的调用对象**；
- 对于同步方法块，锁是 Synchonized **括号里的对象**；

###### 锁原理

- synchronized：是通过**字节码指令**来实现的
  - synchronized 同步块：编译后会在**同步块前后形成 monitorenter 和 monitorexit 两个字节码指令**；
    - 执行 monitorenter 指令时，会尝试获取特定对象的监视器锁（每个对象有一个监视器锁monitor），如果当前线程获得此锁（可重入锁），那么锁的计数器+1。如果获取失败，那么当前线程阻塞，直到锁被另一个线程释放；
    - 执行 monitorexit 指令时，计数器 -1，当为 0 的时候锁释放；
    - 任意一个对象都拥有自己的监视器（对象锁），当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而**没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态**；
  - synchronize 同步方法：编译后会在方法访问处，添加字节码指令 **ACC_SYNCHRONIZED**  标志
    - 不管是 monitorenter，还是ACC_SYNCHRONIZED 本质都是对一个对象的监视器（monitor）进行获取；

###### synchronized：同步块

​	要求多个线程对该块内的代码有序执行，前提条件是同步监视器对象，可以有效的**缩小同步范围**，并保证并发安全的同时尽可能的提高效率；

- 当一个线程访问对象中的 synchronized(this) 同步代码块时，另一个线程仍然可以访问该对象中的非 synchronized(this) 同步代码块，因为非 synchronized 不需要 monitor 锁；
- 当获取不同锁对象的线程执行同步块时，不会阻塞线程，因为是不同的 monitor 锁；

```java
// this锁：指 monitor对象
synchronized (this) {
	// todo
}

// 有一个明确的对象作为锁时
public void  method3(SomeObject obj) {
   // 非this锁：关注obj是否为同一个对象
   synchronized (obj) {
      // todo
   }
}

// 当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的对象来充当锁
Byte[] lock = new Byte[0];
synchronized (lock) {
  // todo
}
```

###### synchronized：同步方法

​	即：获取同一个锁对象的多个线程不能同时进入方法内部执行。

- synchronized 同步方法：在一个线程调用该方法时，**该方法会从调用对象中获取锁**，其他携带同一个对象的线程将会被阻塞，直到持有同步锁的线程将方法执行完毕，释放锁，此线程获取同步锁；
- **同一个锁对象可以产生互斥作用，不同锁对象不能产生互斥作用**；
- 若修饰静态方法：属于类的，与对象无关

```java
public synchronized void method() {
  // ...
}
public static synchronized void method() {
	// ...
}
```

###### 注意：

1. 被 synchronized 修饰方法，不能被继承，若需要同步，在子类重写该方法时需添加 synchronized 关键字；
2. 在接口中定义方法时不能使用 synchronized 关键字；
3. 构造方法不能使用 synchronized 关键字，但可以使用 synchronized 代码块来进行同步；

###### synchronized：类锁（Class锁）

- synchronized 作用于一个类时，每个类有且只有一个 Class 对象，即类的 Class 对象锁，类的所有对象获取的都是同一把锁，相当于静态方法块。

```java
synchronized (ClassName.class) {
	// todo
}
```

##### 02：Java 对象构成

1. 对象头；
2. 实例数据；
   - 对象的实际数据，即字段的值；

3. 对齐填充字节；
   - 由于 JVM 要求对象起始地址必须是 8 字节的整数倍，因此可能需要几个填充来满足对齐要求。因为许多计算机体系结构**对于非对齐的内存访问会更慢**。

##### 03：Java 对象头

- Hotspot 虚拟机的对象头主要包括两部分数据
  - Mark Word （标记字）+  Class Metadata Address（类型指针）+ Array Length （数组长度）
- **Mark Word**：存储锁的信息，hashCode() 值，对象分代年龄；
- **Class Metadata Address**：存储到对象类型数据的指针，用于确定是哪个类的实例；
-  Array Length：如果当前对象是数组，则存储的是数据的长度；

##### 04：Mark Word 标记字

- 一个非固定的数据结构，它会根据对象的状态复用自己的存储空间；
- 大小：8 个字节，64 bit；

![](https://github.com/likang315/Middleware/blob/master/01：多线程/photos/Mark-Word.png?raw=true)

##### 05：Monitor：监视器锁

- 内置锁：一种同步机制，在 Martk-World 中，偏向锁、轻量级锁和重量级锁都**属于 monitor 锁的不同实现方式**；

###### 线程 & Monitor 关联

​	每一个 Java  线程都有一个用于存储锁信息的数据结构，包含一个可用 monitor record （Lock Record）列表。

- **被锁住的对象：**是指在多线程环境下，通过 synchronized 关键字或 Lock 对象进行加锁的 Java 对象。
- 每一个被锁住的对象都会和一个 monitor 关联（Mark Word 指向锁记录（Lock Record）所在的 monitor 的起始地址），同时 **monitor 数据结构中有一个 Owner 字段用于存放拥有该锁的线程的唯一标识**，表示哪个线程持有这个锁。

##### 06：锁的状态

​	阻塞或唤醒一个线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。**如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长；**

- **锁只能升级但不能降级**，即偏向锁升级成轻量级锁后不能降级成偏向锁。这种策略目的是为了**提高获取锁和释放锁的效率；**
  - 无锁状态
  - 偏向锁状态
  - 轻量级锁状态
  - 重量级锁状态（自旋锁状态）

##### 07：重量级锁

​	在 JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括**系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换**等。因此，后来称这种锁为“重量级锁”。

- 线程的阻塞和唤醒会导致 CPU 从用户态转为内核态，因此**频繁的阻塞和唤醒线程对CPU来说是一件负担很重的工作**，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的，所以引入自旋锁。


##### 08：自旋锁

- 让该线程自旋一段时间，不会被立即挂起（释放CPU时间片），看持有锁的线程是否会很快释放锁 。会循环检查锁状态；
- 执行一段无意义的循环（自旋），自旋等待的时间（自旋的次数）必须要有一个限度**，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起**；
- JDK1.6中默认开启，同时自旋的**默认次数为10次**，可以通过参数-XX:PreBlockSpin来调整；
- JDK1.6以后引入自适应的自旋锁，让虚拟机会变得越来越聪明；
- 自旋锁的实现原理：CAS 原子操作
  - AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，**如果修改数值失败则通过循环来执行自旋，直至修改成功**； 

```java
public final int getAndSetInt(Object var1, long var2, int var4) {
    int var5;
    do {
      var5 = this.getIntVolatile(var1, var2);
    } while (!this.compareAndSwapInt(var1, var2, var5, var4));

    return var5;
}
```

##### 09：自适应自旋锁

​	自适应意味着自旋的次数不再是固定的，它是由**上一次在同一个锁上的自旋时间及获取所得成功与否**来决定。

- 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少**甚至省略掉自旋过程**，以免浪费处理器资源；
- 缺点：由于**锁竞争时间**不确定，自适应自旋也没能彻底解决该问题，如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值；

##### 10：轻量级锁

​	如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗。

- 轻量级锁：线程在执行同步块之前，JVM会先在**当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word，线程尝试使用CAS将对象头中的Mark Word更新为指向锁记录的指针**，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），膨胀为自适应自旋锁；

###### 轻量级释放锁

​	释放锁时，会**使用CAS操作将Displaced Mark Word替换回到对象头**，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁；

###### 性能消耗

​	如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。

###### 两个线程同时争夺锁，导致锁膨胀的流程

<img src="https://github.com/likang315/Middleware/blob/master/01：多线程/photos/轻量级锁.png?raw=true" style="zoom:45%;" />

##### 11：偏向锁

​	偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。**轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS**。

- 偏向锁：当一个线程访问同步块并获取锁时，会在**对象头和栈帧中的锁记录里存储锁偏向的线程ID**，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）；如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程
- 如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁，维护偏向锁的过程就成了浪费时间的过程

###### 偏向锁的释放

​	偏向锁的释放采用了一种**只有竞争才会释放锁**的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争，偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）

- 其步骤如下：
  1. 暂停拥有偏向锁的线程，检查偏向锁的线程是否还活着
  2. **撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态**
  3. 最后唤醒暂停的线程

###### 偏向锁的关闭

- 如果确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁；
- -XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态；

##### 12：锁的适用并发场景

- 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁；
- 轻量级锁：无实际竞争，多个线程交替依次使用锁，允许短时间的锁竞争；
- 自旋锁：有实际竞争，锁竞争时间较短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能；
- 重量级锁：有实际竞争，且锁竞争时间较长；

##### 13：锁消除、锁粗化

###### 锁消除

- 有些情况下，JVM检测到不可能存在共享数据竞争，不会使用到锁，这是JVM会对这些同步锁进行锁消除，锁消除的依据是**逃逸分析**的数据支持。

###### 锁粗化

- 就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的加锁；
- 使用同步锁的时候，需要让同步块的作用范围尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁，如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念；



