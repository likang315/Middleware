### Redis 高级特性

------

##### 1：过期策略：所有的数据结构都可以设置过期时间, 时间⼀到就会⽴即删除

​	Redis 会将每个设置了**过期时间的 key 放⼊⼀个独⽴的字典**中, 以后会定时遍历这个字典来删除到期的 key，处理定时遍历之外, 还会使⽤**惰性删除的策略**: 在访问该 key 时再对过期时间进⾏检查, 如果过期就删除并返回空

- Redis 默认会 ：**每秒进⾏⼗次过期扫描**，过期扫描不会遍历过期字典中的所有 key，采⽤简单的**贪⼼策略**:
  1. 从过期字典中随机选取 20个 key
  2. 删除这 20个 key 中已经过期的
  3. 如果过期 key 的比例超过 1/4，那么就重复步骤1
  4. 从库不会进⾏过期扫描，主库在 key 到期的时候，会在 AOF ⽂件中增加⼀条 del 指令，同步到所有从库

##### 2：内存淘汰

- 当 Redis **内存超出物理内存的时候**，内存的数据会开始和磁盘缠身频繁的交换, 会让 Redis 的性能急剧下降
- 在⽣产环境中需要指定 **maxmemory 来限制内存超出期望⼤⼩**

###### 数据淘汰策略：让⽤户决定内存淘汰⽅式

1. noeviction：不支持写请求，只支持读请求，可以保证不会丢失数据，但线上的业务不会持续进⾏
   - 默认的淘汰策略
2. volatile-lru：淘汰设置了过期时间的 key，最少使⽤的 key 优先被淘汰，没有设置过期时间的 key 不会被淘汰
3. volatile-ttl：是 key 的剩余寿命的 ttl 值，值越⼩越优先被淘汰【一般设置它】
4. volatile-random：随机淘汰设置过期时间的 key
5. allkeys-lru：对全体 key 使⽤ LRU 淘汰
6. allkeys-random: 对全部的 key 进⾏随机淘汰

- volatile-xxx ：策略只会针对带过期的时间的 key 进⾏淘汰
- allkeys-xxx ：策略会对所有的 key 进⾏淘汰
- 如果只是拿 Redis 做缓存，那应该使⽤ allkeys-xxx，写缓存时不必携带过期时间
- 如果还想同时使⽤ Redis 的持久化功能，那就使⽤ volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰

##### 3：持久化机制（两种）

###### 1：快照： 

- 快照是内存数据的⼆进制序列化形式  RDB文件（保存数据库的状态），默认的持久化方式
- SAVE、BGSAVE 生成 rdb 文件，区别在在于：
  - SAVE：会阻塞服务器进程，直到 rdb 文件创建完毕为止，在服务器进程阻塞期间，服务器是不可以处理任何任务命令请求的
  - BGSAVE：会 fork 一个子进程，创建 rdb 文件
  - Redis 在持久化的时候，会 fork 出⼀个⼦进程，快照持久化完全交由⼦进程来处理，⽗进程继续处理客户端请求，⼦进程刚刚产⽣的时候, 和⽗进程共享代码段和数据段, 在进程分离的⼀瞬间, 内存⼏乎不会增加
- 自动间隔性保存：一般使用 BGSAVE，因为他不会阻塞服务器进程，可以设置间隔时间来执行 BGSAVE 命令
- rdb文件的载入：在服务器启动时自动载入的，没有用于载入的命令，只需要将rdb文件放入redis安装目录即可，期间阻塞主进程

###### 优点：

1. 只有一个文件 dump.rdb 方便持久化
2. 容灾性好，一个文件可以保存到安全磁盘
3. 性能最化，fork子进程来完成写操作，让主进程继续处理命令
4. RDB每一条数据只有一条记录，不会向AOF一条数据可能有多条记录，所以每条数据只需要写一次就够了，因此文件载入快
5. 数据安全性较低，中途宕机，备份数据可能毁坏

###### 2：AOF ⽇志：连续的增量备份 append only file

- AOF ⽇志记录的是**一条条修改内存数据的指令**
- AOF ⽇志在⻓期的运⾏过程中会变的⽆⽐庞⼤, 数据库重启时需要加载 AOF ⽇志进⾏指令重放, 这个时间就会⽆⽐漫⻓. 所以需要**定期进⾏ AOF 重写,** 给 AOF ⽇志进⾏瘦身

###### AOF 重写

​	通过新建AOF文件，来代替旧文件，并且两个文件所保存的数据库状态的一样的，但是新文件不会包含任任何冗余的命令，所以新文件要小的多

- 重写功能：通过读当前服务器的数据库状态来实现的
- Redis设置了一个AOF重写缓冲区，来记录fork过程中服务器还在处理命令，导致的数据库改变

###### 优点：

​	数据安全，通过append模式写文件，即使中途服务器宕机可以通过redis-check-aof工具解决数据一致性问题

###### 缺点：

1. 文件比rdb形式文件大
2. 数据集大比rdb启动效率低

##### 4：CAP：最多只能同时满足两项

- C — consistent: ⼀致性（牺牲）
- A — Availability: 可⽤性
- P — Partition tolerance: 分区容错性

###### 网络分区：

- 分布式系统的节点往往都是分布在不同的机器上进⾏⽹络隔离开的, 这意味着必然会有⽹络断开的⻛险

在⽹络分区发⽣时，两个分布式节点之间⽆法进⾏通信，我们对⼀个节点进⾏的修改操作将⽆法同步到另外⼀个节点，所以数据的「⼀致性」将⽆法满⾜，因为两个分布式节点的数据不再保持⼀致。除⾮我们牺牲「可⽤性」，也就是**暂停分布式节点服务**，在⽹络分区发⽣时，所有节点不再提供修改数据的功能，直到⽹络状况完全恢复正常再继续对外提供服务

- 约定修改（二次确认）

##### 5：主从复制：为了减少数据库读写的压力，使用指令流，异步进行同步

- 满足可用性，但是不满足一致性，但是最终保证一致性

![](https://github.com/likang315/Java-and-Middleware/blob/master/Redis/Redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png?raw=true)

##### 6：Redis 是⼀个单线程应⽤，但是采⽤ ⾮阻塞IO模型，实现多路复⽤，不会有线程间切换等问题

- Redis本身是单线程，线程安全的内存数据库，但是不代表你的使用就是线程安全的，还是要加锁

###### 阻塞IO

当使⽤ **socket** 的读写⽅法时, 默认是阻塞的, ⽐如 read ⽅法传⼊参数 n, 代表最多读取 n 个字节后再返回, 如果⼀个字节都没有，那么线程就会阻塞, 直到新的数据到来或者连接关闭才返回. ⽽ write ⼀般不会阻塞, 除⾮内核为 socket 分配的写缓冲区已经满了. socket 线程就会阻塞直到缓冲区有空闲空间.

###### 非阻塞IO

⾮阻塞 **IO 在套接字上提供了⼀个选项 Non_blocking,** 当这个选项打开的时候, 读写⽅法不会阻塞, **能读多少读多少, 能写多少写多少.** 能读多少取决于内核为 socket 分配的读缓冲区内数据, 能写多少取决于写缓冲区的空闲空闲字节数. **读写⽅法都会通过返回值来告知调⽤⽅实际读写了多少字节**.⾮阻塞 IO 意味着线程在读写 IO 的时候不必再阻塞, 读写可以瞬间完成然后线程继续其他

###### ⾮阻塞 IO 问题

- 线程要读数据, 结果读了⼀部分就返回, 如果知道何时才应该继续读, 也就是当数据来了, 线程如何得到通知, 以及如果⼀次写不完, 剩下的数据应该何时才能继续写, 线程也应该得到通知

最简单的**事件轮询 API 就是 select 函数**, 它是操作系统提供给⽤户程序的 API, 输⼊是读写描述符 read_fds & write_fds, 输出的是与之对应的可读可写事件, 同时还提供了**⼀个 timeout 参数**, 如果没有任何事件到来, 那么线程最多阻塞 timeout 时间. ⼀旦期间没有任何读写事件到来, 就可以⽴即返回，拿到事件后, 线程就可以继续挨个处理响应的事件，处理完了继续过来轮询

##### 7：管道技术：在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应

- Redis 是一种基于客户端-服务端模型以及请求/响应协议的TCP服务


1. **客户端进程**调⽤ write 将消息写到**操作系统内核为 socket 分配的发送缓冲 send buffer**
2. 客户端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到服务端⽹卡
3. 服务端操作系统将⽹卡中的数据放到内核为 socket 分配的**接受缓冲 recv buffer**
4. 服务端进程**调⽤ read 将消息从接受缓冲取出并进⾏处理**
5. **服务端进程**调⽤ write 将执⾏结果写到内核为 socket 分配的发送缓冲 send buffer
6. 服务端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到客户端⽹卡
7. 客户端操作系统将⽹卡中的数据放到内核为 socket 分配的**接收缓冲 recv buffer**
8. 客户端进程调⽤ read 将消息从接收缓冲取出并返回给上层业务逻辑进⾏处理

###### 管道优势

- write 操作只需要**将数据写到本机操作系统内核的 send buffer 就返回,** 剩下的操作交由操作系统内核
  异步将数据发送到⽬标服务器;
- read 操作**只需要将数据从本机操作系统内核的 recv buffer 读取出来即可,** 但如果缓冲是空的, 就需要
  等待数据的到来, 这是 read 操作真正耗时的地⽅;
- 对于管道来说, 连续的 read 操作⼏乎不会耗时, 只有第⼀个 read 操作会等待⼀个⽹络的来回开销, 然
  后所有的响应消息就都已经回送到内核的接受缓冲了, 后续的 read 操作直接就可以从缓冲拿到结果, 瞬
  间就返回了