### 过期策略：所有的数据结构都可以设置过期时间, 时间⼀到就会⽴即删除.

Redis 会将每个设置了**过期时间的 key 放⼊⼀个独⽴的字典**中, 以后会定时遍历这个字典来删除到期的 key, 处理定时遍历之外, 还会使⽤**惰性删除的策略**: 在访问该 key 时再对过期时间进⾏检查, 如果过期就删除并返回空

Redis 默认会每秒进⾏⼗次过期扫描, 过期扫描不会遍历过期字典中的所有 key, ⽽是采⽤了⼀种简单的贪⼼策略:

1. 从过期字典中随机20个 key;
2. 删除这20个 key 中已经过期的;
3. 如果过期 key 的⽐利超过 1/4, 那么就重复步骤1.
4. 从库不会进⾏过期扫描, 主库在 key 到期的时候, 会在 AOF ⽂件中增加⼀条 del 指令, 同步到所有从库

### 内存淘汰：当 Redis 内存超出物理内存的时候, 内存的数据会开始和磁盘缠身频繁的交换, 会让 Redis 的性
### 能急剧下降

在⽣产环境中需要指定 **maxmemory 来限制内存超出期望⼤⼩**, 

Redis 提供了⼏种可选的策略来让⽤户决定内存淘汰⽅式
• **noeviction:** 不会继续服务写请求, 只服务读请求, 可以保证不会丢失数据, 但线上的业务不会持
续进⾏, 是默认的淘汰策略;
• **volatile-lru:** 尝试淘汰设置了过期时间的 key, 最少使⽤的 key 优先被淘汰, 没有设置过期时间的
key 不会被淘汰
• **volatile-ttl:** 淘汰的策略不会 LRU, ⽽是 key 的剩余寿命的 ttl 值, 越⼩越优先被淘汰.
• **volatile-random:** 随机淘汰设置过期时间的 key.
• **allkeys-lru:** 对全体 key 使⽤ LRU 淘汰.
**• allkeys-random:** 对全部的 key 进⾏随机淘汰.

###### volatile-xxx 策略只会针对带**过期的**时间的 key 进⾏淘汰，

###### allkeys-xxx 策略会对所有的 key 进⾏淘汰

如果你只是拿 Redis 做缓存，那应该使⽤ allkeys-xxx，客户端写缓存时不必携带过期时间

如果你还想同时使⽤ Redis 的持久化功能，那就使⽤ volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘

### Redis 是⼀个单线程应⽤, 但是采⽤⾮阻塞 IO模型, 实现多路复⽤

##### IO/NIO（非阻塞IO）

当使⽤ socket 的读写⽅法时, 默认是阻塞的, ⽐如 read ⽅法传⼊参数 n, 代表最多读取 n 个字节后再返回, 如果⼀个字节都没有, 那么线程就会阻塞, 直到新的数据到来或者连接关闭才返回. ⽽ write ⼀般不会阻塞, 除⾮内核为 socket 分配的写缓冲区已经满了. socket 线程就会阻塞直到缓冲区有空闲空间.
⾮阻塞 IO 在套接字上提供了⼀个选项 Non_blocking, 当这个选项打开的时候, 读写⽅法不会阻塞, **能读多少读多少, 能写多少写多少.** 能读多少取决于内核为 socket 分配的读缓冲区内数据, 能写多少取决于写缓冲区的空闲空闲字节数. **读写⽅法都会通过返回值来告知调⽤⽅实际读写了多少字节**.⾮阻塞 IO 意味着线程在读写 IO 的时候不必再阻塞, 读写可以瞬间完成然后线程继续其他

⾮阻塞 IO 有⼀个问题, 那就是线程要读数据, 结果读了⼀部分就返回, 如果知道何时才应该继续读, 也就是当数据来了, 线程如何得到通知, 以及如果⼀次写不完, 剩下的数据应该何时才能继续写, 线程也应该得到通知

最简单的**事件轮询 API 就是 select 函数**, 它是操作系统提供给⽤户程序的 API, 输⼊是读写描述符 read_fds & write_fds, 输出的是与之对应的可读可写事件, 同时还提供了⼀个 timeout 参数, 如果没有任何事件到来, 那么线程最多阻塞 timeout 时间. ⼀旦期间有任何事件到来, 就可以⽴即返回.拿到事件后, 线程就可以继续挨个处理响应的事件, 处理完了继续过来轮询.

serversocket 对象的读操作是调⽤ accept 接收新的客户端连接, 何时有新连接到来, 也是通过select 系统调⽤的读事件来得到通知的

### 持久化

Redis 的数据全部在内存⾥, 如果突然宕机, 数据就会全部丢失, 因此必须有⼀种机制来保证 Redis 的数据不会因为故障⽽丢失, 这种机制就是 Redis 的持久化机制.

##### Redis 的持久化机制有两种

###### 1：快照,

###### 2：AOF ⽇志. 快照是⼀次全量备份

AOF ⽇志是连续的增量备份. 快照是内存数据的⼆进制序列化形式, 在存储上⾮常紧凑, ⽽AOF ⽇志记录的是内存数据修改的指令记录⽂本. AOF ⽇志在⻓期的运⾏过程中会变的⽆⽐庞⼤, 数据库重启时需要加载 AOF ⽇志进⾏指令重放, 这个时间就会⽆⽐漫⻓. 所以需要定期进⾏ AOF 重写, 给 AOF ⽇志进⾏瘦身.
Redis 在持久化的时候, 会 fork 出⼀个⼦进程, 快照持久化完全交由⼦进程来处理, ⽗进程继续处理客户端请求. ⼦进程刚刚产⽣的时候, 和⽗进程共享代码段和数据段, 在进程分离的⼀瞬间, 内存⼏乎不会增

### 管道技术：在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应

Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务

1. 客户端进程调⽤ write 将消息写到操作系统内核为 socket 分配的发送缓冲 send buffer

2. 客户端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到服务端⽹卡

3. 服务端操作系统将⽹卡中的数据放到内核为 socket 分配的接受缓冲 recv buffer

4. 服务端进程调⽤ read 将消息从接受缓冲取出并进⾏处理

5. 服务端进程调⽤ write 将执⾏结果写到内核为 socket 分配的发送缓冲 send buffer

6. 服务端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到客户端⽹卡

7. 客户端操作系统将⽹卡中的数据放到内核为 socket 分配的接收缓冲 recv buffer

8. ###### 客户端进程调⽤ read 将消息从接收缓冲取出并返回给上层业务逻辑进⾏处理

  **管道优势**

  write 操作只需要将数据写到本机操作系统内核的 send buffer 就返回, 剩下的操作交由操作系统内核
  异步将数据发送到⽬标服务器;
  read 操作只需要将数据从本机操作系统内核的 recv buffer 读取出来即可, 但如果缓冲是空的, 就需要
  等待数据的到来, 这是 read 操作真正耗时的地⽅;
  对于管道来说, 连续的 read 操作⼏乎不会耗时, 之后第⼀个 read 操作会等待⼀个⽹络的来回开销, 然
  后所有的响应消息就都已经回送到内核的读缓冲了, 后续的 read 操作直接就可以从缓冲拿到结果, 瞬
  间就返回了

### CAP：最多只能同时满足两项

• C — consistent: ⼀致性
• A — Availability: 可⽤性
• P — Partition tolerance: 分区容错性     

#### 网络分区：分布式系统的节点往往都是分布在不同的机器上进⾏⽹络隔离开的, 这意味着必然会有⽹络断开的⻛险

在⽹络分区发⽣时，两个分布式节点之间⽆法进⾏通信，我们对⼀个节点进⾏的修改操作将⽆法同步到另外⼀个节点，所以数据的「⼀致性」将⽆法满⾜，因为两个分布式节点的数据不再保持⼀致。除⾮我们牺牲「可⽤性」，也就是**暂停分**
**布式节点服务，在⽹络分区发⽣时，不再提供修改数据的功能**，直到⽹络状况完全恢复正常再继续对外提供服务

#### 约定修改



### 主从复制：为了减少数据库读写的压力，有了主从数据库

![](G:\Java\Redis\主从复制.png)

###### 满足可用性，但是不满足一致性，但是最终保证一致性

###### 







