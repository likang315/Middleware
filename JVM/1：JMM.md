### JVM

​	虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统

------

##### 1：内存模型（JMM，Java Memory Model）

![](https://github.com/likang315/Java-and-Middleware/blob/master/JVM/JVM/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png?raw=true)

1. ###### 程序计数器：当前线程所执行字节码的行号指示器，值 +1，就去下一条的字节码指令去执行

   - 每个线程都有一个独立的程序计数器，线程私有
   - 保证多线程执行时，线程切换执行之后，可以恢复到正确的执行位置
   - 如果线程正在执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，
   - 如果正在执行的是Native方法，这个计数器值则为空（Undefined）
   - 唯一一个在Java虚拟机规范中没有OutOfMemoryError情况发生的区域

2. ###### Java 栈（stack）：方法执行的内存模型

   - JVM 会为每一个调用的方法在栈中分配一个存储空间，称为栈桢（栈中栈） 
   - 栈桢：用于存储**局部变量表（对象的引用）、操作数栈、动态链接、方法进出口**等信息
   - 每个方法的调用直至执行过程，对应一个栈帧，在Java栈中入栈，出栈操作
   - Java 栈可以动态扩展，使用连续的内存空间，线程私有区域
   - 数组引用变量是存放在栈内存中，数组元素是存放在堆内存中

3. ###### 本地方法栈：Native 方法执行的内存模型

   - 存储 jvm 使用到的 Native 方法（本地方法库），线程私有

4. ###### Java堆（heap）：运行时进行存储空间分配和回收的内存管理模型

   - 所有new的对象实例（包括成员变量的属性），都存储在堆中
   - Java 堆时 GC管理的主要区域，因此有时也称GC堆
   - 物理上可以不使用连续的内存地址，只要逻辑上连续即可
   - 线程公有，生命周期与 jvm 相同

5. ###### 方法区（静态域）：存储类的信息，通过类加载器载入类的字节码文件，经解析后装入方法区

   - 线程共享的区域，方法只有一份，通过 this 来区分那个对象调用
   - 运行时常量池(Constant Pool)：方法区的一部分，用于存放编译器生成的各种字面量和符号引用，翻译之后的直接引用也存储在此
   - Class 文件的常量池：在类加载装入方法区的运行时的常量池中存放
   - 运行时常量池和class文件的常量池相比，具有动态性，即运行时也可以放入新的常量
     - 例：String类的 intern（）方法
   - 静态成员变量存储在方法区

   - String str = new String("hello");   变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的常量池中

##### 2：内存分配

- 方法的形参：直接在栈空间分配，当方法调用完成后从栈空间回收
- 方法的局部变量：存储在Java栈帧中
- 方法的引用：在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完后从栈空间回收

##### 3：主内存与工作内存：JVM将内存组织为主内存和工作内存两个部分

1. 主内存：
   - 包括本地方法区和 Java 堆，线程共享区 
2. 工作内存：每个线程都有一个工作内存，线程隔离区，工作内存中主要包括两个部分
   1. 一个是属于该线程私有的栈(Java栈和Native方法	栈)
   2. 对程序计数器PC

- 所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的
- 每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，然后更新到主内存中，而不能直接读写主内存中的变量
- 线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成

#####  4：JVM 在 Jdk 1.8 中的划分

​	**元数据区取代了方法区**，元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：**元数据空间并不在虚拟机中，而是使用本地内存，常量池 和 静态成员变量**从永久代中剥离出来，存放在堆中

永久代(方法区)：指内存的永久保存区域，主要存放 Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域. 它和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理，所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出 OOM 异常

##### 5：对象的访问

​	由于 reference 类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的

###### 访问方式

1. 句柄池

   - Java 堆中有一块句柄池，reference存储句柄池地址，而句柄池中包含了对象实例数据与类型数据各自的具体地址

2. 直接指针

   - reference 存储的直接是对象的直接地址（对象的实例数据地址），还需要类型数据指针

   ![](https://github.com/likang315/Java-and-Middleware/blob/master/JVM/JVM/%E5%8F%A5%E6%9F%84%E6%B1%A0.png?raw=true)


##### 5：内存泄漏和内存溢出

- 内存泄漏：不再使用的对象没有被及时的回收，内存无法被回收，造成浪费
  - 当对象不在使用时应及时设置为null
-  内存溢出：内存空间已满，不够用，定义的数据没有足够的空间存储 **OOM为out of memory**

###### java.lang.OutOfMemoryError: Java heap space

​	java堆内存溢出，此种情况最常见，**一般由于内存泄露或者堆的大小设置不当引起**，而堆大小可以通过虚拟机参数

- -Xms：堆的最小值
- -Xmx：堆的最大值

###### java.lang.OutOfMemoryError: PermGen space

​	java 永久代溢出，即方法区溢出了，**一般出现于大量Class文件，或者采用cglib等反射机制的情况**，因为上述情况会产生大量的Class信息存储于方法区，可以通过更改方法区的大小来解决

- -XX:PermSize=64m -XX:MaxPermSize=256m 的形式来修改方法区的大小，过多的全局变量尤其是字符串也会导致方法区溢出

###### java.lang.StackOverflowError

​	JAVA虚拟机栈溢出，一般是由**于程序中存在死循环或者深度递归调用造成的**，栈大小设置太小也会出现此种溢出

- -Xss：设置栈的容量
- 解决方式：
  - 让深度递归遍历成非递归遍历
  - 死循环，设置阈值，超出之后，直接终止执行
  - 调整栈的大小
  - 使用static对象替代 non-static局部对象，还有逃逸分析

##### 6：逃逸分析(Escape Analysis)、栈上分配

- 逃逸分析：
  - 是一种可以**有效减少 Java 程序中同步负载和内存堆分配压力**的跨函数**全局数据流分析算法**，通过逃逸分析，Java Hotspot 编译器能够分析出一个**新的对象的引用的使用范围**，从而决定是否要将这个对象分配到堆上，较少GC的时间，提高效率
  - 基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸，需分配在堆中
- 栈上分配：
  - 就是把没发生逃逸的对象，分配栈空间中，若逃逸，则分配在堆上

##### 7：JVM 调优

​	一般调整垃圾回收器，和堆大小以及最大停顿时间

- -XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis = 200
  - -XX:+UseG1GC：为开启G1垃圾收集器
  - -Xmx32g：设计堆内存的最大内存为32G
  - -XX:MaxGCPauseMillis=200：设置GC的最大暂停时间为200ms
- 如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可







