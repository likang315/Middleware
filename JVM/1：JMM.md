虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统

### 1：内存模型（JMM(Java Memory Model)）

[![jvm内存模型.png](https://github.com/likang315/Java-and-Middleware/raw/master/4%EF%BC%9AJVM/JVM/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png?raw=true)](https://github.com/likang315/Java-and-Middleware/blob/master/4：JVM/JVM/jvm内存模型.png?raw=true)

###### 1：程序计数器：当前线程所执行字节码的行号指示器，值 +1，就去下一条的字节码指令去执行

1：每个线程都有一个独立的程序计数器，线程私有

###### 2：Java 栈（stack）：方法执行的内存模型

?	1：JVM会为每一个调用的方法在栈中分配一个存储空间，称为栈桢（栈中栈） ?	2：栈桢用于存储**局部变量表,操作数栈,动态链接,方法出口**等信息 ?	3：每个方法的调用直至执行过程，对应一个栈帧在java栈中入栈，出栈操作 ?	4：java栈可以动态扩展，使用连续的内存空间，线程私有区域

?	5：数组引用变量是存放在栈内存中，数组元素是存放在堆内存中

###### 3：本地方法栈：Native 方法执行的内存模型

1：存储jvm使用到的Native 方法（本地方法库），线程私有

###### 4：Java堆（heap）：运行时进行存储空间分配和回收的内存管理模型

1：所有new的对象实例（包括成员变量的属性），都存储在堆中 2：Java 堆时 GC管理的主要区域，因此有时也称GC堆 3：物理上可以不使用连续的内存地址，只要逻辑上连续即可 4：线程共享区域，生命周期与jvm相同

###### 3：方法区（静态域）：存储类的信息，通过类加载器载入类的字节码文件，经解析后装入方法区

?	1：线程共享的区域，方法只有一份，通过this来区分那个对象调用 ?	2：运行时常量池(Constant Pool)：方法区的一部分，用于存放编译器生成的各种字面量和符号引用 ?	3：Class文件的常量池，在类加载装入方法区的运行时的常量池中存放 ?	4：运行时常量池和class文件的常量池相比，具有动态性，即运行时也可以放入新的常量 ?	例：String类的 intern（）方法

?	5：静态成员变量存储在方法区

例: String str = new String("hello"); 变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的常量池中

### 2：内存分配

1：方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收

2：方法的引用，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完后从栈空间回收

3：方法调用时传入的实际参数，先在栈空间分配，在方法调用完成后从栈空间释放

### 3：JVM 主内存与工作内存：JVM将内存组织为主内存和工作内存两个部分

主内存：包括本地方法区和堆，线程共享区 工作内存：每个线程都有一个工作内存，工作内存中主要包括两个部分，一个是属于该线程私有的栈(Java栈和Native方法	栈)和 对程序计数器PC，线程隔离区

1.所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的 2.每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存 中进行而不能直接读写主内存中的变量

3.线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成

### 4：JVM Jdk 1.8 的划分

**元数据区取代了方法区**，元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：**元数据空间并不在虚拟机中，而是使用本地内存**，**字符串常量池 和 静态成员变量**从永久代中剥离出来，存放在堆中

### 5：栈，堆，方法区

1：基本数据类型的变量，对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间 2：通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾回收器管理的主要区域 3：常量池，源代码中的命名常量、String常量和static变量保存在方法区

### 6：内存泄漏和内存溢出

内存泄漏：不再使用的对象没有被及时的回收，内存无法被回收，造成浪费 建议：当对象不在使用时应及时设置为null 内存溢出：内存空间已满，不够用，定义的数据没有足够的空间存储 **OOM为out of memory**

**按照JVM规范，除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM**

##### 最常见的OOM情况有以下三种：

###### java.lang.OutOfMemoryError: Java heap space

java堆内存溢出，此种情况最常见，**一般由于内存泄露或者堆的大小设置不当引起**。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改

###### java.lang.OutOfMemoryError: PermGen space

java永久代溢出，即方法区溢出了，**一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况**，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出

###### java.lang.StackOverflowError

不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由**于程序中存在死循环或者深度递归调用造成的**，栈大小设置太小也会出现此种溢出，可以通过虚拟机参数-Xss来设置栈的大小

解决方式：

1：让深度递归遍历成非递归遍历

2：死循环，设置阈值，超出之后，直接终止执行

3：调整栈的大小

4：使用static对象替代nonstatic局部对象，还有逃逸分析

### 7：逃逸分析

逃逸分析(Escape Analysis)：是一种可以**有效减少Java 程序中同步负载和内存堆分配压力**的跨函数**全局数据流分析算法**，通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上，较少GC的时间，提高效率

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸

### 8：栈上分配：就是把没发生逃逸的对象，在栈分配空间，（一般对象分配空间是在堆）逃逸

###### 二者联系：jvm根据对象是否发生逃逸，会分配到不同（堆或栈）的存储空间