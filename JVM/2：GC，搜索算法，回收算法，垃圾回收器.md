### 垃圾搜索、回收、垃圾回收器

------

##### 1：垃圾：没有被任何引用所指向的对象

​	回收过程是透明的，并不一定看到垃圾就回收，若想快一些，可以调用 System.gc();

##### 2：垃圾回收器（Garbage Collection）

​	JVM自带的一个优先级很低的线程，用于回收没有任何引用所指向的对象，不同的虚拟机平台，实现的方法也	各不相同

###### 目的：

1. 安全性考虑
2. 减少内存泄露
3. 减少程序员工作量

##### 3：JVM 垃圾自动回收机制（GC）：主要进行回收的内存是JVM中的方法区和堆

1：对于堆中的对象，主要用根搜索判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收

2：对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类,就可以被回收

##### 判定为无用类

该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

虽然存在着垃圾回收机制，但是可能会存在"无用但可达"的对象（出栈对象），这些对象不能被 GC 回收，因此也会导致内存泄露的发生

### 4：Java 中的引用类型

根据对引用的不同需求，又分成了4种引用，每种引用的回收机制都是不同的 Java中对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用

决定对象的生命周期

###### 强引用（StrongReference）：new Object（）；

new的对象拥有强引用的对象，那么垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题

###### 软引用（SoftReference）：Java.lang.ref.Softerference 类

如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存 软引用是主要用于内存敏感的高速缓存，收集软可及的对象，可能解决内存吃紧问题，避免内存溢出

###### 弱引用（WeakReference） ：java.lang.ref Class WeakReference

如果一个对象只具有弱引用，那该类就是可有可无的对象，因为只要该对象被 gc 扫描到不管内存是否够用都会把它干掉，这些对象只能生存到下次GC之前

不能决定对象的生命周期

###### 虚引用（PhantomReference） ：java.lang.ref Class PhantomReference

**PhantomReference(T referent, ReferenceQueue <? super q) ** 通过get（） 从队列中取

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪某个对象被垃圾回收的活动

### 5：Java 对象 在 内存中的状态

###### 可达的/可触及的：

Java对象被创建后，如果被一个或多个变量引用，那就是可达的，即从根节点可以触及到这个对象 其实就是**从根节点扫描，只要这个对象在引用链中，那就是可触及的**

###### 可恢复的：

Java对象不再被任何变量引用就进入了可恢复状态 在回收该对象之前，**该对象的finalize()方法进行资源清理**，如果在finalize()方法中重新让变量引用该对象，则该对象再次变为可达状态，否则该对象进入不可达状态

```
protected void finalize()
```

###### 不可达的：

Java对象不被任何变量引用，且系统在调用对象的finalize()方法后依然没有使该对象变成可达状态（该对象依然没有被变量引用）那么该对象将变成不可达状态,当Java对象处于不可达状态时，系统才会真正回收该对象所占有的资源

### 6：搜索算法：搜索定位这些无用的对象（垃圾）

###### 1：引用计数器算法（废弃）

?	引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为对象不再被使用，是“垃圾”了

缺陷：不能解决对象的循环引用问题

###### 2：根搜索算法（使用） ：可达性分析(Reachability Analysis)

?	根搜索算法是通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（Reference Chain）当一个对象没有被GC Roots的引用链连接的时候，说明这个对象是不可达的

```
GC roots（GC根），在JAVA语言中，可以当做GC roots的对象有以下几种：

  		1：栈（栈帧中的本地变量表）中引用的对象
		2：本地方法栈中JNI（一般说的Native方法）引用的对象
		3：方法区中的静态成员
		4：方法区中的常量引用的对象（全局变量），指的是声明为final的常量值
```

### 7：回收算法：算法搜索到无用对象之后，就是回收过程

标记-清除算法、复制算法、标记-整理算法，这三种算法都扩充了根搜索算法

**1：标记—清除算法（Mark-Sweep）** 标记—清除算法包括两个阶段：“标记”和“清除”。**在标记阶段，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象，清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉**

缺陷：标记—清除算法是基础的收集算法，标记和清除阶段的效率不高，而且清除后回产生大量的不连续空间， 这样当程序需要分配大内存对象时，可能无法找到足够的连续空间

**2：标记—整理算法（Mark-Compact） ---老生代** 标记—整理算法和标记—清除算法一样，但是标记—整理算法是把标记的存活对象往内存的一端移动，然后直接回收边界以外的内存

**3：复制算法（Copying） -----新生代** 复制算法是把内存分成大小相同的两块，每次使用其中一块，当垃圾回收的时候，把存活的对象复制到另一块上， 然后把这块内存整个清理掉

缺陷：复制算法实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率不高

现实中的虚拟机复制算法： 将java堆 内存（新生代和老生代）新生代，分为一块比较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其 中一块Survivor，8:1:1 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的 Survivor空间,HotSpot虚拟机默认Eden和Survivor的大小比例是8:1， 每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费

新生代中的对象98%都是“朝生夕死”的，当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以直接把大对象进入老年代

[![新生代，老年代，永久代.jpg](https://github.com/likang315/Java-and-Middleware/raw/master/4%EF%BC%9AJVM/JVM/%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%8C%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%8C%E6%B0%B8%E4%B9%85%E4%BB%A3.jpg?raw=true)](https://github.com/likang315/Java-and-Middleware/blob/master/4：JVM/JVM/新生代，老年代，永久代.jpg?raw=true)

##### 新生代又分为 Eden区、ServivorFrom、ServivorTo三个区

**MinorGC 采用复制算法**：首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）；然后，清空 Eden 和 ServicorFrom 中的对象；最后，ServicorTo 和 ServicorFrom 互换，原ServicorTo成为下一次GC时的ServicorFrom 区

**MajorGC采用标记—清除算法**：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配

指内存的永久保存区域，主要存放 Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域. 它和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理，所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出 OOM 异常

###### 在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）spaceMeta 的区域所取代

**Full GC：清理整个堆空间，包括年轻代和永久代**，还有方法区

###### 出发 Full GC 的条件：

1：System.gc() 方法的调用

2：老年代空间不足，在新生代对象转入及创建大对象、大数组时才会出现不足的现象

3：永生区空间不足（方法区）

4：CMS GC 时，出现 promotion failed 和 concurrent mode failure（并发标记）

**4：分代收集（Generational Collection)** 分代收集是根据对象的存活时间把内存分为新生代和老年代，根据各个代对象的存活特点，每个代采用不同的垃圾回收算法

```
一般是把Java堆分为新生代和老年代：存活时间短的对象归为新生代，存活时间长的对象归为老年代
永久代：即方法区

存活率低：少量对象存活，适合复制算法
在新生代中，每次GC时都发现有大批对象死去，只有少量存活（新生代中98%的对象都是“朝生夕死”），那就选用复制算法
只需要付出少量存活对象的复制成本就可以完成GC
存活率高：大量对象存活，适合用标记-清理/标记-整理
在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC
```

注：老年代的对象中，有一小部分是因为在新生代回收时，老年代做担保，进来的对象,绝大部分对象是因为很多次GC都没有被回收掉而进入老年代

### 9：垃圾收集器：( STW: Stop The World：最小停顿时间 )

[![垃圾回收器.jpg](https://github.com/likang315/Java-and-Middleware/raw/master/4%EF%BC%9AJVM/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.jpg?raw=true)](https://github.com/likang315/Java-and-Middleware/blob/master/4：JVM/JVM/垃圾回收器.jpg?raw=true)

### Stop-The-World 机制：

简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native 代码可以执行，但不能与 JVM 交互

#### 1：Serial + Serial Old（ 串行收集器组合 ）

开启选项：`-XX:+SerialGC`

是一个单线程的收集器,它进行垃圾收集时,必须暂停其他所有的工作线程直到它收集结束

###### Serial收集器：是虚拟机运行在client模式下的默认新生代收集器

内存不足时，串行GC设置停顿标识，待所有线程都进入安全点(Safepoint)时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存

#### 2：Parallel Scavenge + Parallel Old（并行收集器组合）

###### 开启选项：`-XX:+UseParallelGC`或`-XX:+UseParallelOldGC`(可互相激活)

并行收集器与串行收集器工作模式相似，都是stop-the-world方式，**只是暂停时并行地进行垃圾收集**，以关注吞吐量为目标

**年轻代采用复制算法，老年代采用标记-整理**，在回收的同时还会对内存进行压缩。关注吞吐量主要指年轻代的Parallel Scavenge收集器，通过两个目标参数-XX:MaxGCPauseMills和-XX:GCTimeRatio，调整新生代空间大小，来降低GC触发的频率

#### 3：ParNew收集器：Serial收集器的多线程版本，多个Serial收集器线程一起GC,运行在server模式下的首选新生代收集器

### 4：CMS 收集器（Concurrent Mark Sweep：并发+标记+清除）：一种以获取最短回收停顿时间为目标的收集器

###### 应用于重视服务器的响应速度，希望系统停顿时间最短，例如在互联网站或者B/S系统的服务器上，cms 收集算法只是清理老年代

##### CMS 的执行过程可以分为以下几个阶段

[![CMS.png](https://github.com/likang315/Java-and-Middleware/raw/master/4%EF%BC%9AJVM/JVM/CMS.png?raw=true)](https://github.com/likang315/Java-and-Middleware/blob/master/4：JVM/JVM/CMS.png?raw=true)

###### 1：InitialMarking（初始化标记，STW过程 ）

该阶段单线程执行，主要分分为两步：标记GC ROOT能**直接关联**到的对象，标记根对象

1. 标记GC Roots可达的老年代对象；
2. 遍历新生代对象，标记可达的老年代对象；

###### 2： Marking（并发标记）

该阶段进行 GC ROOT TRACING，**GC线程和应用线程并发执行**，遍历 InitialMarking 阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象

因为该阶段并发执行的，在运行期间可能发生**新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等**，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况

为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代

###### 3：Precleaning（预清理）

通过参数`CMSPrecleaningEnabled`选择关闭该阶段，默认启用，主要做两件事情：

1. 处理新生代已经发现的引用，比如在并发阶段，在Eden区中分配了一个A对象，A对象引用了一个老年代对象B（这个B之前没有被标记），在这个阶段就会标记对象B为活跃对象

2. 在并发标记阶段，如果老年代中有对象内部引用发生变化，会把所在的Card标记为Dirty，通过扫描这些Table，重新标记那些在并发标记阶段引用被更新的对象（晋升到老年代的对象、原本就在老年代的对象）

   ##### CARD TABLE卡表（这个东西其实就是个数组,数组中每个位置存的是一个byte)

   CMS将老年代的空间分成大小为512 byte 的块，card table中的每个元素对应着一个块,并发标记时，如果某个对象的引用发生了变化，就标记该对象所在的块为 **dirty card**,并发预清理阶段就会重新扫描该块，将该对象引用的对象标识为可达

###### 4：AbortablePreclean（可中断的预清理）（可能没有）

该阶段发生的前提是，**新生代Eden区的内存使用量大于参数**`CMSScheduleRemarkEdenSizeThreshold` 默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段

###### 5：FinalMarking（并发重新标记，STW过程）：该阶段的任务是完成标记整个年老代的所有的存活对象

该阶段并发执行，在之前的并行阶段，可能产生新的引用关系如下：

1. 老年代的新对象被GC Roots引用
2. 老年代的未标记对象被新生代对象引用
3. 老年代已标记的对象增加新引用指向老年代其它对象
4. 新生代对象指向老年代引用被删除
5. 也许还有其它情况

上述对象中**可能有一些已经在Precleaning阶段和AbortablePreclean阶段被处理过，但总存在没来得及处理的**，所以还有进行如下的处理：

1. 遍历新生代对象，重新标记
2. 根据GC Roots，重新标记
3. 遍历老年代的Dirty Card，重新标记，这里的Dirty Card大部分已经在clean阶段处理过

###### 6：并发清除：清除那些没有标记的对象并且回收空间，用户线程被重新激活，所以可能存在浮动垃圾

###### 7：重置：重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用

#### 浮动垃圾：

并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理

#### CMS默认的回收线程数是 `(CPU个数+3)/4`

并发时GC线程与用户线程抢占CPU,这可能会造成用户线程执行效率下降

如果触发了主动Old GC，这时周期性Old GC正在执行，那么会夺过周期性Old GC的执行权（同一个时刻只能有一种在Old GC在运行），并记录 concurrent mode failure 或者 concurrent mode interrupted

### cms gc 和 full gc 的区别

**cms gc** 通过一个后台线程触发，触发机制是默认**每隔2秒判断一下当前老年代的内存使用率是否达到阈值**，当然具体的触发条件没有这么简单，如果是则触发一次cms gc，在该过程中只会标记出存活对象，然后清除死亡对象，期间会产生碎片空间

**full gc** 是通过 vm thread（虚拟机线程） 执行的，单线程的，整个过程是 stop-the-world，在该过程中会判断当前 gc 是否需要进行compact（压缩），即把存活对象移动到内存的一端，可以有效的消除cms gc产生的碎片空间

### 5：G1 收集器：设计原则就是简单可行的性能调优，取消了新生代，老年代的物理空间划分，jdk1.9

**将堆划分为若干个区域（Region**），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，**新生代的垃圾收集依然采用暂停所有应用线程的方式（STW）**，将存活对象拷贝到老年代或者Survivor空间。**老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作，相当于标记-整理**。这就意味着，不会出现内存碎片

### 特 点

**1：支持并行并发：**G1使用多个CPU来缩短Stop-The-World停顿时间，通过并发可以让 java 程序继续运行 **2：分区 Region：**默认将**整堆划分为2048个分区,*，逻辑上又分为新生代和老生代 **3：空间整合：**结合多种垃圾收集算法，不会产生内碎片** 4：可预测的停顿：低停顿的同时实现高吞吐，可以明确指定M毫秒的时间片内，消耗在垃圾收集上的时间不能超过 N 毫秒

**Humongous区域：** 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，**G1划分了一个Humongous区，它用来专门存放巨型对象**。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC

[![G1内存划分.png](https://github.com/likang315/Java-and-Middleware/raw/master/4%EF%BC%9AJVM/JVM/G1%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png?raw=true)](https://github.com/likang315/Java-and-Middleware/blob/master/4：JVM/JVM/G1内存划分.png?raw=true)

#### Remembered Set：用于跟踪指向某个heap区内的对象引用

G1中使用**point-in的意思是哪些分区引用了当前分区中的对象**。这样，仅仅将这些对象当做根来扫描就避免了无效的，在于每次GC时，所有新生代都会被扫描，所以**只需要记录老年代到新生代之间的引用**即可

如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，通过卡表

在G1 中通过**卡表（Card Table）**，**一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，**每个区域称之为卡。卡通常较小，介于128到512字节之间。**Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址**。默认情况下，每个卡都未被引用。**当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用**

此外 RSet 也将这个数组下标记录下来，一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table 的 Index

### Young GC 阶段：复制算法

###### 1：扫描所有新生代区域，进行根扫描

###### 2：处理 dirty card 队列更新RSet

###### 3：处理RSet ，检测从年轻代指向年老代的对象

###### 4：把存活的对象拷贝到 survivor/old 区域，回收这个区域

### MiXed GC 阶段：不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区

###### 1：全局并发标记（global concurrent marking） ：和CMS类似过程

###### 2：拷贝存活对象（evacuation）

### JVM 调优

-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis = 200

其中**-XX:+UseG1GC**为开启G1垃圾收集器，**-Xmx32g** 设计堆内存的最大内存为32G，**-XX:MaxGCPauseMillis=200**设置GC的最大暂停时间为200ms，如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可