### GC：垃圾收集器

------

##### 1：Stop-The-World：最小停顿时间

​	简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起，除了垃圾收集帮助器之外，Java 中一种全局暂停现象（safePoint），全局停顿，所有Java代码停止，native 代码可以执行，但不能与 JVM 交互

![](https://github.com/likang315/Java-and-Middleware/blob/master/JVM/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.jpg?raw=true)

##### 2：Serial：串行收集器

是一个单线程的收集器，采用复制算法新生代收集器，它进行垃圾收集时，必须暂停其他所有的工作线程直到它收集结束

- HotSpot虚拟机运行在Client模式下的默认的新生代收集器

- 简单而高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率

- ###### 获取最短回收停顿时间为目标的收集器

- 开启选项：`-XX:+SerialGC`

##### 3：ParNew：并行收集器组合

 	是Serial收集器的多线程版本，它也是一个新生代收集器，其他均与serial收集器一样

- 运行在Server模式下的虚拟机中首选的新生代收集器
- 并行收集器与串行收集器工作模式相似，都是stop-the-world方式，**只是暂停时并行地进行垃圾收集**，以关注吞吐量为目标
- 除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作
- 开启选项：`-XX:+UseParallelGC`或`-XX:+UseParallelOldGC`(可互相激活)

##### 4：Parallel Scavenge 收集器：

- 是一个并行的多线程新生代收集器，它也使用复制算法
- Parallel Scavenge  收集器的目标是**达到一个可控制的吞吐量（Throughput）**

###### 以上三种都是新生代收集器

##### 5：Serial Old收集器

​	Serial Old 是 Serial收集器的老年代版本，它同样是一个单线程收集器，使用**标记-整理(Mark-Compact)**算法

- 此收集器的主要意义也是在于给Client模式下的虚拟机使用

- Serial + Serial Old :配合使用

  ![](/Users/likang/Code/Git/Java-and-Middleware/JVM/JVM/serial+serial Old.png)

##### 6：Parallel Old收集器

​	Parallel Scavenge收集器的老年代版本，使用**多线程**和**标记-整理**算法

- 这个收集器是在JDK 1.6中才开始提供的，在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，**吞吐量优先收集器**终于有了比较名副其实的应用组合，在**注重吞吐量以及CPU资源敏感**的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器
- Parallel Scavenge + Parallel Old ：上图多线程版

##### 7：CMS 收集器（Concurrent Mark Sweep：并发+标记+清除）：

​	 以获取最短回收停顿时间为目标的收集器，应用于重视服务器的响应速度，希望系统停顿时间最短，例如在互联网站或者B/S系统的服务器上，cms 收集算法只是清理老年代

###### CMS 的执行过程可以分为4个阶段

![](https://github.com/likang315/Java-and-Middleware/blob/master/JVM/JVM/CMS.png?raw=true)

1. ###### InitialMarking（初始化标记，STW过程 ）

   - 该阶段单线程执行，主要分分为两步：标记GC ROOT能**直接关联**到的对象，标记根对象
     - 标记GC Roots可达的老年代对象；
     - 遍历新生代对象，标记可达的老年代对象；

2. ######  Marking（并发标记）

   - 进行 GC Root Trancing，**GC线程和应用线程并发执行**，遍历 InitialMarking 阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象
   - 因为该阶段并发执行的，在运行期间可能发生**新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等**，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况
   - 为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代

3. ######  Precleaning（预清理）

   - 通过参数`CMSPrecleaningEnabled`选择关闭该阶段，默认启用，主要做两件事情	
     1. 处理新生代已经发现的引用，比如在并发阶段，在Eden区中分配了一个A对象，A对象引用了一个老年代对象B（这个B之前没有被标记），在这个阶段就会标记对象B为活跃对象
     2. 在并发标记阶段，如果老年代中有对象内部引用发生变化，会把所在的Card标记为Dirty，通过扫描这些Table，重新标记那些在并发标记阶段引用被更新的对象（晋升到老年代的对象、原本就在老年代的对象）

###### CARD TABLE卡表（这个东西其实就是个数组,数组中每个位置存的是一个byte)

​	CMS将老年代的空间分成大小为512 byte 的块，card table中的每个元素对应着一个块,并发标记时，如果某个对象的引用发生了变化，就标记该对象所在的块为 **dirty card**，并发预清理阶段就会重新扫描该块，将该对象引用的对象标识为可达

4. ###### FinalMarking（并发重新标记，STW过程）：该阶段的任务是完成标记整个老年代的所有的存活对象

   该阶段在只有GC线程并发执行，用户线程不参与，在之前的并行阶段，可能产生新的引用关系如下：

   1. 老年代的新对象被GC Roots引用
   2. 老年代的未标记对象被新生代对象引用
   3. 老年代已标记的对象增加新引用指向老年代其它对象
   4. 新生代对象指向老年代引用被删除
   5. 也许还有其它情况

上述对象中 **可能有一些已经在Precleaning阶段被处理过，但总存在没来得及处理的**，所以还有进行如下的处理：

- 遍历新生代对象，重新标记
- 根据GC Roots，重新标记
- 遍历老年代的Dirty Card，重新标记，这里的Dirty Card大部分已经在clean阶段处理过

5. ###### 并发清除：Concurrent sweep

   - 清除那些没有标记的对象并且回收空间，用户线程被重新激活，所以可能存在浮动垃圾

   - ###### 浮动垃圾：

     - 并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理

6. ###### 重置：

   - 重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用

-  CMS 默认的回收线程数是：(CPU个数+3)/4
- 并发时 GC线程 与用户线程抢占CPU，这可能会造成用户线程执行效率下降
- 如果主动触发了Old GC，这时周期性Old GC正在执行，那么会夺过周期性Old GC的执行权（同一个时刻只能有一种在Old GC在运行），并记录 concurrent mode failure 或者 concurrent mode interrupted

###### cms gc 和 full gc 的区别

- cms gc：通过一个后台线程触发，触发机制是默认**每隔2秒判断一下当前老年代的内存使用率是否达到阈值**，当然具体的触发条件没有这么简单，如果是则触发一次cms gc，在该过程中只会标记出存活对象，然后清除死亡对象，期间会产生碎片空间
- Major GC/Full GC：是通过 vm thread（虚拟机线程） 执行的，单线程的，整个过程是 stop-the-world，在该过程中会判断当前 gc 是否需要进行compact（压缩），即把存活对象移动到内存的一端，可以有效的消除cms gc产生的碎片空间

##### 8：G1 收集器：设计原则就是简单可行的性能调优，取消了新生代，老年代的物理空间划分，jdk1.9

**将堆划分为若干个区域（Region**），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，**新生代的垃圾收集依然采用暂停所有应用线程的方式（STW）**，将存活对象拷贝到老年代或者Survivor空间。**老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作，相当于标记-整理**。这就意味着，不会出现内存碎片

### 特 点

**1：支持并行并发：**G1使用多个CPU来缩短Stop-The-World停顿时间，通过并发可以让 java 程序继续运行 **2：分区 Region：**默认将**整堆划分为2048个分区,*，逻辑上又分为新生代和老生代 **3：空间整合：**结合多种垃圾收集算法，不会产生内碎片** 4：可预测的停顿：低停顿的同时实现高吞吐，可以明确指定M毫秒的时间片内，消耗在垃圾收集上的时间不能超过 N 毫秒

**Humongous区域：** 如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，**G1划分了一个Humongous区，它用来专门存放巨型对象**。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC

[![G1内存划分.png](https://github.com/likang315/Java-and-Middleware/raw/master/4%EF%BC%9AJVM/JVM/G1%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png?raw=true)](https://github.com/likang315/Java-and-Middleware/blob/master/4：JVM/JVM/G1内存划分.png?raw=true)

#### Remembered Set：用于跟踪指向某个heap区内的对象引用

G1中使用**point-in的意思是哪些分区引用了当前分区中的对象**。这样，仅仅将这些对象当做根来扫描就避免了无效的，在于每次GC时，所有新生代都会被扫描，所以**只需要记录老年代到新生代之间的引用**即可

如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，通过卡表

在G1 中通过**卡表（Card Table）**，**一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，**每个区域称之为卡。卡通常较小，介于128到512字节之间。**Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址**。默认情况下，每个卡都未被引用。**当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用**

此外 RSet 也将这个数组下标记录下来，一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table 的 Index

### Young GC 阶段：复制算法

###### 1：扫描所有新生代区域，进行根扫描

###### 2：处理 dirty card 队列更新RSet

###### 3：处理RSet ，检测从年轻代指向年老代的对象

###### 4：把存活的对象拷贝到 survivor/old 区域，回收这个区域

### MiXed GC 阶段：不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区

###### 1：全局并发标记（global concurrent marking） ：和CMS类似过程

###### 2：拷贝存活对象（evacuation）

### JVM 调优

-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis = 200

其中**-XX:+UseG1GC**为开启G1垃圾收集器，**-Xmx32g** 设计堆内存的最大内存为32G，**-XX:MaxGCPauseMillis=200**设置GC的最大暂停时间为200ms，如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可