### Lock

------

[TOC]

##### 01：锁

- 数据库系统区别于文件系统的⼀个关键特性，用于管理对共享且可变资源的并发访问；
- InnoDB 会在行记录上加锁，同时也会在内部其他地方使用，保证并发性和一致性；

###### 两种标准的行级锁

1. 共享锁：事务读数据时，读锁，可重复加锁；
2. 互斥锁：事务更新或删除一行数据时，写锁，默认时排它锁；
   - 此外, **InnoDB 支持多粒度锁定**，允许事务在行级别和表级别同时存在，因此引出了意向锁（Intention Lock）
   - 意向锁意味着事务希望在更细粒度上进行加锁（行锁）；

##### 02：锁的分类

###### 全局锁

- 给整个数据库加锁，数据库就只读了，备份时使用；

- ```sql
  // 加锁
  flush tables with read lock
  // 释放锁
  unlock tables
  ```

###### 表级锁

- 操作对象是数据表，没有走索引，全表扫描，加的是表锁；
- MySQL 大多数锁策略都支持，是系统**开销最高且并发性最低**的一个锁策略。

###### 01：表锁

- 事务对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务都不行。

- ```sql
  // 表级别的共享锁，也就是读锁
  lock tables t_student read;
  // 表级别的独占锁，也就是写锁；
  lock tables t_stuent write;
  // 释放所有表锁
  unlock tables
  ```

###### 02：元数据锁（DML）

- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；
- 当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有**其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞**，直到执行完 select 语句（ 释放 MDL 读锁）。
- 当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果**有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞**，直到表结构变更完成（ 释放 MDL 写锁）。
- 为什么线程没有申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？
  - 因为申请 MDL 锁的操作会形成一个队列，队列中**写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

###### 03：意向锁

- 意向共享锁：在使用 InnoDB 引擎的表里对某些记录加上共享锁之前，需要先在表级别加上一个意向共享锁；
- 意向独占锁：在使用 InnoDB 引擎的表里**对某些纪录加上独占锁之前，需要先在表级别加上一个意向独占锁**；
- 意向锁的目的：**为了快速判断表里是否有记录被加锁。**

###### 04：AUTO-INC 锁

- 主键字段声明AUTO_INCREMENT，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁**实现的。
- AUTO-INC 锁是特殊的表锁机制，该锁不是再一个事务提交后才释放，而是再**执行完插入语句后就会立即释放**。
- 从 MySQL 5.1开始，在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，**然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁**。

###### 行级锁

- 操作对象是数据表中的一行记录；
- InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁（自动加），否则，InnoDB将使用表锁；
  - 通过**给索引上的索引项加锁，加锁的基本单位是 next-key lock**；
  - 在能使用记录锁或者间隙锁就能避免幻读现象的场景下， **next-key lock 就会退化成记录锁或间隙锁**。
- 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是**访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的**

###### 01：记录锁（Record Lock）

- 记录锁，锁住的是一条记录。有共享锁和独占锁的区别；

- ```java
  // 对读取的记录加共享锁
  SELECT .... FROM table WHERE 索引条件 LOCK IN SHARE MODE；
  // 对读取的记录加独占锁
  SELECT .... FROM table WHERE 索引条件 FOR UPDATE；
  ```

###### 02：间隙锁（Gap Lock）

- 间隙锁：**只存在于可重复读隔离级别**，目的是为了解决可重复读隔离级别下幻读的现象。
- 间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系。
- 当我们**用范围条件而不是相等条件检索数据**，并**请求共享或互斥锁时**，InnoDB会给符合条件的已有数据记录的**索引项加锁**

###### 03：临建锁（Next-Key Lock）

- 临键锁：是 Record Lock + Gap Lock 的组合，**锁定一个范围，并且锁定记录本身。**
- Next-Key Lock **即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中**。

###### 04：插入意向锁

- 事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock）。如果有的话，插入操作就会**发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。
- 间隙锁锁住的是一个区间，插入意向锁**锁住的就是一个点**。

##### 03：加锁方式【悲观锁】

- 自动加锁：**在InnoDB中，insert, update, delete 等语句执行时都会自动加解锁**，修改操作的锁会持有到事务结束，效率高很多；
- 手动加锁：**select .... from table where 索引条件 for update**，在SQL语句中手动加锁；

##### 04：行级锁加锁规则

- 唯一索引在满足一些条件的时候，索引的 next-key lock 退化为间隙锁或者记录锁。
- 非唯一索引范围查询，索引的 next-key lock 不会退化为间隙锁和记录锁。

##### 05：快照读和当前读

###### 一致性非锁定读 (consistent nonblocking read) 【快照读】

- 指 InnoDB 通过**多版本并发控制的方式**来读取当前执行时间数据中的数据，如果当前数据正在执行修改操作，这时读取操作不会被阻塞，而是去读取⼀个**快照数据，通过 Undo log 实现**，快照数据就是当前行数据的历史版本，有多个版本；

###### 一致性锁定读【当前读】

- InnoDB 支持两种一致性的锁定读加锁语句，**通过加间隙锁；**
  - SELECT .... FROM table WHERE 索引条件 **FOR UPDATE**；
    - 对读取的行加锁之后，其他事物不能对已锁定的行加锁，是一种排他锁，其他线程来都被阻塞；
  - SELECT .... FROM table WHERE 索引条件 **LOCK IN SHARE MODE**；
    - 对读取的行加锁之后，**其他事物可以对被锁定的行加相同的锁**，共享锁；

##### 06：死锁检测 (dead lock)

1. **超时检测：**
   -  设置一个阈值，当任意一方等待时间超过预设的阈值时, 其中⼀个事务回滚 ；
   -  InnoDB 锁超时默认时间是 **5s** ；
2. **wait-for-graph 主动检测：**
   - 通过“等待获取的锁” 和 “等待获取该锁的事务”之间，构造出⼀张**有向图，如果图中存在回路**, 就代表存在死锁, 一旦发现回路，会**选择 undo log 量最小的进行回滚**，另⼀个事务就得以继续执行，被回滚的事务会返回"dead lock"。
