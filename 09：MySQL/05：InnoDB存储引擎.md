### InnoDB

------

[TOC]

##### 01：InnoDB 架构

- MySQL 从 5.5 版本之后默认的存储引擎，是第一个支持完整 ACID 特性的事务型存储引擎；

<img src="https://github.com/likang315/Middleware/blob/master/09：MySQL/photos/Innodb-architecture.png?raw=true" style="zoom:67%;" />

###### 后台线程

- 负责刷新缓存池中的数据，保证缓存池中的缓存的是最新的数据；
- 将已经修改的数据文件刷新到磁盘文件（刷盘），同时保证数据库在发生异常的情况下InnoDB能恢复到正常的运行状态；

1. **Master Thread：**将内存数据**异步刷新到磁盘**，InnoDB 的主要工作都是该线程完成，该线程具有最高的优先级；
2. **IO Thread：**处理 IO 请求的回调；
3. **Purge Thread：**在事务提交的时候**回收 Undo Log**；
   - 具体的规则是将删除版本号小于当前系统版本的行删除；
4. **Page Clear Thread：**将脏页刷新操作都放入到单独的线程中来完成；
   - 脏页：读到的数据（缓冲池中），还没有刷新到磁盘上。

###### 缓冲池：innodb_buffer_pool

1. InnoDB 存储引擎是基于磁盘存储的，并将其中所有的记录**按照页**的方式进行管理，由于 CPU 和磁盘速度的鸿沟，采用**缓存池技术**来提高数据库的性能；
2. 缓存池是一块内存区域，在 DB 读取页的时候，首先将从磁盘读到的页存放到缓存池中, 该过程称为**将页"FIX"在缓冲池中**，下次再读相同页的时候先判断是否在缓冲池中。对于写操作，**首先修改缓冲池中的页, 再以一定的频率刷新到磁盘上**，而不是每次发生页修改时触发，**通过"CheckPoint 机制"，刷新磁盘**；
3. 缓冲池的大小默认为 **256KB**，使用LRU(最近最少使用)算法进行管理，InnoDB 对新读取的页会放在 midpoint  (默认5/8长度处)；
4. 重做日志缓冲：InnoDB 首先将 Redo Log 日志放入这个缓冲区，然后以一定的频率刷新到磁盘的 Redo Log 文件中。

##### 02：InnoDB 特性

###### Insert Buffer：提高性能

- 在 InnoDB 中，主键是唯一的标识，在**插入记录的顺序是按照主键递增的顺序进行**，因此不需要磁盘的随机读取。在⼀般情况下，不需要随机读取另⼀个页中的记录，因此 InnoDB 如果采用**自增主键的方式**去插入速度会非常快。但与此同时，更多情况下表中除了主键以外还存在其他索引，此时的插入顺序依然是按照主键顺序存放，对于**非主键索引的叶子节点的插入就不再是顺序的**，此时就需要离散的访问非聚簇索引页，从而产生**大量随机读取导致插入性能下降**，因此对于非聚簇索引的插入或者更新，不是一次直接插入到索引页中，而是先判断插入的非聚簇索引页是否在缓冲池中，如果在，直接插入，否则先放入⼀个 **Insert Buffer** 对象，作为占位符，然后再以⼀定的频率进行 Insert Buffer 和 索引叶子节点的 merge 操作；


###### 二次写（double write）：提高数据页的可靠性

1. 第一部分：double write buffer，大小为 2M
   - 备份的作用，如果写入到共享表空间时出现异常，可以通过double write buffer中的数据进行恢复；

2. 第二部分：物理磁盘上的共享表空间中连续的128个页，即两个区（两个区的数据相同），大小同样为2M；
   - 保证数据页的可靠性；
   - 对缓冲池的脏页进行刷新时，并不直接写硬盘，而是通过**memcpy函数将脏页先拷贝到内存中的 double write buffer**，之后通过 **double write buffer 再分两次写**，每次写入1M到**共享表空间的物理磁盘上**，然后马上**调用 fsync 函数，同步磁盘**，避免数据的丢失；

###### 自适应性哈希索引

- InnoDB 会监控表上各项索引页的查询，如果**观察到适合建立哈希索引就会行动**，因此被称为自适应性哈希索引(Adaptive Hash Index, AHI)，AHI 通过索引页构造而来，InnoDB 会根据**访问的频率和模式**来自动为某些热点页建立 AHI；
- 自适应哈希索引通过**缓冲池的B+树**构造而来，因此建立的速度很快；

##### 03：MySQL  文件存储目录

- SHOW VARIABLES LIKE 'datadir';
  - 查看 MySQL 文件存储目录

###### 数据库文件（三个）

- **db.opt**：用来存储当前数据库的**默认字符集和字符校验规则**；
- **tableName.frm**：tableName 的**表结构**保存在这个文件。每一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。
- **tableName.ibd**：tableName的**表数据**保存在这个文件。每个表独立的表空间；
  - innodb_file_per_table = 1 ，代表将存储的数据、索引等信息单独存储在一个独立的表空间。

##### 04：InnoDB 表存储

- 在 InnoDB 中，表中的数据都是根据**主键顺序组织存放的**，这种存储方式成为索引组织表。

<img src="https://github.com/likang315/Middleware/blob/master/09：MySQL/photos/Innodb-save.png?raw=true" style="zoom:67%;" />

1. **表空间(TableSpace)：**InnoDB 存储引擎逻辑存储的顶层对象，所有数据都存放在表空间。其中包括数据、索引、插入缓冲、回滚信息、系统事务信息等。
2. **段(Segment)：**表空间是由多个段组成的, 常见的段有**数据段，索引段，回滚段等**。InnoDB 由于索引组织表的特点，数据即索引，索引即数据。因此**数据段是 B+ 树的叶子节点，索引段是 B+ 树的非叶子节点**。
3. **区(Extent)：** 区是由连续页组成的空间, 在任何情况下**每个区的大小都为 1MB**，为了保证区中页的连续性，InnoDB 一次从磁盘申请 4-5 个区，**默认情况下 InnoDB 页的大小为 16KB, 一个区中一共有 64 个连续的页**。
4. **页(Page)：**InnoDB 最小存储单位，**默认 16KB**，常见的页有: 数据页 / undo log页 / 系统页；
   - InnoDB 的数据是**以页**为单位来读写的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。

5. **行(Row)：** InnoDB 中数据按行进行存放；


###### 页结构

1. **File Header(文件头)**：固定 38 字节，用来记录头信息，以及**相邻页的指针**；
2. Page Header(页头)： 固定 56 字节，用来记录数据页的状态信息；
3. Infinum 和 Suprenum Records：虚拟的行记录，分别表示页中最大和最小记录；
4. User Recodes(用户记录, 即行记录)； 
5. Free Space(空闲记录) ；
6. **Page Directory(页目录)：**存放记录的相对位置，找到 B+ 树叶⼦节点后，再通过 Page Directory 再进行**二分查找**；
7. **File Trailer(文件结尾信息)：**固定 8 字节，用于检测页是否已经完整地写入磁盘；

###### 页存储空间（单表 2KW）

- 一页除了数据，其他空间大约 1K。一页 16K -1K = 15 K，用于存储数据；
- 索引页：主键（BigInt 8 byte）+ 页码（int 4 byte）= 12 byte （一行），**15 *1024 / 12 = 1280 行；**
- 数据页：数据按照一页 1K 计算，**15  / 1 = 15 行；**
- MySQL：Total = x ^ (z-1)  * y，x：索引页行数，y：数据页行数，z：层数；
  - 假设 B+ 树是两层，那就是 z = 2， Total = （1280 ^1 ）*15 = 19200
  - 假设 B+ 树是三层，那就是 z = 3， Total = （1280 ^2） *15 = 24576000 （约 2.45kw）

##### 05：行格式

- Redundant：MySQL 5.0 之前的格式；
- Compact：MySQL 5.1 版本之后默认的，一种紧凑的数据格式，为了让页存储更多的数据；
- Dynamic：MySQL5.7 版本之后默认的，也是紧凑的行格式，和 Compact 非常类似；
- Compressed：紧凑的行格式，和 Compact 非常类似；

###### Compact 行格式

- <img src="/Users/likang/Code/Git/Middleware/09：MySQL/photos/Compact.png" alt="Compact" style="zoom:30%;" />

###### 记录的额外信息

- **可变长字段列表**：记录可变长字段占用字节数，逆序存放；
  - 例：04（列 2） 03（列 1 ）
  - **非必须的**，若表字段没有可变长字段，就没有可变长字段列表；

- **NULL 值列表**：表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把**这些值为 NULL 的列存储到 NULL值列表中**。
  - 每个列对应一个二进制位（bit），**二进制位按照列的顺序逆序排列**，1：该字段为NULL，不足1 byte，高位补0；
  - **非必须的**，所有字段定义 NOT NULL；

- **记录头信息**：固定大小 5 byte；
  - delete_mask ：标识此条数据是否被删除。执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的该字段值标记为 1；
  - next_record：下一条记录的位置，记录与记录之间是通过链表组织的；
  - record_type：表示当前记录的类型，0 表示普通记录，1 表示B+树非叶子节点记录，2 表示最小记录，3 表示最大记录；

###### 为什么要逆序存放？

- 因为记录头信息中指向**下一个记录的指针**，指向的是下一条记录的记录头信息和真实数据之间的位置。这样的作用是**向左读就是记录头信息，向右读就是真实数据**，比较方便。
- 使得记录靠前的字段**真实数据和数据对应字段长度信息可以同时被加载到一个缓冲行中**；

###### 隐藏字段

- row_id：没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。**不是必需的，占用 6 个字节**。
- trx_id：事务id，表示这个数据是由哪个事务生成的。 **trx_id 是必需的，占用 6 个字节。**
- roll_pointer：这条记录**上一个版本的指针**。**roll_pointer 是必需的，占用 7 个字节。**

###### varchar(n) 中 n 最大取值为多少？

- MySQL 规定除了 TEXT、BLOB 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节（一行大小）。
- n 不能超过 65535 - **变长字段长度列表** - NULL 值列表；

###### 行溢出

- 如果一个数据页存不了一条记录，InnoDB 存储引擎会自动**将溢出的数据存放到溢出页中**。
- 当发生行溢出时，**记录的真实数据位置只会保存该列的一部分数据，而把剩余的数据放在溢出页中**，然后**在真实数据位置用 20 个字节存储指向溢出页的地址**，从而可以找到剩余数据所在的页。

##### 06：索引

- 为了提高查询效率，索引其实是就一个B+树，该表**保存了索引字段与主键**，索引段和数据段都存储在硬盘上，**读取一个节点一次磁盘 I/O 操作**。
- B+Tree 存储**千万级的数据只需要 3-4 层高度**，意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O；
  1. 层数要少，磁盘 IO 次数少；
  2. 支持范围查询；

- <img src="https://github.com/likang315/Middleware/blob/master/09：MySQL/photos/index.png?raw=true" alt="index" style="zoom:60%;" />


###### 01：聚簇索引(主键索引)

- 聚簇索引就是按照**每张表的主键构造⼀棵 B+ 树的非叶子结点，** 叶子节点中存放整张表的记录数据(数据页)， 聚簇索引的特性决定了索引组织表中数据也是索引的一部分，每个数据都通过一个**双向链表**来进行连接；
- 非叶子结点存储的键值对 <主键，数据页号>，叶子结点存储的是完整的行记录；
- 一个表只能有一个聚簇索引，因为一个表的物理顺序只有一种情况，并且多数情况下查询优化器都倾向于采用，因为可以直接在其叶子节点上找到数据；

###### 02：辅助索引

- 辅助索引：叶子节点不包括行记录的全部数据， **叶子节点除了包含键值以外，每个叶子节点中还包含了一个指针，指向聚簇索引中的主键（回表），** 然后再通过主键索引来找到一个完整的记录；

###### 03：联合索引

- 联合索引也是一棵 B+ 树，不同的是联合索引的键值数量大于 1，此外，逻辑上和单键值的 B+ 树并没有什么区别，键值依旧是有序的，只不过这个有序是一个前提的，遵循**最左前缀匹配原则**；

<img src="https://github.com/likang315/Middleware/blob/master/09：MySQL/photos/联合索引.png?raw=true" style="zoom:30%;" />

- 联合索引的规则
  - 对第一个字段的数据进行排序，在第一个字段的有序基础上，然后若第一个字段相等，再对第二个的字段进行排序，**a 是全局有序的，b 是局部有序；**可以通过执行计划的 **key_len** 知道有没有使用二级索引；
  
  - 最左前缀匹配原则**遇到范围查询就会停止，但是 >=、between、like前缀匹配的范围查询，并不会停止**。
  
  - | 联合索引 (a，b, c)                                        | 索引字段是否用到 |
    | :-------------------------------------------------------- | ---------------- |
    | select * from stu where a=xx and b=xx;                    | a 和 b 都用到    |
    | select * from stu where b=xx and a=xx；                   | a 和 b 都用到    |
    | select * from stu where a > xx and b=xx； **索引下推**    | a 用到           |
    | select * from stu where a = 1 and c = 3;     **索引下推** | a 用到           |
    | select * from stu where a >= xx and b=xx； (包含就会用到) | a 和 b 都用到    |
    | select * from stu where a BETWEEN xx AND xx AND b=xx；    | a 和 b 都用到    |
    | select * from stu where a LIKE 'x%' and b=xx；            | a 和 b 都用到    |
  
- **索引下推**（Index Condition Pushdown：ICP）
  
  - 下推：指将部分上层（Server）负责的事情，交给了下层（存储引擎）去处理。MySQL 5.6 开始引入；
  - 在联合索引遍历过程中，对于联合索引中包含的字段判断，**不需要每次回表查询完整记录**，交给 Server 层判断，存储引擎根据联合索引直接判断过滤，减少回表次数；
  - Using index condition：证明使用了索引下推；
  
- **索引区分度**
  
  - 建立联合索引时，要**把区分度大的字段排在前面**，这样区分度大的字段越有可能被更多的 SQL 使用到。
  - 区分度不高时，一般会忽略索引，进行全表扫描；
  

###### 04：覆盖索引

- 它包含了查询语句中所需要的所有字段，**直接从覆盖索引中查询记录并返回**(如果有的话)，而不需要再查询聚簇索引中的记录，使用覆盖索引的好处是**它不包含整行记录的所有信息**，故其大小要远小于聚簇索引，因此可以**减少大量的 IO 操作**；

##### 07：MySQL 为啥选用 B+ 数

1. B+树的**更加矮胖，IO次数少**，磁盘读写代价更低；
   - B树 每个节点中不仅存储索引信息，还存储了存其对应的数据，因此B树的高度更高；
2. B+树的数据信息遍历更加方便，**支持范围查询**【双向链表】
   - B+树只要遍历叶子节点就可以实现整棵树的遍历，而B树不支持这样的操作，而且在数据库中基于范围的查询是非常频繁的，所以数据库索引基本采用B+树；
3. B+树的**查询效率稳定**
   - 任何关键字的查找必须走从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；

##### 08：索引失效

​	用 EXPLAIN 查看SQL执行计划时，发现优化器并没有选择索引，而是执行全表扫描，这种情况多发生于关联查询 JOIN 连接等场景。

1. 联合索引的使用不符合最左前缀匹配原则

2. OR 条件连接的多个条件中**有不走索引的字段**

3. LIKE 查询**前缀模糊匹配**；

   - 表中只有两个字段（id + 索引字段）时，会走覆盖索引，进行全表扫描；

4. 索引区分度不高时，InnoDB 评估使用全表扫描比走索引更快；

5. 对索引字段进行隐式转换；

   - MySQL 在遇到字符串和数字比较的时候，会自动把**字符串转为数字**，然后再进行比较。若是变化的是索引字段，则使用了函数，则索引失效；

   - ```sql
     select * from t_user where CAST(phone AS signed int) = 100; 失效
     select * from t_user where id = CAST("1" AS signed int); 不会失效
     ```

6. 表数据太少；

7. 大字段应该不建索引，会导致索引层级变高，IO 次数变多；

##### 09：索引的效率

- 查找效率高：因为索引表按照索引的字段有序排列的，是一种**有序读**，而不是随机读；
- 插入，删除效率低：当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度，而且索引也是非常消耗内存的；

##### 10：索引的类型

- INDEX 普通索引：添加索引的字段，允许出现相同的值；
- UNIQUE 唯一索引：不允许出现相同的值，可以有NULL值；
- PRIMARY KEY 主键索引：不允许出现相同的值，且不能为NULL值，一个表只能有一个primary_key索引；
- fulltext index：全文索引；

######   创建索引

- CREATE INDEX：只能对表增加普通索引或UNIQUE索引；
- **CREATE INDEX index_name ON table_name (column_name)**
- CREATE UNIQUE INDEX index_name ON table_name (column_name)

###### 修改索引

- ALTER TABLE 表名 ADD 索引类型 （unique,primary key,fulltext,index）索引名（字段名，字段名），ADD ...
  - 只能重新添加，不能修改；
- ALTER TABLE table_name **ADD INDEX index_name  (column_list)**；
  -  索引名,可要可不要;如果不要，该字段名就是索引名

######   删除索引

- ALTER TABLE table_name **DROP INDEX index_name**；
- ALTER TABLE  table_name **DROP PRIMARY KEY；** 
  - 删除主键索引，注意主键索引只能用这种方式删除；

######   查看索引

- show index from tablename;
  - Non_unique：不是唯一索引为1，否则0；
  - Key_name：索引名称，若名字相同则是同一个索引；
  - **Seq_in_index：联合索引中的序列号，若是单列索引则是1；**
  - **Collation**：指的是列以什么方式存储在索引中，A表示升序，B表示降序，NULL表示未排序；
  - **Cardinality**：表示索引中**唯一值的数目的估计值**，值越小，则需要重新评估这个字段是否适合建立索引；
  - Sub_part：前置索引，如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL；
  - **Index_type**：表示索引类型，主要有以下几种索引类型：FULLTEXT，HASH，**BTREE**，RTREE；


###### 强制使用索引

- FORCE INDEX （索引字段名）
- EXPLAIN SELECT * from local_student_info **FORCE INDEX (idx_class_id)**  WHERE class_id <> '10001' ;

##### 11：EXPLAIN（SQL执行计划）

查看运行SQL语句时哪种策略预计会被优化器采用，查看有没有走索引

```shell
# EXPLAIN select * from student;
| id | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra										
|  1 | SIMPLE      | t1    | index | PRIMARY       | name | 63      | NULL |    4 | Using where; Using index |
```

1. ###### id：包含一组数字，表示查询中执行 select 子句 或 操作表的顺序	

   - id相同，执行顺序由上至下
   - id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，先执行

2. ###### select_type 示查询中每个select子句的类型（简单OR复杂）

   - **SIMPLE：**查询中不包含子查询或者UNION；
   - **PRIMARY：**查询中若包含任何复杂的子部分，最外层查询被标记；
   - **SUBQUERY：**在SELECT或WHERE列表中包含了子查询，该子查询被标记；
   - **DERIVED（派生）：**用来表示包含在from子句中的子查询语句
   - 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED 
   - 从UNION表获取结果的SELECT被标记为：UNION RESULT

3. ###### table ：执行SQL用到的表名

4. ###### type ：表示MySQL在表中找到所需行使用的方式，又称“访问类型”

   - ALL, index, **range, ref, eq_ref, const**, system, NULL，从左到右，性能从最差到最好
     - ALL：全表扫描；
     - index：通过索引表，全表扫描；
     - range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的；
     - ref：**使用非唯一索引扫描或者唯一索引的前缀扫描**，返回匹配某个单独值的记录行；
     - eq_ref：使用主键或唯一索引时产生的访问方式，通常使用在多表联查中；
     - const：表示使用了主键或者唯一索引与常量值进行比；
     - NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引（覆盖索引）；

5. ###### possible_keys ：

   - 指出MySQL**可能使用哪个索引**在表中找到记录的，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用；

6. ###### key：

   - 显示MySQL在查询中**实际使用的索引**，若没有使用索引，显示为NULL

7. ###### key_len：

   - 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）

8. ###### ref：

   - 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

9. ###### rows：

   - 估算的找到所需的记录所需要读取的行数

10. ###### Extra：

    - 包含不适合在其他列中显示但十分重要的额外信息
    - **Using index：**该值表示使用了覆盖索引，不需要回表；
    - **Using where：**表示 mysql 服务器将在存储引擎检索行后再进行过滤
    - **Using filesort**：表示查询语句中包含 group by 操作，无法利用索引完成排序操作的时候，不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的；
    - **Using temporary：**表示 MySQL 需要**使用临时表来存储结果集**，常见于排序和分组查询

##### 12：主键

- 若没有显示的定义主键，会选择**第一个不为 NULL 的唯一索引**作为主键，若没有，则存储引擎会为每一行生成 **6 个字节的 RowID** ，并作为主键，主键不可能无限增长，有界限，分表分库；

###### 自增主键

- InnoDB 使用聚簇索引，数据记录本身被存于主索引 (一颗B+Tree) 的叶子节点上。这就要求同一个叶子节点内的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会**根据其主键将其插入适当的节点和位置**，如果页面达到**装载因子**(Inno DB默认为15/16)，则开辟一个新的页(节点)。这样就会形成一个紧凑的索引结构，由于每次插入时也不需要移动已有数据，因此效率很高。也不会增加很多开销在维护索引上；
- **页分裂：**若使用**非自增主键**，由于每次插入主键的值近似于随机，因此每次新记录都要被插到现有索引页得中间某个位置，此时 MySQL 不得不为了**将新记录插到合适位置而移动数据**，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，**同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构**，后续不得不通过 **OPTIMIZE TABLE** 来重建表并优化填充页面；

###### 步长和初始值

- 目的：当数据出现错乱时，我们需要将备份的数据和线上的**数据进行对比**；
- SHOW GLOBAL VARIABLES LIKE 'auto_inc%';
  - 查看步长；
- SET @auto_increment_increment=1;
  - 设置步长；
- auto_increment_offset：表示自增长字段从那个数开始，取值范围是[1,65535]；
- auto_increment_increment：表示自增长字段每次**递增的量**，**默认值是1**，取值范围是[1,65535]；

###### 自增ID用完

- 因为业务表频繁的删除插入数据，为了防止自增ID用完，定时任务修改自增开始初始值；【不唯一】

  ```sql
  ALTER TABLE 表名 AUTO_INCREMENT = 1; 
  ```

- 两个表交换写，使用TRANCATE 清表；

##### 05：日志文件

1. **错误日志(Error Log)** 
   - 错误日志对 MySQL 的启动、运行、关闭过程进行了记录, 不仅**记录了所有错误信息，也记录了一些警告信息**，遇到问题是应该首先查看该文件以便定位问题。当 MySQL 不能正常启动，或者 MySQL 在运行期间遇到的内存不足等问题都可以在其中找到详细记录。
2. **慢查询日志(Slow Query Log)** 
   - 慢查询日志能够定位到可能存在问题的 SQL 语句, 可以**设定一个阈值，将运行时间超过该值的 SQL 语句都记录到慢查询** 日志文件中。另一个可用的参数是 log_queries_not_using_indexes，如果SQL 语句没有使用索引，同样会将这条 SQL 语句记录到慢查询日志文件。
3. **查询日志(Query Log) ** 
   - 查询日志记录了所有对 MySQL 请求的信息（对数据库没有修改的数据）, 不论是否得到了正确的执行。默认文件名: 主机名.log；
4. **二进制日志(Binary Log)** 
   - BinLog **记录了对 MySQL 执行更新的 (不包括SELECT 和 SHOW 等对数据本身没有修改) 的操作**。 不过若⼀个修改操作本身没有导致数据库发生变化也会被写入 Bin Log 中(如修改了一条不存在的记录)。此外，二进制日志还包括了DB 修改操作的时间以及其他额外信息；
   - 主从复制的 bin log，有**三种格式**
     - statement：记录修改的Sql语句
     - row：记录每行记录实际数据的变更
     - mixed：两种混合模式
   - 在 statement 格式下，读已提交这种隔离级别的主从复制，会出现错误的（master上执行先删后插，slave执行的是先插后删），会导致主从不一致，选用 **row 作为 binlog  的格式**
   - Bin Log 主要用途有: 
     1. 数据恢复（Recovery）：数据的恢复需要 Bin Log；
     2. 集群同步（Replication）：通过复制和执行 BinLog，使一台远程的 MySQL 从库与当前主库进行实时同步；
     3. 数据检查（audit）：可以通过 Bin Log 信息，检查是否有对数据库注入的攻击；

