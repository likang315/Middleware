### Transaction

------

[TOC]

##### 01：数据库并发问题

1. **更新丢失：**加锁（行级共享锁），必须等待事物执行完成之后，另一个事物才可以进行；
   1. 回滚丢失：一个写事务成功的时候，另一个事务写失败了，导致了回滚，读已提交解决
   2. 覆盖丢失：一个成功的事务，覆盖了另一个成功的事务的结果，可重复读解决
2. **脏读：**一个事物读到了另一个事物未提交的数据（脏数据）；
   - 读已提交解决；
3. **不可重复读：**在第一个事物中两次读数据之间，由于第二个事物的修改，导致**两次读到的结果不一致**；
   - 是一种**当前读**；
4. **幻读：**同一个事物，**前后两次读取行数不一致**；
   - 在可重复读隔离级别下，**普通查询是快照读**，是不会看到别的事务插入的数据的，幻读只在**当前读**下才会出现；
   - 幻读专指新插入的行，读到原本存在行的更新结果不算。因为**当前读**的作用就是能读到所有已经提交记录的最新值；

##### 02：事务

- 访问并更新数据库中各种数据项的**最小执行单元**；

###### ACID

1. **原子性(Atomic)：**是一个不可分割的执行单元，要么全部完成，要么全部不完成；
   - Undo log 保证；

2. **一致性(Consistency)：**数据库的角度，数据库从一种一致性状态到另一种一致性状态；
   - 通过 原子性 + 隔离性 + 持久性来保证；
3. **隔离性(Isolation)：**事物之间相互隔离；
   - 由锁 和 MCVV 来实现
4. **持久性（Durabiliy）**：事物一旦提交，持久化到磁盘中；
   - 由 Redo Log 实现

##### 03：事物的实现

1. ###### Redo Log (重做日志）：用来实现事务中的持久性, 由两部分组成：

   - 内存中的重做日志缓冲(redo log buffer) ；
   - 磁盘中的重做日志文件(redo log file) ，其是持久的；
   - 当事务提交时，必须先将该事务的所有日志落盘到重做日志文件进行持久化，待事务提交结束才算完成；

2. ###### Undo Log（回滚日志）：记录了事务的行为, 可以对页进行 "回滚" 操作；

   -  undo log 存放在数据库内部的 undo 段中，位于共享表空间；
   - 回滚日志的主要工作是将数据库数据恢复到原来的样子，但数据结构和页本身在回滚之后可能和事务开始前不太相同，因为与此同时有大量的并发事务存在，不能简单的将一个页回滚到事务开始时的样子，否则会影响其他事务，恢复行记录；

##### 04：事务隔离级别

- 事务的隔离级别：是指多个并发事务之间相互隔离的程度。隔离级别越高，性能越差；
- 隔离级别有 4 个，由低到高依次为 
  1. Read uncommitted
     - 一个事务还没提交时，它做的变更就能被其他事务看到；
  
  2. Read committed
  
     - 一个事务提交之后，它做的变更才能被其他事务看到；
     - 解决更新丢失，脏读；
     - 通过**加共享锁**解决；
  3. Repeatable read
  
     - 一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**默认的隔离级别；**
     - 解决不可重复读；
  4. Serializable
  
     - 串行化，对**记录加上读写锁**，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；
     - 幻读；

##### 05：事务的实现方式

1. begin/start transaction 命令；
   - 执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机。
2. start transaction with consistent snapshot 命令；
   - 执行了 start transaction with consistent snapshot 命令，立刻启动事务。

##### 06：Read View（数据快照）

###### 事务 ID 字段

- **m_ids ：**指的是在创建 Read View 时，当前数据库中活跃事务的**事务 id 列表**，注意是一个列表。
  - 活跃事务：指启动了但还没提交的事务。
- **min_trx_id：**指的是在创建 Read View 时，当前数据库中活跃事务中事务 **id 最小的事务**，也就是 m_ids 的最小值。
- **max_trx_id：**这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**。
- **creator_trx_id：**指的是创建该 Read View 的事务的事务 id。

###### 不同隔离级别下的工作原理

- 读已提交下：**事务每次读数据时都重新创建 Read View**，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
- 可重复读：启动事务时生成一个 Read View，通过对比事务 ID 大小，判断最新版本是否对事务可见；

###### 多版本并发控制技术（MVCC）

- MVCC 通过维护多版本数据，保证一个读事务永远不会被阻塞，一条记录维护有多个版本，Undo log 链；
- MVCC 优缺点
  - 代替了行锁，实现了对读的非阻塞（非锁定读），读写不冲突，缺点是**每行记录都需要额外的存储空间**，需要做更多的行维护和检查工作；

##### 07：幻读【重要】

- 可重复读隔离级别下，并没有彻底解决幻读，只是用 MVCC 避免了部分幻读；
- 串行化：若需完全避免，需要**手动加锁将快照读调整为当前读，使用 next-key 完全避免了幻读；**

###### 出现幻读的场景

1. 查询之后，更新，再查询；
2. 先不加锁，后加锁；
   - T1 时刻：事务 A 先执行快照读语句：select * from test where id > 100 得到了 3 条记录。
   - T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；
   - T3 时刻：事务 A 再执行**当前读语句**： select * from test where id > 100 for update 就会得到 4 条记录；

##### 04：主从复制

![](https://github.com/likang315/Middleware/blob/master/09：MySQL/photos/主从复制.png?raw=true)

- 从库生成两个线程，**一个IO线程，一个SQL线程**
- 主库会通过**bin log 记录每行实际数据的变更**，IO 线程去请求 主库 的bin log，主库会生成一个 **log dump 线程**，用来给从库 IO 线程传bin log，从库将得到的 bin log日志**写入 Relay log（中继日志） 文件中**，**SQL 线程负责读取**Relay log文件中的日志，并解析成具体操作，来实现主从的数据一致；

###### 两种复制的方式

1. 异步复制原理
   - 主库**提交事务后，立即返回客户端**，它的同步是当有从库的I/O线程请求才传送 Bin log 的。
2. 半同步复制原理
   - 主库在执行完客户端提交的事务后不是立刻返回给客户端，而是**等待至少一个从库接收并写到relay log中才返回给客户端**，相对于同步复制，半同步复制提高了数据的安全性，同时它也会导致性能下降； 

###### 主从复制优缺点

1. 灾容性好，用于故障切换、恢复数据库；
2. 读写分离，提供查询服务，降低主库负载；
3. 从库**只有一个sql Thread**，主库写压力大，复制很可能延时，通过并行复制解决；

######  主从库架构

1. 一主一从
2. 一主多从，读是在从库读取的
3. 主主复制
4. 多主一从
5. 联级复制

