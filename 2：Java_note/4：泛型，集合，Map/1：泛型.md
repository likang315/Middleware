### 泛型：参数化类型 ----- 给类加参数，达到动态的确定类型的目的

### JVM泛型的擦除机制：

Java中的泛型，只在编译阶段有效，泛型信息不会进入到运行时阶段
在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加**类型检查和类型转换的方法**

##### 通配符：?   ----------------- 通配符用来表未知类型



### 上下边界问题

**？extends E ：向上限定**，？代表E及其子类，也可以称之为：**泛型固定上边界**
	因此你做添加操作的时候,你只知道,你添加数据的上限。但是你无法确定你要添加数据的下限，因此无法添加数据
**？super E ：向下限定**，    ？代表E及其父类 **(泛型固定下边界)**   在做添加的时候是不会有问题的
	因为：泛型的下边界,已经限制。再向集合中添加数据,只能是其本身或者他的子类



### 泛型（类，抽象类，接口）：

##### 泛型类：在实例化类的时候指明泛型的具体类型

```java
泛型类：public static class Person<T>
	 {  
                private T ob; 			// 定义泛型属性  
                public Person(T ob) 
                {  
                    this.ob = ob; 
                } 
   	 } 	 
例：
Person<Integer> Ob = new Person<Integer>(100);  //T的实际类型是整型
```

##### 泛型接口：

```java
public interface Animal <T>{

}
```

​1:当实现泛型接口的类，未传入泛型实参时，与泛型类的定义相同，在声明类的时候，**需将泛型的声明也一起加到类中**

​	例：
​		public class A<T> implements Animal<T>{

​		}

2:实现泛型接口的类，传入泛型实参时，则**所有使用泛型的地方都要替换成传入的实参类型**

​	例：
​		public class A  implements Animal<String>{

​		}

##### 泛型方法：public <T> void method(E e ) ;

public 与 返回值中间<T>非常重要，可以理解为**声明此方法为泛型方法，只有声明了<T>的方法才是泛型方法，**
泛型类中的使用了泛型的成员方法并不是泛型方法

​	

##### 注意：

​	1：泛型的类型参数只能是**类类型，因为传递的是对象**
​	2：泛型的类型参数可以有多个
​	3：不能对确切的泛型类型 使用 instanceof 操作
​	4：**使用通配符创建泛型数组**是可以的
​		例:List<?>[] ls = new ArrayList<?>[10];  


