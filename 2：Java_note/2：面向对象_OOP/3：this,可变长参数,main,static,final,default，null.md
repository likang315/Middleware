### 1：main 方法（主方法）：

**类的入口点，定义了程序从何处开始，java编译器通过方法来执行程序**

1：主方法是静态的，所以如果要在主方法直接调用方法时 ，必须是静态的

2：形参为String数组，可以在Run as 中传递参数，每个参数用enter键隔开
	public static void main(String args[])

### 2：可变长参数：

**本质是一个数组，所有的实参，都被保存到一个和形参同名的数组里，然后像操作数组的方式操作可变长参数**

```java
public void a(int... ints){ //数据类型+...

}
```

###### 可变长参数的使用规则：

1：一个方法只能有一个可变长参数，并且这个可变长参数必须是该方法的最后一个参数

2：在编译器中，实参个数可变的方法是最后带了一个数组形参的方法的

3：在调用方法的时候，如果能够和固定参数的方法匹配，也能够与可变长参数的方法匹配，则选择固定参数的方法

4：如果要调用的方法可以和两个可变参数匹配（就是另一个方法中也有可变长参数），则出现错误，因为系统不知道调用那个方法

```java
	      public void print(String... args) 
          {
	          for (int i = 0; i < args.length; i++) 
              {
	        	  System.out.println(args[i]);
	          }
	      }
```



### 3：this  关键字 ：

**代表本类对象的调用，被隐式地用于引用对象的成员变量和方法**

使用范围：在本类中才有 this 而言，脱离本类 this 无意义

使用方法：（this 引用的就是本类的一个对象）
	1：通过this**访问属性**( this. +... )--------区别属性和形参同名问题（此时指向当前创建的对象），用在get，set函数
	2：通过this**访问构造方法**( this（）)----减少重复代码的出现（此时指代当前类）----此时必须在本构造方法的第一行
 	3：this 还可以作为**方法的返回值**，返回一个对象

方法：必须是实例方法，静态方法没有 this 说法-----在方法中this指代的是当前调用这个方法的对象

```java
public world(String name,char sex) {//形式上的并没有真正地创建
	this();//构造方法，创建
	this.sex=sex;
}

public world (String name) {
	this.name=name;
}		
```



### 4：super 关键字 ：

super关键字代表了**当前父类对象的引用**

###### super关键字的作用：

1：子父类存在着同名的成员时，在子类中默认是访问子类的成员，可以**通过super关键字指定访问父类的成员**

2：创建子类对象时，**默认会先调用父类无参的构造方法**，可以通过 super 关键字指定调用父类的构造方法

###### super 关键字调用父类构造方法特点：

1：如果在子类的构造方法上没有指定调用父类的构造方法，那么java编译器会在子类的构造方法上面加上super()
	即调用无参构造，super(18,23,34)，即调用父类的有参构造
2：super关键字调用父类的构造函数时，该语句必须要是**子类构造函数中的第一个语句**

3：super 与 this关键字**不能同时出现在同一个构造函数**中调用其他的构造函数。语法上因为两个语句都需要第一个语句

   super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）
   this（参数）   ：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）



### super 关键字 与 this 关键字的区别：

###### 1：代表的事物不一致

​		super关键字代表了父类的引用或者父类对象的引用

​		this关键字代表的是本类对象引用

###### 2：使用前提不一致

​		super关键字必须要有继承关系才能使用

​		this关键字在本类中使用

###### 3：调用构造函数的区别

​		super关键字是调用父类的构造函数

​		this关键字是调用本类的构造函数



### 4：static：静态修饰符

###### 1：静态可以修饰，常量，方法，类， 会放到内存区域的方法区

###### 2：静态属于类所有，可以使用访问   类名.静态成员名

3：虽然静态成员也可以通过对象调用，但是不建议以这样的形式调用， 会让人混淆静态和非静态成员，直接通过类名调用 

###### 4：静态成员中不可以使用this关键字

5：静态只能访问静态的

###### 6：static修饰的方法可以被继承，不能被重写

 静态数据成员：类变量
 静态方法：方法的参数仅与参数有关和对象无关，属于类的
 静态块：用来初始化静态资源（图片，视频，音频）
 静态内部类：不依赖外围类的对象

#####   父类的 static 成员变量术语当前类，子类不接访问



### 5：final：不可变的

**用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，被其修饰的类不可继承**

### 类 ：该类不能是抽象类，不能被继承

方法：该方法不能定义成抽象方法，不能被重写和覆盖
变量：该变量就会被变为常量，用final定义常量时使用大写字母，不可改变
对象：final对象的引用只能恒定指向唯一一个对象

###### 注意：final 修饰的属性必须在对象存在时给定值，或者必须在声明时给值或者在构造方法给值，

在声明时给值，产生的对象的该变量的值全部相等并且不能改变，在构造方法中赋值，产生的结果是不同的对象可以有该变量的不同值并且不能改变

###### 常用：static final 类型 常量 = 初始值；

static与final联合使用时必须在声明时赋值-----因为static在声明是共享的，而且final不可被二次赋值，如果不在初始化时赋初值，则变量的值一直是默认值，并且不会改变

如果在声明时没有赋值，称为空白final



### 6：default：

**关键字，只能用于修饰接口中声明的方法，java 8 新特性**

特性：被default关键字修饰的方法，必须有方法体，也可以被重写

### 7：null 关键字

​	1：null 是Java中的关键字,它不属于任何类型,只是一种特殊的值

​	2：可以强转为任何包装器类型，调用静态方法（只能）

​	3：null==null 返回true,被转换为同种类型的null,都返回true,不同类型直接编译报错

​	4：可以对String类型，进行拼接运算

编译器对null进行了特别的优化,其实就是实例化StringBuilder,在调用append()方法时对null的一个特别处理,当为null时,转化为“null”,最后调用toString()返回一个String对象

​	5：用八大基本类型转换后的null,不可以进行基本类型的运算,否则会出现编译或者运行错误

### 8：instanceof

通过返回一个布尔值来指出，这个对象**是否是这个特定类或者是它的子类的一个实例**

用法： 

###### 	result = object instanceof class 

参数： 
	Result：布尔类型。 
	Object：任意对象表达式。 
	Class： 任意已定义的对象类。 
说明： 

**如果 object 是 class 的一个实例，则 instanceof 运算符返回 true。如果 object 不是指定类的一个实例，或者 object 是 null，则返回 false**

### instanceof 在Java的 编译状态和 运行状态是有区别的：

在编译状态中，class可以是object对象的**父类，本生类，子类**在这三种情况下Java编译时不会报错。

在运行转态中，class可以是object对象的**父类，本生类，不能是子类**，在前两种情况下result的结果为true，最后一种为false，但是class为子类时编译不会报错。运行结果为false

