### Redis 应用场景

------

[TOC]

##### 01：缓存

- 相比基于内存的 Redis，基于磁盘存储的关系型数据库读取⽤时会⾮常⻓，主要有⼀下⼏个原因:
  1. Redis 的数据存储在内存中，RDS 的数据主要存储于磁盘；
  2. Redis 的查询⽅式是 Hash，效率接近于 O(1), ⽽ RDS 的查询⽅式是 B+Tree；
  3. Redis 只缓存热点数据，并且存在过期时间和内存淘汰，注定数据量⼩, ⽽ RDS 需要存储全量数据；

##### 02：缓存雪崩、缓存击穿、缓存穿透

- **缓存雪崩**：当**缓存服务器宕机或者大量缓存集中在某一个时间段失效**，这样在失效的时候，也会给后端系统(比如DB)带来很大压力；
- **缓存击穿**：跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，**而缓存击穿是一个热点的Key失效**，有大并发集中对其进行访问，突然间这个Key失效了，导致大量请求全部打在数据库上，导致数据库压力倍增；
  - 微信公众号获取token；
- **缓存穿透**：发送的请求**传进来的key是不存在Redis中的**（永远不存在），那么就查不到缓存，查不到缓存就会去数据库查询，导致数据库压力倍增，这些请求**像“穿透”了缓存**一样直接打在数据库上；
  - 这和缓存击穿有根本的区别，区别在于**缓存穿透的情况是传进来的key在Redis中是不存在的**。

###### 解决雪崩：

- 惰性删除、定期删除【贪心策略】；
- 熔断机制；

###### 解决击穿

1. 业务允许的情况下，**热点key永不过期**；

2. **redis 使用分布式锁**，SETNX，是「SET if Not Exists」的缩写，也就是只有不存在的时候才设置，只有获得所得线程才可以查询数据库；

3. ```java
   public String get(key) {
       String value = redis.get(key);
       // 代表缓存值过期
       if (value == null) {
           // 设置3min的过期时间，防止del操作失败的时候，下次缓存过期一直不能load db
           if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {
               // db 获取value
               value = db.get(key);
               redis.set(key, value, expire_secs);
               redis.del(key_mutex);
           } else {
               // 代表同时其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
               sleep(50);
               // 重试
               get(key);
           }
       } else {
         	return value;      
       }
   }
   ```

###### 解决穿透

1. 布隆过滤器提前拦截；
   - 通过布隆过滤器查询元素存在不存在，**在查询的时候先去布隆过滤器查询 key 是否存在**，如果不存在就直接返回；
   - 由一个固定大小的二进制向量或者位图（bitmap）和一系列映射函数组成的； 
     - 如果这些点有任何一个 0，则被查询变量一定不在；
     - 如果都是 1，则被查询变量很**可能存在**，因为映射函数本身就是散列函数，**散列函数是会有碰撞的**；
2. 把无效的Key存进Redis中；
   - 如果Redis查不到数据，数据库也查不到，我们**把这个Key值保存进Redis，设置value="null"**，这种处理方式肯定是有问题的，假如**传进来的这个不存在的Key值每次都是随机的**，那存进Redis也没有意义。

##### 03：缓存不一致

- 查询线程与更新线程冲突：使用 setnx 分布式锁防止冲突；
  - 查询线程**回写缓存的时候**，把更新线程的缓存数据覆盖，因此查询线程**在回写缓存的时候，使用分布式锁来防止覆盖**；
- 查询线程与删除线程冲突：delete标记；
  - 查询线程**回写缓存的时候**，覆盖了删除线程的remove操作，因此删除的时候，不是物理删除缓存数据，而是为缓存数据打上delete 标识，查询线程依然使用分布式锁来防止覆盖；
  - 如果查询线程从缓存中**查出带delete的数据，则认为该数据不可用，当做没有命中处理；**

##### 04：分布式锁

- 分布式锁的本质是在 Redis 中 **设置⼀个标识, 当其他进程试图来访问的时候, 发现已经有标识, 代表该资源已被锁住**, 就需要**放弃或者重试**；

- SETNX：（ET if Not eXists）

  - 语义：key存在的情况下，不操作redis内存；也就是返回值是0；

  - ```java
    // 返回值result ：设置成功，返回 1 。设置失败，返回 0 
    Long result = jedis.setnx(key, seconds, value);
    ```

- 使⽤ **setnx(set if not exists) 指令,** 只允许被⼀个客户端占领, 当使⽤完毕后, 再调⽤ del 指令释放，但以上的⽅式存在⼀个问题, 如果逻辑执⾏中**出现了异常, 可能会导致 del 指令没有调⽤**, 锁永远就没有机会得到释放，因此在拿到锁之后, 再**给锁加上⼀个过期时间**, 即使出现异常也可以保证 5 秒之后锁⾃动释放，但是如果在加锁和释放锁之间的逻辑执⾏太⻓, 以⾄于超出了锁的超时限制, 就会**导致多个线程重新获取这把锁, 导致临界区代码不能得到严格的串⾏执⾏**，为了避免这个问题, Redis 分布式锁不要⽤于较⻓时间的任务。

- 下单，减库存；

##### 05：计算器

- 统计浏览次数等；

##### 06：排行榜

- ZSet，谁得分高谁排名往上；

