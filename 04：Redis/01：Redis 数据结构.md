### Redis：

------

[TOC]

##### 01：概述

- Redis 是一个开源的使用C语言编写、遵守BSD协议、支持网络、**基于内存亦可持久化的日志型、Key-Value 数据库**，并提供多种语言的API，通常被称为数据结构服务器；
- redis 作为内存数据库，所有数据都**保存在内存中**, 一旦程序停止工作，数据都将丢失，需要我们重新从其他地方加载数据，不过Redis提供了两种方式保存Redis中的数据；
  1. dump.rdb 快照，把内存信息**持久化磁盘**上；
  2. 一种是**存储到AOF文件中**，aof 文件存储的是一条一条存储和修改数据的命令，类似mysql的二进制日志；

###### redis 特性

- Redis 支持**数据的持久化**，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用；
- Redis **数据结构丰富**，不仅仅支持的 key-value 类型的数据，还提供list，set，zset，hash等数据结构的存储；
- Redis 支持数据的备份，即 **master-slave （一主多从）模式的数据备份**；
- Redis 的单个操作都是原子性的，要么成功要么失败，**单个操作是原子性的。多个操作支持事务，但不是原子性**，通过MULTI和EXEC指令包起来；

###### Value 的数据结构【五种】

1. String（字符串）
2. Hash（哈希）
3. List（列表）
4. Set（集合）
5. Zset  (有序集合)

##### 02：String【简单动态字符串 SDS】

###### SDS 的定义

- ```c
  # sds.h/sdshdr
  struct sdshdr {
      // 记录 buf 数组中已使用字节的数量,等于 SDS 所保存字符串的长度
      int len;
      // 记录 buf 数组中未使用字节的数量（空闲）
      int free;
      // 字节数组，用于保存字符串
      char buf[];
  };
  ```

![SDS](/Users/likang/Code/Git/Middleware/04：Redis/photos/SDS.png)



###### SDS 与C 字符串的区别

1. O(1) 的时间复杂度获取字符串长度，C 遍历是O(n);
2. 杜绝缓冲溢出
   - 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间**是否满足**修改所需的要求， 如果不满足的话， **API 会自动将 SDS 的空间扩展至执行修改所需的大小**， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。
3. 减少修改字符串时带来的内存重分配次数
   - 通过未使用空间， SDS 实现了**空间预分配**和**惰性空间**释放两种优化策略。
   - 空间预分配：执行**增长**操作时，发现空间不足时，进行下列操作，否则直接进行操作；
     - 如果对 SDS 进行修改之后， SDS 的长度（也即是 `len` 属性的值）将小于 `1 MB` ， 那么程序分配和 `len` 属性同样大小的未使用空间， 这时 SDS `len` 属性的值将和 `free` 属性的值相同。
     - 如果对 SDS 进行修改之后， SDS 的长度将大于等于 `1 MB` ， 那么程序会分配 `1 MB` 的未使用空间。
       -  举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `30 MB` ， 那么程序会分配 `1 MB` 的未使用空间， SDS 的 `buf` 数组的实际长度将为 `30 MB + 1 MB + 1 byte` 。
     - 通过这种预分配策略， SDS 将连续增长 `N` 次字符串所需的内存重分配次数从必定 `N` 次降低为**最多 `N` 次**。
   - 惰性空间释放
     - 当 SDS 的 API 需要**缩短** SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是**使用 `free` 属性将这些字节的数量记录起来**， 并等待将来使用；
     - SDS 也提供了相应的API，在需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。

###### 二进制安全

- 所有 SDS API 都会以**处理二进制的方式**来处理 SDS 存放在 `buf` 数组里的数据， 程序不会对其中的数据做任何限制、过滤；
- 字节数组，Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据；
- 通过使用二进制安全的 SDS ， 而不是 C 字符串， 使得 Redis **不仅可以保存文本数据， 还可以保存任意格式的二进制数据**。

###### 兼容部分 C 字符串函数

- 虽然 SDS 的 API 都是二进制安全的， 但它们一样**遵循 C 字符串以空字符结尾的惯例**： 总会在为 `buf` 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 `<string.h>` 库定义的函数。

##### 03：链表（List）

###### 链表和链表节点的实现

- 多个 ListNode 可以通过 `prev` 和 `next` 指针组成**双向链表**；

##### 04：字典（Hash）

- 是一个 String 类型的 key和 value 的映射表（HashMap），底层是**数组 + 链表**；
- 每个 hash 可以存储 2^32-1 键值对（40多亿）

###### 字典的定义

- ```c
  typedef struct dict {
      // 类型特定函数
      dictType *type;
      // 私有数据
      void *privdata;
      // 哈希表
      dictht ht[2];
      // rehash 索引
      // 当 rehash 不在进行时，值为 -1
      int rehashidx; /* rehashing not in progress if rehashidx == -1 */
  } dict;
  ```

  - `type` 属性和 `privdata` 属性是针对不同类型的键值对， 为创建多态字典而设置的；
  - `ht` 属性是一个包含两个项的数组， 数组中的每个项都是一个 `dictht` 哈希表， 一般情况下， **字典只使用 `ht[0]` 哈希表， `ht[1]` 哈希表只会在对 `ht[0]` 哈希表进行 rehash 时使用**。
  -  `rehashidx` ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 `-1` 。

###### 没有rehash的字典

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/dict.png" alt="dict" style="zoom:60%;" />

###### 哈希算法

-  index = hash & dict->ht[x].sizemask;

###### 解决hash冲突

- Redis 的哈希表使用链地址法（separate chaining）来解决键冲突，将冲突结点头插；

###### ReHash

- 是包含两个项的数组，数组中的每个项都是⼀个字典，⼀般情况下，字典只使⽤ ht[0] 字典，ht[1] 只在 ht[0] 进⾏rehash 的时候使用，作为临时载体；

###### Rehash 流程

1. 为字典ht[1] 分配空间，这个hash表的空间取决于要执行的操作，以及ht[0] 当前所包含的键值对的数量（`ht[0].used` 属性的值）；
   - 如果执行扩展操作，那么ht[1]的大小为**第一个大于等于ht[o].used * 2 的  2^n ；
   - 如果执行收缩操作，那么ht[1]的大小是第一个小于等于ht[0].used 的 2^n ；
4. 将保存在ht[0]中的所有键值时rehash到 ht[1] 上，即**重新计算key的哈希值和索引值然后将key放在 ht[1] 对应的位置上**；
3. 当ht[0]包含的所有键值对都迁移到了ht[1]，**释放ht[0]，将ht[1]设置为ht[0]，并在在ht[1]新创建一个空白字典**，为下一次 rehash 做准备；

###### Hash表的扩展与收缩

- 当任意一个条件被满足时， 程序会自动对哈希表执行扩展操作：

  1. 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于`1`；
  2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `5` ；
     - 因为已保存节点数量是包括**冲突的节点数量**，所以已保存节点数量是有可能大于哈希表大小的，所以也就可以达到5。

- 负载因子公式

  ```c
  # 负载因子 = 哈希表已保存节点数量 / 哈希表大小
  load_factor = ht[0].used / ht[0].size
  ```

- 当哈希表的负载因子小于 `0.1` 时， 程序自动对哈希表执行收缩操作。

###### 渐进式 ReHash

- 采取**分而治之**的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个增删改查操作上， 从而避免了集中式 rehash 而带来的庞大计算量（集中式会导致停止服务）；
- 在 rehash 的过程中，程序优先在 ht[0] 中进行查找，如果没有找到，再去 ht[1] 中进行查找，此外，新添加的键值对一律保存在ht[1]中，而ht[0] 不在进行任何添加操作，慢慢变成空表；

###### 渐进式Rehash步骤

1. 为ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个hash表；
2. 在字典中维持一个索引计数器变量rehashidx，并将它设置为0，表示rehash 正式开始；
3. 在rehash期间，每次对字典执行增删改查时，程序**除了执行指定的操作外，还会顺带将 ht[0] 字典在的rehashidx索引上的所有键值对 rehash 到 ht[1] **，rehash 完成后，程序将 rehashidx 值自增1；
   - rehashidx 索引就是ht[0]上的下标，每次rehash一个元素，自增1；
4. 随着字典操作的不断进行，最终有的键值对会被rehash至ht[1]，**这时将rehashidx的值没置为 -1**，表示rehash操作已经完成；

##### 05：整数集合（Set）

- String 类型元素的无序集合；
- 相当于 Java 中的 HashSet，它内部的**键值对是⽆序，并且唯⼀的**，底层实现相当于⼀个特殊的字典，字典中所有的 **value 都是⼀个 NULL**，当集合中的最后⼀个元素被移除后，数据结构⾃动删除，内存被回收；
- Redis 用于保存整数值的集合抽象数据结构，可以保存类型**为 `int16_t` 、 `int32_t` 或者 `int64_t` 的整数值**， 并且保证集合中**不会出现重复元素**。

###### 数据结构

```c
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```

- `contents` 数组是整数集合的底层实现： 整数集合的每个元素都是 `contents` 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。
- 虽然 `intset` 结构将 `contents` 属性声明为 `int8_t` 类型的数组， 但实际上 `contents` 数组并不保存任何 `int8_t` 类型的值 ，`contents` 数组的真正类型取决于 `encoding` 属性的值：
  - 如果 `encoding` 属性的值为 **`INTSET_ENC_INT32`** ， 那么 `contents` 就是一个 `int32_t` 类型的数组， 数组里的每个项都是一个 `int32_t` 类型的整数值 （最小值为 `-2,147,483,648` ，最大值为 `2,147,483,647` ）。

###### 升级

- 每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。

###### 升级过程

1. 根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

###### 升级之后新元素的摆放位置

- 引发升级的新元素的长度总是**比整数集合现有所有元素的长度都大**， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：所以要么最开头，要么最末尾；

###### 示例

- 因为每个元素都占用 `16` 位空间， 所以整数集合底层数组的大小为 `3 * 16 = 48` 位， 整数集合的三个元素在这 `48` 位里的位置，现将类型为 `int32_t` 的整数值 `65535` 添加到整数集合里面；
- 最后， 程序将整数集合 `encoding` 属性的值从 `INTSET_ENC_INT16` 改为 `INTSET_ENC_INT32` ， 并将 `length` 属性的值从 `3` 改为 `4`。
- 因为每次向整数集合添加新元素**都可能会引起升级**， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的**时间复杂度为 O(N)** 。

 <img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/upgrade_01.png" style="zoom:67%;" />

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/upgrade_02.png" style="zoom:67%;" />

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/upgrade_03.png" style="zoom: 67%;" />

###### 优点【两个】

1. 提升整数集合的灵活性；
   - 整数集合可以通**过自动升级底层数组来适应新元素**， 所以我们可以随意地将 `int16_t` 、 `int32_t` 或者 `int64_t` 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。
2. 尽可能地节约内存；

###### 降级

- 整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。

##### 06：压缩列表

- 














##### 06：Zset

- Redis 中最优特色的数据结构，String 类型元素的**有序集合且唯一**；
- 底层实现是：**跳表+Hash，跳表保证有序，Hash保证的查找高效**；
- 该结构中每个元素都会关联一个**double类型的 score** ，redis 正是通过 score 来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但分数(score)却可以重复，**skipList负责实现高性能排序，Hash负责实现高性能查找**；
- ![](https://github.com/likang315/Middleware/blob/master/04%EF%BC%9ARedis/photos/skipList.png?raw=true)

  - **层：**跳表的Level数组，每次创建一个新的结点时，**随机生成[1, 32] 的值作为数组的长度**，即层的高度；
  - **前进指针：**每一层都有一个指向表尾的指针，level[i].forward ，用于从表头方位节点；
  - **后退指针：**backward 用于从表尾方向访问节点；
  - **分值：**用一个double类型的浮点数，跳表中所有节点都按分值的从小到大排序；
  - **成员对象：**是一个指针，指向对象地址；

##### 07：BitMap

- key-value（字符串位图）

- 可以直接对值得bit位操作，大数据查找；

- 示例

  - ```sh
    # 设置值为big（3个字符，一个字符8bit）
    set hello big
    # 获取二进制形式的第1位，即为0
    getbit hello 0
    # 给位图指定索引设置值
    # setbit key offset vlaue
    # 把hello二进制形式的第8位设置为1，之前的ASCII码为98，现在改为99，即把b改为c
    setbit hello 7 1
    # 获取位图指定索引的值
    getbit key offset
    # 获取位图指定范围(start到end,单位为bit，如果不指定就是获取全部)位值为1的个数
    bitcount key [start end]
    ```

    