### Redis：

------

[TOC]

##### 01：概述

- Redis 是一个开源的使用C语言编写、遵守BSD协议、支持网络、**基于内存亦可持久化的日志型、Key-Value 数据库**，并提供多种语言的API，通常被称为数据结构服务器；
- redis 作为内存数据库，所有数据都**保存在内存中**, 一旦程序停止工作，数据都将丢失，需要我们重新从其他地方加载数据，不过Redis提供了两种方式保存Redis中的数据；
  1. dump.rdb 快照，把内存信息**持久化磁盘**上；
  2. 一种是**存储到AOF文件中**，aof 文件存储的是一条一条存储和修改数据的命令，类似mysql的二进制日志；

###### redis 特性

- Redis 支持**数据的持久化**，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用；
- Redis **数据结构丰富**，不仅仅支持的 key-value 类型的数据，还提供list，set，zset，hash等数据结构的存储；
- Redis 支持数据的备份，即 **master-slave （一主多从）模式的数据备份**；
- Redis 的单个操作都是原子性的，要么成功要么失败，**单个操作是原子性的。多个操作支持事务，但不是原子性**，通过MULTI和EXEC指令包起来；

##### 02：简单动态字符串 SDS

###### SDS 的定义

- ```c
  # sds.h/sdshdr
  struct sdshdr {
      // 记录 buf 数组中已使用字节的数量,等于 SDS 所保存字符串的长度
      int len;
      // 记录 buf 数组中未使用字节的数量（空闲）
      int free;
      // 字节数组，用于保存字符串
      char buf[];
  };
  ```

![SDS](/Users/likang/Code/Git/Middleware/04：Redis/photos/SDS.png)



###### SDS 与C 字符串的区别

1. O(1) 的时间复杂度获取字符串长度，C 遍历是O(n);
2. 杜绝缓冲溢出
   - 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间**是否满足**修改所需的要求， 如果不满足的话， **API 会自动将 SDS 的空间扩展至执行修改所需的大小**， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。
3. 减少修改字符串时带来的内存重分配次数
   - 通过未使用空间， SDS 实现了**空间预分配**和**惰性空间**释放两种优化策略。
   - 空间预分配：执行**增长**操作时，发现空间不足时，进行下列操作，否则直接进行操作；
     - 如果对 SDS 进行修改之后， SDS 的长度（也即是 `len` 属性的值）将小于 `1 MB` ， 那么程序分配和 `len` 属性同样大小的未使用空间， 这时 SDS `len` 属性的值将和 `free` 属性的值相同。
     - 如果对 SDS 进行修改之后， SDS 的长度将大于等于 `1 MB` ， 那么程序会分配 `1 MB` 的未使用空间。
       -  举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `30 MB` ， 那么程序会分配 `1 MB` 的未使用空间， SDS 的 `buf` 数组的实际长度将为 `30 MB + 1 MB + 1 byte` 。
     - 通过这种预分配策略， SDS 将连续增长 `N` 次字符串所需的内存重分配次数从必定 `N` 次降低为**最多 `N` 次**。
   - 惰性空间释放
     - 当 SDS 的 API 需要**缩短** SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是**使用 `free` 属性将这些字节的数量记录起来**， 并等待将来使用；
     - SDS 也提供了相应的API，在需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。

###### 二进制安全

- 所有 SDS API 都会以**处理二进制的方式**来处理 SDS 存放在 `buf` 数组里的数据， 程序不会对其中的数据做任何限制、过滤；
- 字节数组，Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据；
- 通过使用二进制安全的 SDS ， 而不是 C 字符串， 使得 Redis **不仅可以保存文本数据， 还可以保存任意格式的二进制数据**。

###### 兼容部分 C 字符串函数

- 虽然 SDS 的 API 都是二进制安全的， 但它们一样**遵循 C 字符串以空字符结尾的惯例**： 总会在为 `buf` 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 `<string.h>` 库定义的函数。

##### 03：双向链表

###### 链表和链表节点的实现

- 多个 ListNode 可以通过 `prev` 和 `next` 指针组成**双向链表**；

##### 04：字典

- 是一个 String 类型的 key和 value 的映射表（HashMap），底层是**数组 + 链表**；
- 每个 hash 可以存储 2^32-1 键值对（40多亿）

###### 字典的定义

- ```c
  typedef struct dict {
      // 类型特定函数
      dictType *type;
      // 私有数据
      void *privdata;
      // 哈希表
      dictht ht[2];
      // rehash 索引
      // 当 rehash 不在进行时，值为 -1
      int rehashidx; /* rehashing not in progress if rehashidx == -1 */
  } dict;
  ```

  - `type` 属性和 `privdata` 属性是针对不同类型的键值对， 为创建多态字典而设置的；
  - `ht` 属性是一个包含两个项的数组， 数组中的每个项都是一个 `dictht` 哈希表， 一般情况下， **字典只使用 `ht[0]` 哈希表， `ht[1]` 哈希表只会在对 `ht[0]` 哈希表进行 rehash 时使用**。
  -  `rehashidx` ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 `-1` 。

###### 没有rehash的字典

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/dict.png" alt="dict" style="zoom:60%;" />

###### 哈希算法

-  index = hash & dict->ht[x].sizemask;

###### 解决hash冲突

- Redis 的哈希表使用链地址法（separate chaining）来解决键冲突，将冲突结点头插；

###### ReHash

- 是包含两个项的数组，数组中的每个项都是⼀个字典，⼀般情况下，字典只使⽤ ht[0] 字典，ht[1] 只在 ht[0] 进⾏rehash 的时候使用，作为临时载体；

###### Rehash 流程

1. 为字典ht[1] 分配空间，这个hash表的空间取决于要执行的操作，以及ht[0] 当前所包含的键值对的数量（`ht[0].used` 属性的值）；
   - 如果执行扩展操作，那么ht[1]的大小为**第一个大于等于ht[o].used * 2 的  2^n ；
   - 如果执行收缩操作，那么ht[1]的大小是第一个小于等于ht[0].used 的 2^n ；
4. 将保存在ht[0]中的所有键值时rehash到 ht[1] 上，即**重新计算key的哈希值和索引值然后将key放在 ht[1] 对应的位置上**；
3. 当ht[0]包含的所有键值对都迁移到了ht[1]，**释放ht[0]，将ht[1]设置为ht[0]，并在在ht[1]新创建一个空白字典**，为下一次 rehash 做准备；

###### Hash表的扩展与收缩

- 当任意一个条件被满足时， 程序会自动对哈希表执行扩展操作：

  1. 服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于`1`；
  2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 `5` ；
     - 因为已保存节点数量是包括**冲突的节点数量**，所以已保存节点数量是有可能大于哈希表大小的，所以也就可以达到5。

- 负载因子公式

  ```c
  # 负载因子 = 哈希表已保存节点数量 / 哈希表大小
  load_factor = ht[0].used / ht[0].size
  ```

- 当哈希表的负载因子小于 `0.1` 时， 程序自动对哈希表执行收缩操作。

###### 渐进式 ReHash

- 采取**分而治之**的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个增删改查操作上， 从而避免了集中式 rehash 而带来的庞大计算量（集中式会导致停止服务）；
- 在 rehash 的过程中，程序优先在 ht[0] 中进行查找，如果没有找到，再去 ht[1] 中进行查找，此外，新添加的键值对一律保存在ht[1]中，而ht[0] 不在进行任何添加操作，慢慢变成空表；

###### 渐进式Rehash步骤

1. 为ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个hash表；
2. 在字典中维持一个索引计数器变量rehashidx，并将它设置为0，表示rehash 正式开始；
3. 在rehash期间，每次对字典执行增删改查时，程序**除了执行指定的操作外，还会顺带将 ht[0] 字典在的rehashidx索引上的所有键值对 rehash 到 ht[1] **，rehash 完成后，程序将 rehashidx 值自增1；
   - rehashidx 索引就是ht[0]上的下标，每次rehash一个元素，自增1；
4. 随着字典操作的不断进行，最终有的键值对会被rehash至ht[1]，**这时将rehashidx的值没置为 -1**，表示rehash操作已经完成；

##### 05：整数集合（IntSet）

- 整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。
- Redis 用于保存整数值的集合抽象数据结构，可以保存类型**为 `int16_t` 、 `int32_t` 或者 `int64_t` 的整数值**， 并且保证集合中**不会出现重复元素**。

###### 数据结构

```c
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```

- `contents` 数组是整数集合的底层实现： 整数集合的每个元素都是 `contents` 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。
- 虽然 `intset` 结构将 `contents` 属性声明为 `int8_t` 类型的数组， 但实际上 `contents` 数组并不保存任何 `int8_t` 类型的值 ，`contents` 数组的真正类型取决于 `encoding` 属性的值：
  - 如果 `encoding` 属性的值为 **`INTSET_ENC_INT32`** ， 那么 `contents` 就是一个 `int32_t` 类型的数组， 数组里的每个项都是一个 `int32_t` 类型的整数值 （最小值为 `-2,147,483,648` ，最大值为 `2,147,483,647` ）。

###### 升级

- 每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。

###### 升级过程

1. 根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

###### 升级之后新元素的摆放位置

- 引发升级的新元素的长度总是**比整数集合现有所有元素的长度都大**， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：所以要么最开头，要么最末尾；

###### 示例

- 因为每个元素都占用 `16` 位空间， 所以整数集合底层数组的大小为 `3 * 16 = 48` 位， 整数集合的三个元素在这 `48` 位里的位置，现将类型为 `int32_t` 的整数值 `65535` 添加到整数集合里面；
- 最后， 程序将整数集合 `encoding` 属性的值从 `INTSET_ENC_INT16` 改为 `INTSET_ENC_INT32` ， 并将 `length` 属性的值从 `3` 改为 `4`。
- 因为每次向整数集合添加新元素**都可能会引起升级**， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的**时间复杂度为 O(N)** 。
- ![](/Users/likang/Code/Git/Middleware/04：Redis/photos/upgrade_01.png)

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/upgrade_02.png" style="zoom:67%;" />

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/upgrade_03.png" style="zoom: 67%;" />

###### 优点【两个】

1. 提升整数集合的灵活性；
   - 整数集合可以通**过自动升级底层数组来适应新元素**， 所以我们可以随意地将 `int16_t` 、 `int32_t` 或者 `int64_t` 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。
2. 尽可能地节约内存；

###### 降级

- 整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。


##### 06：跳跃表

- 跳跃表支持平均 O(log N) ，最坏 O(N) 复杂度的节点查找，在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单，String 类型元素的**有序集合且唯一**；
- Redis 的跳跃表由 `redis.h/zskiplistNode` 和 `redis.h/zskiplist` 两个结构定义， 其中 `zskiplistNode` 结构用于表示跳跃表节点， 而 `zskiplist` 结构则用于保存跳跃表节点的相关信息；

###### 跳表的实现

- <img src="https://github.com/likang315/Middleware/blob/master/04%EF%BC%9ARedis/photos/skipList.png?raw=true" style="zoom:67%;" />
  - `header` ：指向跳跃表的表头节点。
  - `tail` ：指向跳跃表的表尾节点。
  - `level` ：记录目前跳跃表内，层数最大的那个节点的层数**（表头节点的层数不计算在内）**。
  - `length` ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。
  - **层：**节点中用 `L1` 、 `L2` 、 `L3` 等字样标记节点的各个层， `L1` 代表第一层， `L2` 代表第二层，以此类推。
    - 每个层都带有两个属性：**前进指针和跨度**。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离
  - **前进指针：**每一层都有一个指向表尾的指针，level[i].forward ，用于从表头方位节点；
  - **后退指针：**backward 用于从表尾方向访问节点；
  - **分值：**用一个double类型的浮点数，跳表中所有节点都按分值的从小到大排序；
  - **成员对象：**是一个指针，指向对象地址；

###### `redis.h/zskiplistNode` 结构定义

```c
typedef struct zskiplistNode {
    // 后退指针
    struct zskiplistNode *backward;
    // 分值
    double score;
    // 成员对象
    robj *obj;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
```

- 跨度：用来计算排位（结点的索引）的： 在查找某个节点的过程中， 将沿途访问过的**所有结点的跨度累计起来**， 得到的结果就是目标节点在跳跃表中的排位。
- 分值和成员：在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是**多个节点保存的分值却可以是相同的**： 分值相同的节点将**按照成员对象在字典序中的大小来进行排序**， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。

###### `zskiplist` 结构的定义

```c
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数，表头节点的层高并不计算在内
    int level;
} zskiplist;	
```

##### 07：压缩列表（ziplist）

- 压缩列表（ziplist）是列表键和哈希键的底层实现之一。
- 当一个列表键只包含少量值， 并且每个值要么就是**小整数值**， 要么就是**长度比较短的字符串**， 那么 Redis 就会使用**压缩列表来做列表键的底层实现**。 
-  当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用**压缩列表来做哈希键的底层实现**。

###### 压缩列表的构成

- ![](/Users/likang/Code/Git/Middleware/04：Redis/photos/zipList_struct.png)

| 属性      | 类型       | 长度     | 用途                                                         |
| :-------- | :--------- | :------- | :----------------------------------------------------------- |
| `zlbytes` | `uint32_t` | `4` 字节 | 记录整个压缩列表**占用的内存字节数**：在对压缩列表进行内存重分配， 或者计算 `zlend` 的位置时使用。 |
| `zltail`  | `uint32_t` | `4` 字节 | 记录压缩列表**表尾节点距离压缩列表的起始地址有多少字节**： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。 |
| `zllen`   | `uint16_t` | `2` 字节 | 记录了压缩列表包含的节点数量： 当这个属性的值小于 `UINT16_MAX` （`65535`）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 `UINT16_MAX` 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。 |
| `entryX`  | 列表节点   | 不定     | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。     |
| `zlend`   | `uint8_t`  | `1` 字节 | 特殊值 `0xFF` （十进制 `255` ），用于**标记压缩列表的末端**。 |

###### 压缩列表节点的构成

- 每个压缩列表节点可以保存一个**字节数组**或者一个**整数值**；
  - 字节数组可以是以下三种长度的其中一种：
    1. 长度小于等于 `63` （2^{6}-1）字节的字节数组；
    2. 长度小于等于 `16383` （2^{14}-1） 字节的字节数组；
    3. 长度小于等于 `4294967295` （2^{32}-1）字节的字节数组。
  - 而整数值则可以是以下六种长度的其中一种：
    1. `4` 位长，介于 `0` 至 `12` 之间的无符号整数；
    2. `1` 字节长的有符号整数；
    3. `3` 字节长的有符号整数；
    4. `int16_t` 类型整数；
    5. `int32_t` 类型整数；
    6. `int64_t` 类型整数。
- 每个压缩列表节点都由 `previous_entry_length` 、 `encoding` 、 `content` 三个部分组成；
- ![](/Users/likang/Code/Git/Middleware/04：Redis/photos/ziplistNode.png)

###### previous_entry_length

- 以字节为单位， 记录了压缩列表中前一个节点的长度；
- 因为节点的 `previous_entry_length` 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。【倒退】
- 压缩列表的**从表尾向表头遍历操作**就是使用这一原理实现的；

###### encoding

- 记录了节点的 `content` 属性所保存数据的类型以及长度（占多少字节）；
  - 一字节、两字节或者五字节长， 值的最高位为 `00` 、 `01` 或者 `10` 的是字节数组编码： 这种编码表示节点的 `content` 属性保存着**字节数组**， 数组的长度由编码除去最高两位之后的其他位记录；
  - 一字节长， 值的最高位以 `11` 开头的是整数编码： 这种编码表示节点的 `content` 属性保存着**整数值**， 整数值的类型和长度由编码除去最高两位之后的其他位记录；

###### content

- 节点的 `content` 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 `encoding` 属性决定。

###### 连锁更新

- 场景：在一个压缩列表中， 有多个连续的、长度介于 `250` 字节到 `253` 字节之间的节点 `e1` 至 `eN`，这时， 如果我们将一个长度大于等于 `254` 字节的新节点 `new` 设置为压缩列表的表头节点， 那么 `new` 将成为 `e1` 的前置节点。
- 因为 `e1` 的 `previous_entry_length` 属性仅长 `1` 字节， 它没办法保存新节点 `new` 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将 `e1` 节点的 `previous_entry_length` 属性从原来的 `1` 字节长扩展为 `5` 字节长。
- 除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。
- 因为连锁更新在最坏情况下需要对压缩列表执行 `N` 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。
- 出现概率较低，平均时间复杂度仅为： O(N)；

#### 08：对象【重要】

- Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了**一个对象系统**， 这个系统包含**字符串对象、列表对象、哈希对象、集合对象和有序集合对象**这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。
- 使用对象的好处是， 我们可以**针对不同的使用场景， 为对象设置多种不同的数据结构实现**， 从而优化对象在不同场景下的使用效率【内存，读取效率】。

##### 对象的类型与编码

- 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象**用作键值对的键**（键对象）， 另一个对象**用作键值对的值**（值对象）。

###### Redis 中的每个对象都由**一个 `redisObject` 结构**表示

- ```c
  typedef struct redisObject {
      // 类型
      unsigned type:4;
      // 编码
      unsigned encoding:4;
      // 指向底层实现数据结构的指针
      void *ptr;
      // 引用计数，共享对象
      int refcount;
      // 该对象最后一次被命令程序访问的时间
      unsigned lru:22;
  } robj;
  ```

###### 对象的Type 属性【对应Type命令】

- | 类型常量       | 对象的名称   |
  | :------------- | :----------- |
  | `REDIS_STRING` | 字符串对象   |
  | `REDIS_LIST`   | 列表对象     |
  | `REDIS_HASH`   | 哈希对象     |
  | `REDIS_SET`    | 集合对象     |
  | `REDIS_ZSET`   | 有序集合对象 |

  对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：

  - 当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；
  - 当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”；

###### 编码和底层实现

- 对象的 `ptr` 指针指向对象的底层实现数据结构， 而这些**数据结构由对象的 `encoding` 属性**决定。

- | 编码常量                    | 编码所对应的底层数据结构      |
  | :-------------------------- | :---------------------------- |
  | `REDIS_ENCODING_INT`        | `long` 类型的整数             |
  | `REDIS_ENCODING_EMBSTR`     | `embstr` 编码的简单动态字符串 |
  | `REDIS_ENCODING_RAW`        | 简单动态字符串                |
  | `REDIS_ENCODING_HT`         | 字典                          |
  | `REDIS_ENCODING_LINKEDLIST` | 双端链表                      |
  | `REDIS_ENCODING_ZIPLIST`    | 压缩列表                      |
  | `REDIS_ENCODING_INTSET`     | 整数集合                      |
  | `REDIS_ENCODING_SKIPLIST`   | 跳跃表和字典                  |

- 不同类型和编码的对象【使用 **OBJECT ENCODING** 命令可以查看一个数据库键的值对象的编码】

- | 对象           | 编码(数据结构常量)          | 说明                                                 |
  | :------------- | :-------------------------- | :--------------------------------------------------- |
  | `REDIS_STRING` | `REDIS_ENCODING_INT`        | 使用整数值实现的字符串对象。                         |
  | `REDIS_STRING` | `REDIS_ENCODING_EMBSTR`     | 使用 `embstr` 编码的简单动态字符串实现的字符串对象。 |
  | `REDIS_STRING` | `REDIS_ENCODING_RAW`        | 使用简单动态字符串实现的字符串对象。                 |
  | `REDIS_LIST`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的列表对象。                         |
  | `REDIS_LIST`   | `REDIS_ENCODING_LINKEDLIST` | 使用双端链表实现的列表对象。                         |
  | `REDIS_HASH`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的哈希对象。                         |
  | `REDIS_HASH`   | `REDIS_ENCODING_HT`         | 使用字典实现的哈希对象。                             |
  | `REDIS_SET`    | `REDIS_ENCODING_INTSET`     | 使用整数集合实现的集合对象。                         |
  | `REDIS_SET`    | `REDIS_ENCODING_HT`         | 使用字典实现的集合对象。                             |
  | `REDIS_ZSET`   | `REDIS_ENCODING_ZIPLIST`    | 使用压缩列表实现的有序集合对象。                     |
  | `REDIS_ZSET`   | `REDIS_ENCODING_SKIPLIST`   | 使用跳跃表和字典实现的有序集合对象。                 |

##### 字符串对象

- 字符串对象的编码可以是 `int` 、 `raw` 或者 `embstr` 。
- 如果一个字符串对象保存的是整数值， 并且这个整数值可以用 `long` 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 `ptr` 属性里面（将 `void*` 转换成 `long` ）， 并将字符串对象的编码设置为 `int` 。
  - 值存储在了指向数据结构的指针；
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度**大于 44字节**， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 `raw；
- 如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度**小于等于 `44` 字节**， 那么字符串对象将使用 `embstr` 编码的方式来保存这个字符串值。
  - `embstr` 编码是专门用于**保存短字符串的一种优化编码方式，**这种编码和 `raw` 编码一样， 都使用 `redisObject` 结构和 `sdshdr` 结构来表示字符串对象， 但 `raw` 编码会调用**两次内存分配函数**来分别创建 `redisObject` 结构和 `sdshdr` 结构， 而 `embstr` 编码则通过**调用一次内存分配函数来分配一块连续的空间**， 空间中依次包含 `redisObject` 和 `sdshdr` 两个结构。
- 一般用 `long、double` 类型表示的**浮点数在 Redis 中也是作为字符串值来保存的**： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存，用的时候在反转回来。

###### 编码的转换

- `int` 编码的字符串对象和 `embstr` 编码的字符串对象在条件满足的情况下， 会被转换为 `raw` 编码的字符串对象。
  - 追加字符串或者修改时，自动变化；

##### 列表对象

- 列表对象的编码可以是 `ziplist` 或者 `linkedlist` 。
- `ziplist` 编码的列表对象使用压缩列表作为底层实现， 每个**压缩列表节点（entry）保存了一个列表元素**。
-  `linkedlist` 编码的列表对象使用双端链表作为底层实现， 每个**双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。**
  - 嵌套字符串对象；
- <img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/linkedlist_str.png" style="zoom:80%;" />

###### 编码转换

- 当列表对象可以同时满足以下两个条件时， 列表对象使用 `ziplist` 编码，不满足时列表对象需要使用 `linkedlist` 编码。
  1. 列表对象保存的所有字符串元素的长度都小于 `64` 字节；
  2. 列表对象保存的**元素数量**小于 `512` 个；

##### 哈希对象

- 哈希对象的编码可以是 `ziplist` 或者 `hashtable` 。
- `ziplist` 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：
  - 保存了同一键值对的两个节点总是紧挨在一起， **保存键的节点在前， 保存值的节点在后**；
- `hashtable` 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存;

###### 编码转换

- 当哈希对象同时满足**以下两个条件时， 哈希对象使用 `ziplist` 编码，不能满足这两个条件时，使用 `hashtable` 编码。
  - 哈希对象保存的所有键值对的键和值的字符串长度都小于 `64` 字节；
  - 哈希对象保存的**键值对数量**小于 `512` 个；

##### 集合对象

- 集合对象的编码可以是 `intset` 或者 `hashtable` 。
- `intset` 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。 
-  `hashtable` 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 `NULL` 
- <img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/intset_set_obj.png" style="zoom:80%;" />

###### 编码的转换

- 当集合对象可以同时满足以下两个条件时，使用 `intset` 编码，不能满足这两个条件的集合对象使用 `hashtable` 编码。
  1. 集合对象保存的所有元素都是整数值；
  2. 集合对象保存的元素数量不超过 `512` 个；

##### 有序集合对象（sorted-set）

- 有序集合的编码可以是 `ziplist` 或者 `skiplist` 。

- `ziplist` 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用**两个紧挨在一起的压缩列表节点来保存**， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。

- `skiplist` 编码的有序集合对象**使用 `zset` 结构作为底层实现， 一个 `zset` 结构同时包含一个字典和一个跳跃表**；

  - ```c
    typedef struct zset {
        zskiplist *zsl;
        dict *dict;
    } zset;
    ```

- `zset` 结构中的 `zsl` 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 `object` 属性保存了元素的成员， 而跳跃表节点的 `score` 属性则保存了元素的分值。 通过这个跳跃表， 程序可以**对有序集合进行范围型操作**， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。

  除此之外， `zset` 结构中的 `dict` 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： **字典的键保存了元素的成员， 而字典的值则保存了元素的分值**。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。

###### 为什么有序集合需要同时使用跳跃表和字典来实现？

- 字典保证根据分值查找复杂度O(1)，跳表保证有序遍历复杂读O(n)；

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/zset.png" style="zoom:60%;" />

###### 编码的转换

- 当有序集合对象同时满足以下两个条件时， 使用 `ziplist` 编码，不能满足这两个条件时，将使用 `skiplist` 编码。
  1. 有序集合保存的元素数量小于 `128` 个；
  2. 有序集合保存的所有元素成员的长度都小于 `64` 字节；

##### 类型检查与多态命令

- Redis 中用于操作键的命令基本上可以分为两种类型
  1. 可以对任何类型的键执行；
  2. 只能对特定类型的键执行；

###### 类型检查的实现

- 类型特定命令所进行的类型检查是通过 `redisObject` 结构的 `type` 属性来实现的：
  - 在执行一个类型特定命令之前， 服务器会先检查**输入数据库键的值对象是否为执行命令所需的类型**， 如果是的话， 服务器就对键执行指定的命令，否则， 服务器将拒绝执行， 并向客户端返回一个类型错误。

###### 多态命令的实现

- 根据值对象的编码方式， 选择正确的命令实现代码来执行命令。
- 例：
  - 列表对象有 `ziplist` 和 `linkedlist` 两种编码可用， 其中前者使用**压缩列表 API** 来实现列表命令， 而后者则使用**双端链表 API** 来实现列表命令。

##### 内存回收

- 因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个**引用计数法**实现的内存回收机制， 通过这一机制， 程序可以通过**跟踪对象的引用计数信息**， 在适当的时候自动释放对象并进行内存回收。
- 每个对象的引用计数信息由 `redisObject` 结构的 `refcount` 属性记录：
  - int refcount;

##### 对象共享

- 除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有**对象共享**的作用。
- 在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：
  1. 将数据库键的值指针指向一个现有的值对象；
  2. 将被共享的值对象的引用计数增一。
- 目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了**从 `0` 到 `9999` 的**所有整数值， 当服务器需要用到值为 `0` 到 `9999` 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。
- <img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/shared-memory.png" style="zoom:80%;" />

##### 对象的空转时长

-  `redisObject` 结构包含的最后一个属性为 `lru` 属性， 该属性记录了对象最后一次被命令程序访问的时间
  - unsigned lru:22;
- **OBJECT IDLETIME** 命令可以打印出给定键的空转时长， 这一空转时长就是通过将**当前时间减去键的值对象的 `lru` 时间计算得出**。

















