### Redis：

------

[TOC]

##### 01：概述

- Redis 是一个开源的使用C语言编写、遵守BSD协议、支持网络、**基于内存亦可持久化的日志型、Key-Value 数据库**，并提供多种语言的API，通常被称为数据结构服务器；
- redis 作为内存数据库，所有数据都**保存在内存中**, 一旦程序停止工作，数据都将丢失，需要我们重新从其他地方加载数据，不过Redis提供了两种方式保存Redis中的数据；
  1. dump.rdb 快照，把内存信息**持久化磁盘**上；
  2. 一种是**存储到AOF文件中**，aof 文件存储的是一条一条存储和修改数据的命令，类似mysql的二进制日志；

###### redis 特性

- Redis 支持**数据的持久化**，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用；
- Redis **数据结构丰富**，不仅仅支持的 key-value 类型的数据，还提供list，set，zset，hash等数据结构的存储；
- Redis 支持数据的备份，即 **master-slave （一主多从）模式的数据备份**；
- Redis 的单个操作都是原子性的，要么成功要么失败，**单个操作是原子性的。多个操作支持事务，但不是原子性**，通过MULTI和EXEC指令包起来；

###### Value 的数据结构【五种】

1. String（字符串）
2. Hash（哈希）
3. List（列表）
4. Set（集合）
5. Zset  (有序集合)

##### 02：String【简单动态字符串 SDS】

###### SDS 的定义

- ```c
  # sds.h/sdshdr
  struct sdshdr {
      // 记录 buf 数组中已使用字节的数量,等于 SDS 所保存字符串的长度
      int len;
      // 记录 buf 数组中未使用字节的数量（空闲）
      int free;
      // 字节数组，用于保存字符串
      char buf[];
  };
  ```

![SDS](/Users/likang/Code/Git/Middleware/04：Redis/photos/SDS.png)



###### SDS 与C 字符串的区别

1. O(1) 的时间复杂度获取字符串长度，C 遍历是O(n);
2. 杜绝缓冲溢出
   - 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间**是否满足**修改所需的要求， 如果不满足的话， **API 会自动将 SDS 的空间扩展至执行修改所需的大小**， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。
3. 减少修改字符串时带来的内存重分配次数
   - 通过未使用空间， SDS 实现了**空间预分配**和**惰性空间**释放两种优化策略。
   - 空间预分配：执行**增长**操作时，发现空间不足时，进行下列操作，否则直接进行操作；
     - 如果对 SDS 进行修改之后， SDS 的长度（也即是 `len` 属性的值）将小于 `1 MB` ， 那么程序分配和 `len` 属性同样大小的未使用空间， 这时 SDS `len` 属性的值将和 `free` 属性的值相同。
     - 如果对 SDS 进行修改之后， SDS 的长度将大于等于 `1 MB` ， 那么程序会分配 `1 MB` 的未使用空间。
       -  举个例子， 如果进行修改之后， SDS 的 `len` 将变成 `30 MB` ， 那么程序会分配 `1 MB` 的未使用空间， SDS 的 `buf` 数组的实际长度将为 `30 MB + 1 MB + 1 byte` 。
     - 通过这种预分配策略， SDS 将连续增长 `N` 次字符串所需的内存重分配次数从必定 `N` 次降低为**最多 `N` 次**。
   - 惰性空间释放
     - 当 SDS 的 API 需要**缩短** SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是**使用 `free` 属性将这些字节的数量记录起来**， 并等待将来使用；
     - SDS 也提供了相应的API，在需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。

###### 二进制安全

- 所有 SDS API 都会以**处理二进制的方式**来处理 SDS 存放在 `buf` 数组里的数据， 程序不会对其中的数据做任何限制、过滤；
- 字节数组，Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据；
- 通过使用二进制安全的 SDS ， 而不是 C 字符串， 使得 Redis **不仅可以保存文本数据， 还可以保存任意格式的二进制数据**。

###### 兼容部分 C 字符串函数

- 虽然 SDS 的 API 都是二进制安全的， 但它们一样**遵循 C 字符串以空字符结尾的惯例**： 总会在为 `buf` 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 `<string.h>` 库定义的函数。

##### 03：链表

###### 链表和链表节点的实现

- 多个 ListNode 可以通过 `prev` 和 `next` 指针组成**双向链表**；

##### 04：字典

- 是一个 String 类型的 key和 value 的映射表（HashMap），底层是**数组 + 链表**；
- 每个 hash 可以存储 2^32-1 键值对（40多亿）

###### 字典的定义

- ```c
  typedef struct dict {
      // 类型特定函数
      dictType *type;
      // 私有数据
      void *privdata;
      // 哈希表
      dictht ht[2];
      // rehash 索引
      // 当 rehash 不在进行时，值为 -1
      int rehashidx; /* rehashing not in progress if rehashidx == -1 */
  } dict;
  ```

  - `type` 属性和 `privdata` 属性是针对不同类型的键值对， 为创建多态字典而设置的；
  - `ht` 属性是一个包含两个项的数组， 数组中的每个项都是一个 `dictht` 哈希表， 一般情况下， 字典只使用 `ht[0]` 哈希表， `ht[1]` 哈希表只会在对 `ht[0]` 哈希表进行 rehash 时使用。
  -  `rehashidx` ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 `-1` 。

###### 没有rehash的字典

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/dict.png" alt="dict" style="zoom:60%;" />

###### 哈希算法

-  index = hash & dict->ht[x].sizemask;

###### 解决hash冲突

- Redis 的哈希表使用链地址法（separate chaining）来解决键冲突，将冲突结点头插；

###### ReHash

- 是包含两个项的数组，数组中的每个项都是⼀个字典，⼀般情况下，字典只使⽤ ht[0] 字典，ht[1] 只在 ht[0] 进⾏rehash 的时候使用，作为临时载体；

###### Rehash 步骤

1. 为字典ht[1] 分配空间，这个字段取决于要执行的操作，以及ht[0] 当前所包含的键值对的数量；
2. 如果执行扩展操作，那么ht[1]的大小就是一个大于等于ht[o].used * 2 的2的指数幂；
3. 如果执行收操作，那么htp1]的大小是第一个小于等于ht[0].used * 2 的 2 的指数幂；
4. 将保存在ht[0]中的所有键值时rehash到ht[0]上，即**重新计算key的哈希值和索引值然后将key放在ht[1]对应的位置上**；
5. 当ht[0]包含的所有键值对都迁移到了ht[1]，**释放ht[0]，将ht[1]设置为ht[0]，并在在ht[1]新创建一个空白字典**，为下一次
   rehash做准备；

###### 渐进式ReHash

- 渐进式Rehash操作，**不会阻塞读写操作**，索引变量index（相当于下标），将rehash键值对所需的计算，**均摊到对字典的所有操作中**，从而避免了集中式的rehash带来庞大的计算量；

###### 渐进式Rehash步骤

1. 为ht[1] 分配空间，让上字典同时有ht[O)和ht[i];
2. 在字典中维持一个索引计数器变量rehashidx，并将它设置为0，表示ReHash开始；
3. 在rehash期间，每次对字典执行增删改查时，程序**除了执行指定的操作外还会顺带将ht[0]字典在的rehashdx索引上的所有键值对 rehash 到叫ht[1]**，rehash完成后，rehashidx自增1；
4. 随着字典操作的不断进行，最终有的键值对会被rehash至ht[1]，**这时将rehashidx的值没置为 -1**，表示rehash操作已经完成；
5. 在rehash的过程中，程序优先在叫ht[0]中进行查找，如果没有找到，就会继续去ht[1] 中进行查找，此外，新添加的键值对一律保存在ht[1]中，而ht[0] 不在进行任何添加操作，慢慢变成空表；









##### 05：Set

- String 类型元素的无序集合；
- 相当于 Java 中的 HashSet，它内部的**键值对是⽆序，并且唯⼀的**，底层实现相当于⼀个特殊的字典，字典中所有的 **value 都是⼀个 NULL**，当集合中的最后⼀个元素被移除后，数据结构⾃动删除，内存被回收；


##### 06：Zset

- Redis 中最优特色的数据结构，String 类型元素的**有序集合且唯一**；
- 底层实现是：**跳表+Hash，跳表保证有序，Hash保证的查找高效**；
- 该结构中每个元素都会关联一个**double类型的 score** ，redis 正是通过 score 来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但分数(score)却可以重复，**skipList负责实现高性能排序，Hash负责实现高性能查找**；
- ![](https://github.com/likang315/Middleware/blob/master/04%EF%BC%9ARedis/photos/skipList.png?raw=true)

  - **层：**跳表的Level数组，每次创建一个新的结点时，**随机生成[1, 32] 的值作为数组的长度**，即层的高度；
  - **前进指针：**每一层都有一个指向表尾的指针，level[i].forward ，用于从表头方位节点；
  - **后退指针：**backward 用于从表尾方向访问节点；
  - **分值：**用一个double类型的浮点数，跳表中所有节点都按分值的从小到大排序；
  - **成员对象：**是一个指针，指向对象地址；

##### 07：BitMap

- key-value（字符串位图）

- 可以直接对值得bit位操作，大数据查找；

- 示例

  - ```sh
    # 设置值为big（3个字符，一个字符8bit）
    set hello big
    # 获取二进制形式的第1位，即为0
    getbit hello 0
    # 给位图指定索引设置值
    # setbit key offset vlaue
    # 把hello二进制形式的第8位设置为1，之前的ASCII码为98，现在改为99，即把b改为c
    setbit hello 7 1
    # 获取位图指定索引的值
    getbit key offset
    # 获取位图指定范围(start到end,单位为bit，如果不指定就是获取全部)位值为1的个数
    bitcount key [start end]
    ```

    