### 复制（replicate）

------

[TOC]

##### 01：概述

- 在Redis 中，用户可以通过**执行 SLAVEOF 命令或设置 slaveof 选项**，让一个服务器去复制( replicate ) 另一个服务器，我们称被复制的服务器为主服务器( master ),  对主服务器进行复制的服务器是从服务器( slave )。
- 通过复制让主从服务器数据库状态保持一致；

##### 02：旧版复制功能的实现【同步+命令传播】

###### 同步

- 当客户端向从服务器发送 SLAVEOF 命令， 要求从服务器复制主服务器时， 从服务器**首先需要执行同步操作**；
- 从服务器对主服务器的同步操作需要通过向主服务器发送 SYNC 命令来完成， 以下是 SYNC 命令的执行步骤：
  1. 从服务器向主服务器**发送 SYNC 命令**。
  2. 收到 SYNC 命令的主服务器**执行 BGSAVE 命令**， 在后台生成一个 **RDB 文件**， 并使用一个**缓冲区记录从现在开始执行的所有写命令**。
  3. 当主服务器的 BGSAVE 命令执行完毕时， 主服务器会将 BGSAVE 命令**生成的 RDB 文件发送给从服务器**， 从服务器接收并载入这个 RDB 文件， 将自己的数据库状态更新至主服务器执行 BGSAVE 命令时的数据库状态。
  4. 主服务器将记录在**缓冲区里面的所有写命令发送给从服务器**， 从服务器执行这些写命令， 将自己的数据库状态**更新至**主服务器数据库当前所处的状态。

###### 命令传播

- 在**同步操作执行完毕之后**， 主从服务器两者的数据库将达到一致状态， 但这种一致并不是一成不变的 ，每当主服务器执行客户端发送的写命令时， 主服务器的数据库就有可能会被修改， 并导致主从服务器状态不再一致。
- 为了让主从服务器再次回到一致状态， **主服务器需要对从服务器执行命令传播操作**： 主服务器会将自己执行的写命令，发送给从服务器执行， 当从服务器执行了相同的写命令之后， 主从服务器将再次回到一致状态。

##### 03：旧版复制功能缺陷

- 在Redis中  从服务器对主服务器的复制可以分为以下两种情况 
  - **初次复制：**从服务器以前没有复制任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。
  - **断线后复制：**  处于命令传播阶段的主从服务器因为网络原因中断了复制，但从服务器通过自动重新连接上了主服务器  并继续复制主服务器；
    - 重新连接上只有，又要进行一次同步—命令传播过程，但其实从服务器只需要在主从断开期间，变更的数据；
- 对于初次复制来旧版复制功够很好地完成任务，但对于断线后复制来说旧版复制功能，虽然也能让主从服务器重新回到一致状态，但效率却非常低。
- **SYNC 命令是一个非常耗费资源的操作**
  1. 主服务器执行BGSAVE命令来生成RDB 文件，整个生成操作会耗费主服务器**大量的CPU、内存和磁盘I/0 资源**。
  2. 主服务器将己生成的RDB 文件发送给从服务器，整个发送操作会耗费主从服务器大量的**网络资源（带宽和流量）**，并对主服务器响应命令时间产生影响。
  3. 接收到RDB文件的从服务器，在载入RDB 文件期间，从服务器会**因为阻塞无法处理请求命令**。

##### 04：新版复制功能的实现

- Redis从2.8版本开始，使用 **PSYNC命令代替SYNC命令** 来执行复制时的同步操作。
- PSYNC 命令具有完整重同步（full resynchronization）和部分重同步（partialresynchronization）两种模式：
  1. **完整重同步用于处理初次复制情况：**完整重同步的执行步骤和SYNC命令的执行步骤一样；
  2. **部分重同步则用于处理断线后重复制情况：**当从服务器在断线后重新连接主服务器时，如果条件允许，**主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器**，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

##### 05：部分重同步的实现

- 部分重同步功能由以下三个部分构成：
  - 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量；
  - 主服务器的复制积压缓冲区（replication backlog）；
  - 服务器的运行ID（run ID）；

###### 复制偏移量

- **主服务器和从服务器会分别维护一个复制偏移量**，主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N，从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。
- 通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态：

###### 复制积压缓冲区

- 复制积压缓冲区是由**主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列**，默认大小为1MB。
- <img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/replicate-buffer.png" style="zoom:75%;" />

- 主服务器的复制积压缓冲区里面会**保存着一部分最近传播的写命令**，并且复制积压缓冲区会**为队列中的每个字节记录相应的复制偏移量**。
- 主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：
  - 如果offset偏移量之后的数据**仍然存在于复制积压缓冲区里面**，那么主服务器将对从服务器执行部分重同步操作。
  - 如果offset偏移量之后的数据**已经不存在于复制积压缓冲区**，那么主服务器将对从服务器执行完整重同步操作。
- 缓冲区大小
  - **size = second*write_size_per_second** 来估算：
    - second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）；
    -  write_size_per_second：主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）。

###### 服务器运行ID

- 每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID。
- 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。
- 当从服务器对主服务器进行初次复制时，**主服务器会将自己的运行ID传送给从服务器**，而从服务器则会将这个运行ID保存起来。
- 当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：
  - 如果从服务器保存的运行ID和**当前连接的主服务器的运行ID相同**，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作。
  - 如果从服务器保存的运行ID和**当前连接的主服务器的运行ID并不相同**，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器**执行完整重同步操作**。

##### 06：PSYNC 命令的实现

- PSYNC命令的调用方法有两种：
  - 如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送**PSYNC ? -1**命令，主动请求主服务器进行**完整重同步**；
  - 如果从服务器已经复制过某个主服务器，那么从服务器将向主服务器发送**PSYNC ＜runid＞ ＜offset＞**命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的**主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作**。
- 接收到PSYNC命令的主服务器回复情况
  1. 如果主服务器返回 **+FULLRESYNC ＜runid＞ ＜offset＞**回复，那么表示**主服务器将与从服务器执行完整重同步操作**：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。
  2. 如果主服务器返回**+CONTINUE** 回复，那么表示主服务器将与从服务器执行**部分重同步操作**，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。
  3. 如果主服务器返回**-ERR** 回复，那么表示主服务器的版本低于Redis 2.8，**不支持PSYNC命令**，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。

##### 07：复制的实现

- 通过向从服务器发送 SLAVEOF 命令，我们可以让一个从服务器去复制一个主服务器

  - ```shell
    SLAVEOF <master_ip> <master_port>
    ```

###### 设置主服务器的地址和端口

- 当客户端向从服务器发送 SLAVE 命令时，从服务器首先要做的是将客户端给定的主服务器IP地址以及端口保存到**服务器状态的masterhost属性和masterport属性**里面。

  - ```c
    struct redisServer {
    	// 主服务器地址
    	char *masterhost;
    	// 主服务器端口
    	int masterport;
    }
    ```

- SLAVEOF命令是一个**异步命令**，在完成masterhost属性和masterport属性的设置工作之后，**从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收**，而实际的复制工作将在OK返回之后才真正开始执行。

###### 建立套接字连接

- 创建连向主服务器的套接字连接，如果从服务器创建的套接字能成功连接（connect）到主服务器，那么**从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器**，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令等。
- 这时从服务器将同时具有**服务器（server）和客户端（client）两个身份**：从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复。

###### 发送 ping 命令

- 从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个PING命令；
  - 虽然主从服务器成功建立起了套接字连接，但双方并未使用该套接字进行过任何通信，通过发送PING命令可以**检查套接字的读写状态是否正常**。
  - 因为复制工作接下来的几个步骤都必须在主服务器可以正常处理命令请求的状态下才能进行，通过发送PING命令可以**检查主服务器能否正常处理命令请求**。
- 如果主服务器向从服务器返回一个错误时，从服务器断开并**重新创建连向主服务器的套接字**。

###### 身份验证【要么都设置，要么都不设置】

- 从服务器在收到主服务器返回的"PONG"回复之后，下一步要做的就是决定是否进行身份验证：
  - 如果从服务器设置了**masterauth选项**，那么进行身份验证。
  - 如果从服务器没有设置masterauth选项，那么不进行身份验证
- 在需要进行身份验证的情况下，从服务器将向主服务器**发送一条AUTH命令**，命令的参数为从服务器masterauth选项的值。
- 如果从服务器通过**AUTH 命令发送的密码和主服务器 requirepass 选项所设置的密码相同**，那么主服务器将继续执行从服务器发送的命令，复制工作可以继续进行。与此相反，如果主从服务器设置的密码不相同，那么主服务器将返回一个 **invalid password** 错误。
- 如果主服务器设置了 requirepass 选项，但从服务器却没有设置 masterauth 选项，那么主服务器将返回一个**NOAUTH错误**。另一方面，如果主服务器没有设置requirepass选项，但从服务器却设置了masterauth选项，那么主服务器将返回一个 **no password is set** 错误，所有错误都会中止复制工作；

###### 发送端口信息

- 在身份验证步骤之后，从服务器将执行命令 **REPLCONF listening-port ＜port-number＞**，向主服务器发送从服务器的监听端口号。
- 主服务器在接收到这个命令之后，会将端口号记录在**从服务器所对应的客户端状态的slave_listening_port属性**中,

###### 同步

- 此时，从服务器将向主服务器发送 PSYNC 命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。
- 在同步操作执行之前，只有从服务器是主服务器的客户端，但是**在执行同步操作之后，主服务器也会成为从服务器的客户端**。

###### 命令传播

- 当完成了同步之后，主从服务器就会进入命令传播阶段，这时**主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令**，就可以保证主从服务器一直保持一致；

##### 08：心跳检测

- 在**命令传播阶段**，从服务器默认会以**每秒一次**的频率，向主服务器发送命令

  - ```c
    REOLCONF ACK <replication_offset>
    ```

  - 检测主从服务器的网络连接状态；

  - 辅助实现 min-slaves 选项；

  - 检测传播命令丢失；

###### 检测主从服务器的网络连接状态

- 如果主服务器**超过一秒钟没有收到从服务器发来的REPLCONF ACK命令**，那么主服务器就知道主从服务器之间的连接出现问题了；
- 从服务器列表的**lag** 属性，我们可以看到相应**从服务器最后一次向主服务器发送REPLCONF ACK命令距离现在过了多少秒**

###### 辅助实现min-slaves配置选项

- Redis的 **min-slaves-to-write 和 min-slaves-max-lag** 两个选项可以防止主服务器在不安全的情况下执行写命令；

  - ```shell
    # 从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令
    min-slaves-to-write 3
    min-slaves-max-lag 10
    ```

###### 检测传播命令丢失

- 如果因为网络故障，**主服务器传播给从服务器的写命令在半路丢失**，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器**将发觉从服务器当前的复制偏移量少于自己的复制偏移量**，然后主服务器就会根据从服务器提交的复制偏移量，**在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器**。