### 事件（Event）

------

##### 01：事件

- Redis 服务器是一个事件驱动程序， 服务器需要处理两类事件；
- 文件事件：用于处理 Redis 服务器和客户端之间的网络IO的抽象；
- 时间事件：用于处理定时任务的的抽象；

##### 02：文件事件

- Redis 基于 **Reactor 模式**开发了自己的网络事件处理器： 这个处理器被称为**文件事件处理器( file event handler)**。
- 文件事件处理器使用 **IO 多路复用( multiplexing )** 程序来同时监听多个套接字， 并根据套接字目前执行的任务来为**套接字关联不同的事件处理器**。
- 当被监听的套接字准备好执行连接应答（ accept )、读取（ read )、写人( write )、关闭( close ) 等操作时， 与操作相对应的文件事件就会产生， 这时**文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。**

###### 文件事件处理器的构成

- 文件事件处理器分为四个部分
  -  套接字；
  - I/0 多路复用技术；
  - 文件事件分派器(dispatcher )；
  - 事件处理器；
- 文件事件是对套接字操作的抽象，每**当一个套接字准备好执行连接应答(accept )、写人、读取、关闭等操作时**，就会产生一个文件事件。因为一个服务器通常会连接多个套接字， 所以多个文件事件有可能会并发地出现。
- I/0 多路复用技术：负责**监听多个套接字**，并向文件事件分派器**传送产生了事件的套接字**。尽管多个文件事件可能会并发地出现， 但I/0 多路复用程序总是会将所有产生事件的套接字**都放到一个队列里**面， 然后通过这个队列， 以有序( sequentially ) 、同步(synchronously)、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后（ 该套接字为事件**所关联的事件处理器执行完毕**）， I/0 多路复用程序才会继续向文件事件分派器传送下一个套接字；

<img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/event_io.png" alt="event_io" style="zoom:70%;" />

###### I0 多路复用程序的实现

- Redis 为每个I/0 多路复用函数库实现了相同的API , 所以l/0 多路复用程序的底层实现是可以互换，在实现源码中用 #include 宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I/0 多路复用函数库来作为Redis 的I/0 多路复用程序的底层实现。

###### 事件的类型

- I/0 多路复用程序可以监听多个套接字的ae.h/AE_READABLE 事件和ae.h/AE_WRITABLE 事件
  - 当**套接字变得可读时**（客户端对套接字执行write操作，或执行close操作），或有新的可应答( acceptable ) 套接字出现时，客户端对服务器的监听套接字执行connect 操作， 套接字产生AE_READABLE 事件。
  - 当**套接字变得可写时**（客户端对套接字执行read 操作），套接字产生AE_WRITABLE 事件;
  - 可读、可写操作时相对于服务器而言的；
- I/0 多路复用程序允服务器同时监听套接字的AE_READABLE 事件和AE_WRITABLE事件，如果一个套接字同时产生了两种事件，那么文件事件分派器会优先处理AE_READABLE 事件，等到AE_READABLE 事件处理完之后，才处理AE_WRITABLE事件。

##### 03：文件事件处理器

- Redis为文件事件编写了多个处理器   些事件处理器分别用于实现不同的网络需求；

###### 连接应答处理器【监听套接字】

- networking.c/acceptTcpHandler 函数是Redis的连接应答处理器，这个处理器用于对连接 服务器监听套接字的客户端行为应答，具体实现为sys/socket.h/accept函数的包装。
- 当Redis 服务器进行初始化的时候 ，程序会**将这个连接应答处理器和服务器监听套接字的AE_READABLE 事件关联起来**，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候，**套接字就会产生AE_READABLE 事件**，引发连接应答处理器执行相应的套接字应答到操作；

###### 命令请求处理器【客户端套接字】

- networking.c/readQueryFromClient 函数是Redis 的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令 求内容，具体实现为unistd.h/read 函数的包装。
- 当一个客户端通过连接应答处理器成功接到服务器之后 ，服务器会将客户端套接字的AE_READABLE 事件和命令请求处理器关联起来，**当客户端向服务器发起命令请求的时候，套接字就会产生AE_READABLE 事件，引发命令请求处理器执行**，并执行相应的套接字读入操作；

###### 命令回复处理器

- networking.c/sendReplyToClient 函数是Redis 的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过接字返回给客户端，具体实现为unistd.h/write 函数的包装。
- 当服务器有命令回复需要传送给客户端的时候，**服务器会将客户端套接字的AE_WRITABLE 事件和命令回复处理器关联起来  当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE 事件，引发命令回复处理器执行**，并执行相应的套接字写入操作。当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE 事件之间的关联。

##### 04：时间事件

- 时间事件分为两类：
  - 定时事件：一段程序在指定的时间之后执行一次。
  - 周期性事件：一段程序每隔指定时间就执行一次。
- 一个时间事件三个属性组成：
  1. Id：服务器为时间事件创建的全局唯一ID标号，ID号按从小到大的顺序递增，新事件的ID号比旧事件的ID 号大。
  2. when: 毫秒精度的UNIX 时间戳，记录了实际那事件的到达 ( arrive ) 时间。
  3. timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。
- 判断一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值，如果事件处理器返回回 ae.h/AE_NOMORE , 那么该事件为定时事件，事件在到一次之后就会被删除，之后不再到达。
- 如果事件处理器返回一个非AE_NOMORE的整数值，那么这个事件为周期性事件，当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到，并以这种方式一直更新并行下去。

###### 实现

- 

























