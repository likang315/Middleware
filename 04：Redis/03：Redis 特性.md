### Redis 特性

------

[TOC]

##### 01：Redis 分区

- 分割数据到多个Redis实例的处理过程，因此**每个实例只保存key的一个子集**；
- 每个实例中有多个连接数；


###### 范围分区：

- 最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例，缺点你是**需要维护一张映射表**，这个表需要被管理；


###### Hash分区

- **用一个hash函数将key转换为一个数字**，比如使用crc32 hash函数，返回一个整数，对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个；

- 注意：取模操作是取除的余数，通常在多种编程语言中用  % 操作符实现

##### 02：Redis 事务

1. 批量操作在发送 EXEC 命令前被**放入队列缓存**；
2. **收到 EXEC 命令后进入事务执行**，事务中任意命令执行失败，其余的命令依然被执行，没有原子性；
3. 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中，隔离性；
4. 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 **Redis 事务的执行并不是原子性的**； 
   - Multi：标记一个事务块的开始
   
   - Exec： 执行所有事务块内的命令
   
   - discard ：取消事务，放弃执行事务块内的所有命令
   
   - watch key [key ...]：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
   
   - unwatch： 取消 WATCH 命令对所有 key 的监视
   
   - ```shell
     127.0.0.1:6379> multi
     OK
     127.0.0.1:6379> set a 3
     QUEUED
     127.0.0.1:6379> lpop a
     QUEUED
     127.0.0.1:6379> exec
     1) OK
     2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
     ```

##### 03：过期策略

- 所有的数据结构都可以**设置过期时间**，时间⼀到就会⽴即删除；Redis 会将每个设置了**过期时间的 key 放⼊⼀个独⽴的字典**中, 以后会**定时遍历**这个字典来删除到期的 key，除了定时遍历之外, 还会使⽤**惰性删除的策略**: 在访问该 key 时再对过期时间进⾏检查，如果过期就删除并返回空；

- Redis 默认会 ：**每秒进⾏⼗次过期扫描**，过期扫描不会遍历过期字典中的所有 key，采⽤简单的**贪⼼策略**:
  1. 从过期字典中随机选取 20个 key
  2. 删除这 20个 key 中已经过期的
  3. 如果过期 key 的比例超过 1/4，那么就重复步骤1；
  4. **从库不会进⾏过期扫描**，主库在 key 到期的时候，会**在 AOF ⽂件中增加⼀条 del 指令**，同步到所有从库；

##### 04：内存淘汰

- 当 Redis **内存超出物理内存的时候**，内存的数据会开始和磁盘缠身频繁的交换, 会让 Redis 的性能急剧下降；
- 在⽣产环境中需要指定 **maxmemory 来限制内存超出期望⼤⼩**

###### 最大内存淘汰策略（maxmemory-policy）

1. noeviction：**不支持写请求，只支持读请求**，但线上的业务不会持续进⾏；
   - 默认的淘汰策略
2. volatile-lru：**设置了过期时间中最少使⽤的 key 优先被淘汰**，没有设置过期时间的 key 不会被淘汰；
   - 线上设置；
3. volatile-ttl：是 **key 的剩余寿命的 ttl 值**，值越⼩越优先被淘汰；
4. volatile-random：**随机淘汰设置过期时间的 key**；
5. allkeys-lru：对全体 key 使⽤ LRU 淘汰；
6. allkeys-random: 对全部的 key 进⾏随机淘汰；

###### 注意事项

- volatile-xxx ：策略只会针对带过期的时间的 key 进⾏淘汰
- allkeys-xxx ：策略会对所有的 key 进⾏淘汰
- 如果**只是做缓存**，那应该使⽤ allkeys-xxx，写缓存时不必携带过期时间
- 如果**还想同时使⽤ Redis 的持久化功能**，那就使⽤ volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰；

##### 05：持久化机制【两种】

###### 01：快照（RDB）

- 快照是**内存数据的⼆进制序列化形式 RDB文件**（保存数据库的状态），默认的持久化方式
- SAVE、**BGSAVE** 生成 rdb 文件，区别在在于：
  - SAVE：会**阻塞服务器进程**，直到 rdb 文件创建完毕为止，在服务器进程阻塞期间，服务器是不可以处理任何任务命令请求的；
  - BGSAVE：会 fork 一个子进程，创建 rdb 文件；
    - Redis 在持久化的时候，会 fork 出⼀个⼦进程，快照持久化完全交由⼦进程来处理，⽗进程继续处理客户端请求，⼦进程刚刚产⽣的时候,，和⽗进程共享代码段和数据段, 在进程分离的⼀瞬间, 内存⼏乎不会增加；
- **自动间隔性保存**：一般使用 BGSAVE，因为他不会阻塞服务器进程，可以**设置间隔时间来执行 BGSAVE 命令**
- **rdb文件的载入**：在服务器启动时自动载入的，没有用于载入的命令，只需要**将rdb文件放入redis安装目录**即可，期间阻塞主进程；
- 优点：
  1. 只有一个文件 dump.rdb 方便持久化
  2. 容灾性好，一个文件可以保存到安全磁盘
  3. 性能最化，fork子进程来完成写操作，让主进程继续处理命令
  4. RDB每一条数据只有一条记录，不会向AOF一条数据可能有多条记录，所以每条数据只需要写一次就够了，因此文件载入快；
- 缺点：
  1. 数据安全性较低，中途宕机，损失部分数据；

###### 02：AOF ⽇志：(append only file)

- AOF ⽇志记录的是**一条条修改内存数据的指令**，连续的增量备份；
- AOF ⽇志在⻓期的运⾏过程中会变的**⽆⽐庞⼤**，数据库重启时需要加载 AOF ⽇志进⾏指令重放, 这个时间就会⽆⽐漫⻓. 所以需要**定期进⾏ AOF 重写**，给 AOF ⽇志进⾏瘦身；
- **AOF 重写**
  - 通过新建AOF文件，来代替旧文件，并且两个文件所保存的数据库状态的一样的，但是新文件不会包含任任何冗余的命令，所以新文件要小的多；
  - 重写功能：通过读当前服务器的数据库状态来实现的；
  - Redis设置了一个AOF重写缓冲区，来记录fork过程中服务器还在处理命令，导致的数据库改变；
- 优点：
  - 数据安全性高，通过append模式写文件，即使中途服务器宕机可以通过**redis-check-aof工具**解决数据一致性问题；
- 缺点：
  1. 文件比rdb形式文件大；
  2. 数据集大比rdb启动效率低；

##### 06：主从复制

- redis 主从数据的同步是异步完成的，当客户端在主节点修改了数据之后会立即返回，由主节点完成对从节点的更新，因此**不满足一致性**，即使在主从节点中断连接的情况下，主节点依然对外提供读写服务，因此**满足可用性**；但是**最终会一致性**，从节点会尽力去追赶主节点，允许一段时间内的数据不一致，比如：网络断开，主从之间存在大量不一致，而当主从重新连接上后，会**通过各种策略重新保持一致**；

###### 增量同步

- redis 主从使用**指令流实现同步**，主节点会将**写指令记录在本地的buffer中，然后异步地同步到从节点**，从节点一边同步指令，一遍想主节点**反馈最新的同步进度（偏移量）**。
- 由于内存空间有限，redis使用**环形数组实现该buffer**，如果数据内容已满，就会将与原有的数据覆盖，在极端情况下，从节点如果落后指令太多，就**会存在未同步的指令被覆盖的问题**，此时就会尝试使用更复杂的机制实现同步—**快照同步**。

###### 全量同步【快照同步】

- 快照同步是一个非常消耗资源的操作，主节点需要**进行一次 bgsave** 来将当前内存中的数据全量持久化到磁盘文件中，再将磁盘文件整体发送给从节点，**从节点接收后，会将本地的数据全部清除，然后完成全量加载**，加载完毕后通知主节点进行增量同步。

##### 07：管道技术

- Redis 是一种基于客户端-服务端模型以及请求/响应协议的TCP服务

1. **客户端进程**调⽤ write 将消息写到**操作系统内核为 socket 分配的发送缓冲 send buffer**
2. 客户端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到服务端⽹卡
3. 服务端操作系统将⽹卡中的数据放到内核为 socket 分配的**接受缓冲 recv buffer**
4. 服务端进程**调⽤ read 将消息从接受缓冲取出并进⾏处理**
5. **服务端进程**调⽤ write 将执⾏结果写到内核为 socket 分配的发送缓冲 send buffer
6. 服务端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到客户端⽹卡
7. 客户端操作系统将⽹卡中的数据放到内核为 socket 分配的**接收缓冲 recv buffer**
8. 客户端进程调⽤ read 将消息从接收缓冲取出并返回给上层业务逻辑进⾏处理

###### 管道优势

- write 操作只需要**将数据写到本机操作系统内核的 send buffer 就返回,** 剩下的操作交由操作系统内核
  异步将数据发送到⽬标服务器;
- read 操作**只需要将数据从本机操作系统内核的 recv buffer 读取出来即可,** 但如果缓冲是空的, 就需要
  等待数据的到来, 这是 read 操作真正耗时的地⽅;
- 对于管道来说, 连续的 read 操作⼏乎不会耗时, **只有第⼀个 read 操作会等待⼀个⽹络的来回开销**, 然
  后所有的响应消息就都**已经回送到内核的接受缓冲**了, 后续的 read 操作直接就可以从缓冲拿到结果, 瞬
  间就返回了；

##### 08：Redis 6.0

- Redis 6.0 之前本身是单线程，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”；
- 使用Redis时，几乎不存在CPU成为瓶颈的情况，Redis 主要受限于内存和网络开销。

###### 阻塞IO

当使⽤ **socket** 的读写⽅法时, 默认是阻塞的, ⽐如 read ⽅法传⼊参数 n, 代表最多读取 n 个字节后再返回, 如果⼀个字节都没有，那么线程就会阻塞, 直到新的数据到来或者连接关闭才返回. ⽽ write ⼀般不会阻塞, 除⾮内核为 socket 分配的写缓冲区已经满了. socket 线程就会阻塞直到缓冲区有空闲空间。

###### 非阻塞IO

⾮阻塞 **IO 在套接字上提供了⼀个选项 Non_blocking,** 当这个选项打开的时候, 读写⽅法不会阻塞, **能读多少读多少, 能写多少写多少.** 能读多少取决于**内核为 socket 分配的读缓冲区内数据**, 能写多少取决于写缓冲区的空闲空闲字节数. **读写⽅法都会通过返回值来告知调⽤⽅实际读写了多少字节**，⾮阻塞 IO 意味着线程在读写 IO 的时候不必再阻塞, 读写可以瞬间完成然后线程继续其他任务；

###### IO多路复用

- 线程要读数据, 结果读了⼀部分就返回, 如何知道何时才应该继续读, 也就是当数据来了, 线程如何得到通知, 以及如果⼀次写不完, 剩下的数据应该何时才能继续写, 线程也应该得到通知；
- 是 IO 模型的一种，即经典的Reactor设计模式，有时也称为**异步阻塞IO**；
- **多路：指的是多个socket连接，复用：指的是复用一个线程。**
  - 多路复用主要有三种技术：select，poll，epoll。
  - epoll是最新的也是目前最好的多路复用技术。
  - 采用多路 I/O 复用技术**可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）**；
- 最简单的**事件轮询 API 就是 select 函数**, 它是操作系统提供给⽤户程序的 API, 输⼊是读写描述符 read_fds & write_fds, 输出的是与之对应的可读可写事件, 同时还提供了**⼀个 timeout 参数**, 如果没有任何事件到来, 那么线程最多阻塞 timeout 时间. ⼀旦期间没有任何读写事件到来, 就可以⽴即返回，拿到事件后, 线程就可以继续挨个处理响应的事件，处理完了继续过来轮询；

###### 多线程 Redis

- 因为读写网络的 read/write 系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗，因此**提高网络 IO 性能**或者**使用多线程充分利用多核**，来优化redis性能；

- 多线程**默认是禁用的**，只使用主线程。如需开启需要修改redis.conf配置文件

- 开启多线程后，还需要**设置线程数**，否则是不生效的。同样修改redis.conf配置文件，和核数对应；

- ```sh
  io-threads-do-reads yes
  io-threads 4
  ```

- Redis的多线程部分**只是用来处理网络数据的读写和协议解析**，执行命令仍然是单线程顺序执行，并不存在并发安全问题；

