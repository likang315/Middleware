### Redis 持久化

------

[TOC]

##### 01：概述

- 因为 Redis 是内存数据库， 它将自己数据库中的数据储存在内存里面， 所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面， 那么一旦服务器进程退出， 服务器中的数据库的数据也会消失不见。
- 两种持久化机制：RDB持久化和AOF持久化
  - RDB：保存数据库的键值对信息；
  - AOF：保存 Redis 服务器所执行的写命令；

##### 02：RDB 文件的创建和载入

- RDB持久化的两种方式
  - SAVE
    - SAVE命令会阻塞Redis 服务器进程， 直到RDB 文件创建完毕为止， 在服务器进程阻塞期间， 服务器不能处理任何命令请求：
  - BGSAVE
    - 派生出一个子进程，然后由子进程负责创建RDB 文件，服务器进程（ 父进程） 继续处理命令请求；
  - 创建 RDB 文件的实际工作由 **rdb.c/rdbSave** 函数完成， SAVE命令和BGSAVE 命令以不同的方式调用这个函数；
- RDB 文件的载入
  - 在服务器启动时自动执行的，所以 Redis 并没有专门用于载入 RDB 文件的命令，只要 Redis 服务器在启动时检测到 RDB 件存在， 它就会自动载入RDB 文件。
  - 载入RDB文件期间，服务器处于阻塞状态，直至载入完成为止；
  - 载入文件的工作由 **rdb.c/rdbLoad** 函数完成；
- 载入文件的优先级
  - 由于AOF的更新频率更高，因此只有**在 AOF 持久化功能处于关闭状态时**， 服务器才会使用 RDB 文件来还原数据库状态。

##### 03：AOF 持久化（Append Only File）

1. 命令追加：

   - 当 AOF 持久化功能处于打开状态时， 服务器在执行完一个写命令之后， 会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾；

2. 文件写入：写入到 AOF 文件缓冲区；

3. 文件同步：落盘；

   - 服务器每次结束一个事件循环之前， 它都会调用 flushAppendOnlyFile 函数， 考虑是否需要将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件里面；

4. | appendFsync | flushAppendOnlyFile 函数的行为（不同的行为效率和安全性不一样） |
   | :---------: | :----------------------------------------------------------- |
   |   always    | 将 aof_buf  缓冲区中的所有内容写入并同步到AOF 文件           |
   |  everysec   | 将 aof_buf  缓冲区中的所有内容写人到AOF 文件， 如果上次同步AOF 文件的时间距离现在超过一秒钟， 那么再次对 AOF 文件进行同步， 并且这个同步操作是由一个线程； |
   |     No      | 将 aof_buf 缓冲区中的所有内容写人到AOF 文件， 但并不对AOF 文件进行同步，何时进行同步由操作系统来决定； |

##### 04：AOF 文件的载入和数据还原

1. 创建一个不带网络连接的伪客户端(fake client ) : 因为 Redis 的命令只能在客户端上下文中执行， 而载入AOF 文件时所使用的命令直接来源于AOF 文件而不是网络连接， 所以服务器使用了一个没有网络连接的伪客户端来执行 AOF 文件保存的写命令， 伪客户端执行命令的效果和带网络连接的客户端执行服务器启动载人程序创建伪客户端命令的效果完全一样。

2. 从AOF 文件中分析并读取出一条写命令。

3. 使用伪客户端执行被读出的写命令。

4. 一直执行步骤2和步骤3, 直到AOF文件中的所有写命令都被处理完毕为止，当完成以上步骤之后， AOF 文件所保

   存的数据库状态就会被完整地还原出来。

##### 05：SAVE 命令执行时的服务器状态

- SAVE、BGSAVE、BGREWRITEAOF  三者关系
  - SAVE 命令执行期间，拒绝一切命令；
  - BGSAVE 命令执行期间，禁止SAVE执行（父子进程竞争），BGREWRITEAOF 命令会延迟到BGSAVE命令执行完成之后执行；
  - BGREWRITEAOF  命令执行期间，拒绝以上两个命令执行；

##### 06：自动间隔性保存

- Redis 允许用户通过设置服务器配置的 save 选项， 让服务器**每隔一段时间自动执行一次 BGSAVE 命令**；
- 可以通过 save 选项设置多个保存条件， 但只要其中任意一个条件被满足， 服务器就会执行命令。

###### 设置保存条件

- 服务器状态

  - ```c
    struct redisServer {
        // 记录了保存条件的数组
    	Struct saveparam *saveparams;
        // 修改计数器
    	long long dir七y;
    	//上一次执行保存的时间
    	time_t lastsave;
    }；
    ```

    

- 服务器状态（redisSever）结构的saveparam属性中；

- saveparams 属性是一个数组， 数组中的每个元素都是一个saveparam 结构

  - ```c
    // 多少秒内，修改了多少次
    struct saveparam {
    	// 秒数
    	time_t seconds;
    	// 修改数
    	int changes;
    }
    ```

###### dirty 计数器和 lastsave 属性

- 除了savepararns 数组之外， 服务器状态还维持着一个 dirty 计数器， 以及一个 lastsave 属性；
  - dirty计数器：记录距离上一次成功执行 SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库） 进行了多少次修改。
  - lastsave 属性是一个UNIX 时间戳， 记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。

###### 检查保存条件是否满足

- Redis 的服务器周期性操作函数 severCron 默认每隔 100 毫秒就会执行一次， 该函数用于对正在运行的服务器进行维护， 它的其中一项工作就是检查 save 选项所设置的保存条件是否已经满足， 如果满足的话， 就执行BGSAVE 命令，执行完成后，清除dirty;

##### 07：RDB文件结构

- <img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/rdb_struct.png" style="zoom:45%;" />

1. **redis：**RDB 文件的最开头是 REDIS 部分，这个部分的长度为 5 字节，保存着"REDIS" 五个字符。通过这五个字符,程序可以在载文件时， 快速检查所载入的文件是否RDB 文件。
2. **db_version：** 长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号；
3. **databases：**包含着零个或任意多个数据库， 以及各个数据库中的键值对数据：
   - 如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0 字节。
   - 如果服务器的数据库状态为非空（ 有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。
4. **EOF：**常量的长度为1 字节， 这个常量标志着RDB 文件正文内容的结束， 当读入程序遇到这个值的时候， 它知道**所有数据库的所有键值对都已经载入完毕**了。
5. **check_sum：**是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db _version、databases、EOF 四个部分的内容进行计算得出的。
   - 服务器在**载入RDB 文件时**，会将载人数据**所计算出的校验和与 check_sum 所记录的校验和进行对比**， 以此来检查RDB 文件是否有出错或者损坏的情况出现。

###### database 部分

- **SELECTDB** 常量的长度为1 字节， 当读入程序遇到这个值的时候， 它知道接下来要读人的将是一个数据库下标；
- **db_number：**保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1 字节、2字节或者5 字节。当程序读人db_number 部分之后，服务器**会调用SELECT命令，根据读入的数据库号码进行数据库切换**， 使得之后读入的键值对可以载入到正确的数据库中。
- **key_value_pairs：**部分保存了数据库中的所有键值对数据， 如果键值对带有过期时间， 那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同， key_value_pairs部分的长度也会有所不同；

###### key_value_pairs 部分

- 不带过期时间的键值对在RDB 文件中由TYPE、key 、value三部分组成；
  - TYPE 记录了va lue的类型， 长度为1 字节；
- 带有过期时间的键值对，新增的EXPIRETIME_MS 和 ms 两部分；
  - EXPIRETIME_MS 常量的长度为1 字节，它告知读入程序， 接下来要读入的将是一个以毫秒为单位的过期时间。
  - ms 是一个8字节长的带符号整数， 记录着一个以毫秒为单位的UNIX时间戳， 这个时间戳就是键值对的过期时间。

###### value的编码

- 列表对象为例：
  - list_len：列表元素的个数；
  - len1：第一个元素的长度；
  - key：第一个元素；

##### 08：分析RDB文件

- 使用 OD 命令，分析RDB文件，该命令可以用指定的格式转存（dump）并打印输入文件；
- od -c dump.rdb
  - 使用ASCII码的方式打文件；
- redis 自带 的RDB 文件检查工具：redis-check-dump；

##### 09：AOF重写（BGREWRITEAOF）

- 体积过大的AOF 文件很可能对 Redis服务器、甚至整个宿主计算机造成影响， 并且AOF 文件的体积越大， 使用AOF 文件来进行**数据还原所需的时间就越多**。

###### AOF 文件重写的实现

- 实际上 AOF 文件重写并**不需要**对现有的AOF 文件进行任何读取、分析或者写入操作，这个功能是通过**读取服务器当前的数据库状态**来实现的。
- 缓冲区溢出：在实际中， 为了避免在执行命令时造成客户端输入缓冲区溢出， 重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时， 会先检查键所包含的元素数量， 如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_TIMES_PRE_CMD  常量的值， 那么重写程序将会**使用多条命令来记录键的值**。

###### AOF 重写流程

1. Redis执行 fork() ，现在同时拥有父进程和子进程。
2. 子进程开始将新 AOF 文件的内容写入到新的AOF文件，对于所有新执行的写入命令，父进程一边将它们累积到一个 **AOF 重写缓冲区** ，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。
3. 当子进程完成重写工作时，它**给父进程发送一个信号**，父进程在接收到信号之后，将AOF重写缓冲区 的所有数据追加到新 AOF 文件的末尾。
4. 对新的AOF 文件进行改名， 原子地(atomic) 覆盖现有的AOF 文件，完成新旧两个AOF 文件的替换。



