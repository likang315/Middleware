### Redis 持久化

------

[TOC]

##### 01：概述

- 因为 Redis 是内存数据库， 它将自己数据库中的数据储存在内存里面， 所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面， 那么一旦服务器进程退出， 服务器中的数据库的数据也会消失不见。
- 两种持久化机制：RDB持久化和AOF持久化
  - RDB：保存数据库的键值对信息；
  - AOF：保存 Redis 服务器所执行的写命令；

##### 02：RDB 文件的创建和载入

- RDB持久化的两种方式
  - SAVE
    - SAVE命令会阻塞Redjs 服务器进程， 直到RDB 文件创建完毕为止， 在服务器进程阻塞期间， 服务器不能处理任何命令请求：
  - BGSAVE
    - 派生出一个子进程，然后由子进程负责创建RDB 文件，服务器进程（ 父进程） 继续处理命令请求；
  - 创建 RDB 文件的实际工作由 **rdb.c/rdbSave** 函数完成， SAVE命令和BGSAVE 命令以不同的方式调用这个函数；
- RDB 文件的载入
  - 在服务器启动时自动执行的，所以 Redis 并没有专门用于载入 RDB 文件的命令，只要 Redis 服务器在启动时检测到 RDB 件存在， 它就会自动载入RDB 文件。
  - 载入RDB文件期间，服务器处于阻塞状态，直至载入完成为止；
  - 载入文件的工作由 **rdb.c/rdbLoad** 函数完成；
- 载入文件的优先级
  - 由于AOF的更新频率更高，因此只有**在 AOF 持久化功能处于关闭状态时**， 服务器才会使用 RDB 文件来还原数据库状态。

##### 03：SAVE 命令执行时的服务器状态

- SAVE、BGSAVE、BGREWRITEAOF  三者关系
  - SAVE 命令执行期间，拒绝一切命令；
  - BGSAVE 命令执行期间，禁止SAVE执行（父子进程竞争），BGREWRITEAOF 命令会延迟到BGSAVE命令执行完成之后执行；
  - BGREWRITEAOF  命令执行期间，拒绝以上两个命令执行；

##### 04：自动间隔性保存

- Redis 允许用户通过设置服务器配置的 save 选项， 让服务器**每隔一段时间自动执行一次 BGSAVE 命令**；
- 可以通过 save 选项设置多个保存条件， 但只要其中任意一个条件被满足， 服务器就会执行命令。

###### 设置保存条件

- 服务器状态

  - ```c
    struct redisServer {
        // 记录了保存条件的数组
    	Struct saveparam *saveparams;
        // 修改计数器
    	long long dir七y;
    	//上一次执行保存的时间
    	time_t lastsave;
    }；
    ```

    

- 服务器状态（redisSever）结构的saveparam属性中；

- saveparams 属性是一个数组， 数组中的每个元素都是一个saveparam 结构

  - ```c
    // 多少秒内，修改了多少次
    struct saveparam {
    	// 秒数
    	time_t seconds;
    	// 修改数
    	int changes;
    }
    ```

###### dirty 计数器和 lastsave 属性

- 除了savepararns 数组之外， 服务器状态还维持着一个 dirty 计数器， 以及一个 lastsave 属性；
  - dirty计数器：记录距离上一次成功执行 SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库） 进行了多少次修改。
  - lastsave 属性是一个UNIX 时间戳， 记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。

###### 检查保存条件是否满足

- Redis 的服务器周期性操作函数 severCron 默认每隔 100 毫秒就会执行一次， 该函数用于对正在运行的服务器进行维护， 它的其中一项工作就是检查 save 选项所设置的保存条件是否已经满足， 如果满足的话， 就执行BGSAVE 命令，执行完成后，清除dirty;

##### 05：RDB文件结构

- <img src="/Users/likang/Code/Git/Middleware/04：Redis/photos/rdb_struct.png" style="zoom:45%;" />

1. **redis：**RDB 文件的最开头是 REDIS 部分，这个部分的长度为 5 字节，保存着"REDIS" 五个字符。通过这五个字符,程序可以在载文件时， 快速检查所载入的文件是否RDB 文件。
2. **db_version：** 长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号；
3. **databases：**包含着零个或任意多个数据库， 以及各个数据库中的键值对数据：
   - 如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0 字节。
   - 如果服务器的数据库状态为非空（ 有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。
4. **EOF：**常量的长度为1 字节， 这个常量标志着RDB 文件正文内容的结束， 当读入程序遇到这个值的时候， 它知道**所有数据库的所有键值对都已经载入完毕**了。
5. **check_sum：**是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db _version、databases、EOF 四个部分的内容进行计算得出的。
   - 服务器在**载入RDB 文件时**，会将载人数据**所计算出的校验和与 check_sum 所记录的校验和进行对比**， 以此来检查RDB 文件是否有出错或者损坏的情况出现。

###### database 部分

- **SELECTDB** 常量的长度为1 字节， 当读入程序遇到这个值的时候， 它知道接下来要读人的将是一个数据库下标；
- **db_number：**保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1 字节、2字节或者5 字节。当程序读人db_number 部分之后，服务器**会调用SELECT命令，根据读入的数据库号码进行数据库切换**， 使得之后读入的键值对可以载入到正确的数据库中。
- **key_value_pairs：**部分保存了数据库中的所有键值对数据， 如果键值对带有过期时间， 那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同， key_value_pairs部分的长度也会有所不同；

###### key_value_pairs 部分

- 不带过期时间的键值对在RDB 文件中由TYPE、key 、value三部分组成；
  - TYPE 记录了va lue的类型， 长度为1 字节；
- 带有过期时间的键值对，新增的EXPIRETIME_MS 和 ms 两部分；
  - EXPIRETIME_MS 常量的长度为1 字节，它告知读入程序， 接下来要读入的将是一个以毫秒为单位的过期时间。
  - ms 是一个8字节长的带符号整数， 记录着一个以毫秒为单位的UNIX时间戳， 这个时间戳就是键值对的过期时间。

###### value的编码

- 列表对象为例：
  - list_len：列表元素的个数；
  - len1：第一个元素的长度；
  - key：第一个元素；

##### 06：分析RDB文件

- 使用 OD 命令，分析RDN文件，该命令可以用指定的格式转存（dump）并打印输入文件；
- od -c dump.rdb
  - 使用ASCII码的方式打文件；
- redis 自带 的RDB 文件检查工具：redis-check-dump；

##### 07：AOF 持久化（Append Only File）的实现

- 



























