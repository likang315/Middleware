### Redis 特性

------

[TOC]

##### 02：Redis 事务

1. 批量操作在发送 EXEC 命令前被**放入队列缓存**；
2. **收到 EXEC 命令后进入事务执行**，事务中任意命令执行失败，其余的命令依然被执行，没有原子性；
3. 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中，隔离性；
4. 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 **Redis 事务的执行并不是原子性的**； 
   - Multi：标记一个事务块的开始
   
   - Exec： 执行所有事务块内的命令
   
   - discard ：取消事务，放弃执行事务块内的所有命令
   
   - watch key [key ...]：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
   
   - unwatch： 取消 WATCH 命令对所有 key 的监视
   
   - ```shell
     127.0.0.1:6379> multi
     OK
     127.0.0.1:6379> set a 3
     QUEUED
     127.0.0.1:6379> lpop a
     QUEUED
     127.0.0.1:6379> exec
     1) OK
     2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
     ```

##### 04：内存淘汰

- 当 Redis **内存超出物理内存的时候**，内存的数据会开始和磁盘缠身频繁的交换, 会让 Redis 的性能急剧下降；
- 在⽣产环境中需要指定 **maxmemory 来限制内存超出期望⼤⼩**

###### 最大内存淘汰策略（maxmemory-policy）

1. noeviction：**不支持写请求，只支持读请求**，但线上的业务不会持续进⾏；
   - 默认的淘汰策略
2. volatile-lru：**设置了过期时间中最少使⽤的 key 优先被淘汰**，没有设置过期时间的 key 不会被淘汰；
   - 线上设置；
3. volatile-ttl：是 **key 的剩余寿命的 ttl 值**，值越⼩越优先被淘汰；
4. volatile-random：**随机淘汰设置过期时间的 key**；
5. allkeys-lru：对全体 key 使⽤ LRU 淘汰；
6. allkeys-random: 对全部的 key 进⾏随机淘汰；

###### 注意事项

volatile-xxx ：策略只会针对带过期的时间的 key 进⾏淘汰

- allkeys-xxx ：策略会对所有的 key 进⾏淘汰
- 如果**只是做缓存**，那应该使⽤ allkeys-xxx，写缓存时不必携带过期时间
- 如果**还想同时使⽤ Redis 的持久化功能**，那就使⽤ volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰；

##### 07：管道技术

- Redis 是一种基于客户端-服务端模型以及请求/响应协议的TCP服务

1. **客户端进程**调⽤ write 将消息写到**操作系统内核为 socket 分配的发送缓冲 send buffer**
2. 客户端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到服务端⽹卡
3. 服务端操作系统将⽹卡中的数据放到内核为 socket 分配的**接受缓冲 recv buffer**
4. 服务端进程**调⽤ read 将消息从接受缓冲取出并进⾏处理**
5. **服务端进程**调⽤ write 将执⾏结果写到内核为 socket 分配的发送缓冲 send buffer
6. 服务端内核将 send buffer 的内容发送到⽹卡, ⽹卡将数据通过⽹际路由发送到客户端⽹卡
7. 客户端操作系统将⽹卡中的数据放到内核为 socket 分配的**接收缓冲 recv buffer**
8. 客户端进程调⽤ read 将消息从接收缓冲取出并返回给上层业务逻辑进⾏处理

###### 管道优势

- write 操作只需要**将数据写到本机操作系统内核的 send buffer 就返回,** 剩下的操作交由操作系统内核
  异步将数据发送到⽬标服务器;
- read 操作**只需要将数据从本机操作系统内核的 recv buffer 读取出来即可,** 但如果缓冲是空的, 就需要
  等待数据的到来, 这是 read 操作真正耗时的地⽅;
- 对于管道来说, 连续的 read 操作⼏乎不会耗时, **只有第⼀个 read 操作会等待⼀个⽹络的来回开销**, 然
  后所有的响应消息就都**已经回送到内核的接受缓冲**了, 后续的 read 操作直接就可以从缓冲拿到结果, 瞬
  间就返回了；

##### 08：Redis 6.0

- Redis 6.0 之前本身是单线程，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”；
- 使用Redis时，几乎不存在CPU成为瓶颈的情况，Redis 主要受限于内存和网络开销。

###### 阻塞IO

当使⽤ **socket** 的读写⽅法时, 默认是阻塞的, ⽐如 read ⽅法传⼊参数 n, 代表最多读取 n 个字节后再返回, 如果⼀个字节都没有，那么线程就会阻塞, 直到新的数据到来或者连接关闭才返回. ⽽ write ⼀般不会阻塞, 除⾮内核为 socket 分配的写缓冲区已经满了. socket 线程就会阻塞直到缓冲区有空闲空间。

###### 非阻塞IO

⾮阻塞 **IO 在套接字上提供了⼀个选项 Non_blocking,** 当这个选项打开的时候, 读写⽅法不会阻塞, **能读多少读多少, 能写多少写多少.** 能读多少取决于**内核为 socket 分配的读缓冲区内数据**, 能写多少取决于写缓冲区的空闲空闲字节数. **读写⽅法都会通过返回值来告知调⽤⽅实际读写了多少字节**，⾮阻塞 IO 意味着线程在读写 IO 的时候不必再阻塞, 读写可以瞬间完成然后线程继续其他任务；

###### 多线程 Redis

- 因为读写网络的 read/write 系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗，因此**提高网络 IO 性能**或者**使用多线程充分利用多核**，来优化redis性能；

- 多线程**默认是禁用的**，只使用主线程。如需开启需要修改redis.conf配置文件

- 开启多线程后，还需要**设置线程数**，否则是不生效的。同样修改redis.conf配置文件，和核数对应；

- ```sh
  io-threads-do-reads yes
  io-threads 4
  ```

- Redis的多线程部分**只是用来处理网络数据的读写和协议解析**，执行命令仍然是单线程顺序执行，并不存在并发安全问题；

