### ZooKeeper 的应用场景

------

[TOC]

##### 01：概述

- 从实际的场景出发，演示如何使用 Zookeeper 去解决一些常见的分布式问题；
- ZooKeeper是一个典型的发布/订阅模式的分布式数据管理与协调服务（框架），开发人员可以使用它来进行分布式数据的发布与订阅。

##### 02：数据发布/订阅【配置中心】

- 数据发布/订阅系统，即所谓**配置中心**。发布者将数据发布到Zookeeper 的一个或一系列节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。
- ZooKeeper 采用的是**推拉相结合**的方式，客户端向服务端注册自己需要关注的节点，一旦该节点的数据发生变更，那么服务端就会向相应客户端发送Watcher事件通知，客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据。
- 如果将配置信息存放到ZooKeeper上进行集中管理，那么通常情况下，应用在**启动的时候都会主动到ZooKeeper服务端上进行一次配置信息的获取**，同时在指定节点上注册一个Watcher监听，这样一来，但凡有配置信息发生变更，**服务端都会实时通知到有所订阅的客户端**，从而达到实时获取最新配置信息的目的。

###### 示例：数据库切换

- 需要将初始化配置存储到ZooKeeper上去。一般情况下，我们可以在ZooKeeper上选取**一个数据节点用于配置的存储**。
- 配置获取
  - 集群中每台机器启动在初始化阶段，首先会从上面提到的ZooKeeper配置节点上读取数据库信息，同时客户端还需要在该配置节点上注册一个数据变更的Watcher监听，一旦发生节点数据变更，所有订阅的客户端都能够获取到数据变更知。
- 配置变更
  - 在**系统运行过程中**，可能会出现需要进行数据库切换的情况，这个时候就需要进行配置变更。借助ZooKeeper，我们只需要对ZooKeeper上配置的节点内容进行更新，ZooKeeper就能够帮帮我们将数据的变更通知发送到各个客户端，每个客户端在接收到这个变更通知后，就可以重新进行最新数据的获取。

##### 03：命名服务【Dubbo】

- 在分布式系统中，被命名的实体通常可以是**集群中的机器、提供服务的地址或远程对象**等——这些我们都可统称以它们为名字(Name)，其中较为常见的就是一些**分布服务式框架(如RPC、RMI)中的服务地址列表**，通过使用命名服务，客户端应用能够根据指定名字来获取资源的实体、服务地址和提供者的信息等；
- 服务注册
  - 服务提供者向ZK写入提供的服务信息及地址；
  - 定时心跳，告知ZK 服务是否正常；
- 服务调用
  - 消费者启动时向ZK拉取提供的服务信息及地址，并向该数据节点注册一个Watcher，服务变更时是及时通知注册的消费端；

##### 04：分布式协调/通知【重要】

- 对于一个在多台机器上部署运行的应用而言，通常**需要一个协调者(Coordinator)来控制整个系统的运行流程**，例如分布事务式的处理、机器间的互相协调等。引入这样一协调个者，便于将分布式协调职责的从应用中分离出来，从而可以大大减少系统之间的耦合，而且能够显著的提高系统的可扩展性。

###### 实现原理

- ZK 实现分布式协调与通知功能的原理是不同的客户端都对ZooKeeper上同一个数据节点进行Watcher注册，监听数据节点的变化〈包括数据节点本及其子节点)，如果数据节点发生变化，那么所有的订阅客户端都能够接收到相应的Watcher通知，并做出相应的处理。

###### 示例：MySQL  数据复制总线（Mysql_Replicator）

- 是一个实时的数据复制框架，用于在不同的MySQL 数据库实例之间进行异步数据复制和数据变化通知。

###### 数据复制的核心逻辑

- core进程在启动的时候，首先会向 **/mysql_replicator/tasks 节点**〈“任务列表节点”)注册任务。
  - 例如：对于一个“复制热门商品”的任务，Task 所在机器在启动的时候，会首先在任务列表节点上创建一个子节点，例如**/mysql_replicator/tasks/copy_hot_task** (“任务节点")。如果在注册过程中发现该子节点已经存在，说明已经有其他Task机器注册了该任务，因此自己不需要再创建该节点了。
- 任务热备份
  - 复制组件采用 “热备份” 的容灾方式，即**将同一个复制任务部署在不同的主机上，我们称这样的机器为 “任务机器”**，主、
    备任务机器通过 ZooKeeper 互相检测运行健康状况。
  - 实现：（完成了分布式协调）
    1. 无论第一步中是否创建了任务节点，每台任务机器都需要在 **/mysql_replicator/tasks/copy_hot_task/instances**节点上将自己的主机名注册上去。注意，这里注册的节点类型很特殊，是**一个临时的顺序节点**。在注册完这个子节点后，通常一个完整的节点名如下：**/mysql_replicator/tasks/copy_hot_task/instances/hostname-1**，其中最后的序列号就是临时顺序节点的精华所在。
    2. **小序号优先策略：**在完成该子节点的创建后，每台任务机器都可以获取到自己创建的节点的完整节点名以及所有子节点的列表，然后通过对比判断自己是否是所有子节点中序号最小的。**如果自己序号是最小的子节点，那么就将自己运行的状态设置为RUNNING，其余的任务机器则将自己设置为STANDBY**。
    3. **StANDBY（待命状态）：**一旦标记为 RUNNING 的机器出现故障停止了任务执行，那么就需要在所有标记为STANDBY 的客户端机器中再次按照 “小序号优先” 策略来选出 RUNNING 机器来执行。
       - 标记为 STANDBY 的机器都需要在 /mysql_replicator/tasks/copy_hot_task/instances 节点上**注册一个“子节点列表变更” 的Watcher 监听器**，用来订阅所有任务执行机器的变化情况，**一旦 RUNNING 机器宕机与ZooKeeper**
         **断开连接后，对应的节点就会消失，于是其他机器也就接收到了这个变更通知**，从而开始新一轮的RUNNING 选举。

###### 通用的分布式系统机器间通信方式

1. ZK 实现心跳检测
   - 基于ZooKeeper的临时节点特性，可以**让不同的机器都在ZooKeeper的一个指定节点下创建临时子节点，不同的机器之间可以根据这个临时节点来判断对应的客户端机器是否存活**。通过这种方式，检测系统和被检测系统间之并不需要直接相关联，而是通过ZooKeeper上的某个节点进行关联，大大减少了系统间的耦合。
2. 工作进度汇报
   - 在一个常见的任务分发系统中，通常任务被分发到不同的机器上执行后，需要实时地将自己任务的执行进度汇报给分发系统。这个时候就可以通过ZooKeeper来实现。
   - 在 ZooKeeper上选择一个节点，每个执行任务的机器都在这个节点下面创建临时子节点，这样做可以实现两个功能：
     1. 通过判断临时节点是否存在来确定任务机器是否存活；
     2. 每个任务机器自己都会实时地将任务的执行进度写到这个临时节点上去，以便中心系统能够实时地获取到任务的执行进度。
3. 系统调度
   - 一种调度模式：一个分布式系统由控制台和一些客户端系统两部分组成，控制台的职责就是需要将一些指令信息发送给所有的客户端，以控制它们进行相应的业务逻辑。
   - 例如：管理人员在控制台上做的一些操作，实际上就是修改了 ZooKeeper 上某些节点的数据，而 ZooKeeper 进一步把这些数据变更以事件通知的形式发送给对应订阅的客户端。

##### 05：集群管理

- 所集群谓管理，包括**集群监控与集群控制**两大块，前者侧重对集群运行时状态的收集，后者则是对集群进行操作与控制。
  - 集群中在线有多少机器工作；
  - 对集群中每台机器的运行时状态进行数据收集；
  - 对集群中机器进行上下线操作；

###### 基于 ZK 实现的集群控制

- 机器的上线时，向ZK 机器列表下创建一个临时节点，临时节点删除时，机器下线。

###### 传统的集群监控方式

- 基于的 Agent 的分布式集群管理体系中，都是通过**在集群中的每台机器上部署一个Agent（字节码增强）**，由这个 Agent 负责主动向指定的一个监控中心系统（哨兵）汇报自己所在机器的状态。
- 弊端
  1. 大规模升级困难；
  2. 统一的Agent 无法满足多样的需求；
  3. 编程语言的多样性；

###### 基于 ZK 的集群监控方式（分布式日志收集中心）

- 收集器模块：核心就是收集分布在不同机器上的系统日志。
- 在一个典型的日志收集系统架构设计中，整个日志系统会把所有**需要收集的日志机器（日志源机器）分为多个组，每个组对应一个收集器，这个收集器其实就是一个台机器(收集器)**，用于收集日志。对于日志收集系统需要解决两个问题；
  - 多变的日志源机器；
  - 多变的日志收集器；

###### 基于 ZK 实现的分布式日志收集中心

- 注册收集器（持久结点）
  - 在ZooKeeper上创建一个节点作为收集器的根节点，例如：/logs/collector，每个收集器机器在启动时，都会在收集器节点下创建自己的节点；
- 任务分发
  - 待所有收集器都创建好自己对应的节点后，系统根据收集器根节点下的子节点个数，将所有日志源机器分成对应的若干组，然后将分组后的日志源机器列表分别写到这些收集器创建的节点（例如：/logs/collector/host1）上。这样一来，每个收集器都能够从自己对应的节点上获取日志源机器列表，进而开始进行日志收集工作。
- 状态汇报
  - 每个收集器机器在创建完自己的专属节点后，还需要在对应的子节点上创建一个状态子节点，例如：**/logs/collector/host1/status**，每个收集器机器都需要**定期向该节点写入自己的状态信息**。
  - 这种策略看作是一种心跳检测机制，通常收集器机器都会在这个节点中写入日志收集进度信息。日志系统根据该状态子节点的最后更新时间来判断对应的收集器机器是否存活；
- 动态分配
  - 如果收集器机器挂掉或扩容时，就需要动态地进行收集任务的重分配。在运行过程中，日志系统（进程）始终关注着。/logs/collector 这节点个下所有子节点的变更，一旦检测到有收集器机器停止汇报或是有新的收集器机器加入时，就要开始进行任务的重分配。
    - 全局动态分配
    - 局部动态分配
      - 负载高的收集器（负责的日志源机器）向低负载的收集器转移；

##### 06：Leader 选举

- 所有的客户端机器**都向ZK同时注册一个相同的数据节点**，但只有一个机器能注册成功，那么这台机器就成为了Leader，其他**没有在ZK 上成功注册节点的机器，都会在该节点上注册一个子节点变更的Watcher**，一旦发现当前Leader 宕机，那么其余机器将会重新进行Leader 选举。

##### 07：分布式锁

###### 基于 ZK 实现独占锁

- **定义锁：**通过 ZooKeeper上的数据节点来表示一个锁，例如：/exclusive_lock/lock节点 定义为一个独占锁；
- **获取锁（加锁）：**在需要获取排他锁时，所有的客户端都会试图通过调用 create() 接口，在 /exclusive_lock 节点下创建**临时子节点/exclusive_lock/lock** 。成功创建节点的客户端获得了锁，没有获取锁的客户端需要在 /exclusive_lock 节点上注册一个子节点变更的 Watcher 监听，以便实时监听lock 节点的变更情况。
- **释放锁：**当移除lock 节点后，zk 都会通知所有在 /exclusive_lock 节点上注册了子节点变更 Watcher 监听的客户端。这些客户端在接收到通知后，再次重新发起分布式锁获取，即重复“获取锁”过程。

###### 基于 ZK 实现共享锁

- **定义锁：**同样用一个节点表示锁，例如：/shared_lock/host_name-请求类型-序号的**临时顺序节点**。
- **获取锁：**在需要获取共享锁时，所有客户端都会到 /shared_lock 这个节点下面创建一个临时顺序节点，如果当前是读请求，那么创建就例如：shared_lock/192.768.0.7-R-0000000001 的节点。如果是写请求，那么创建就例如：/shared_lock/192.168.0.7-W-0000000002的节点。
- **实现读写顺序：**
  1. 创建完节点后，获取 /shared_lock 节点下的所有子节点，并对该节点注册子节点变更的Watcher监听。
  2. 确定自己的节点序号在所有子节点中的顺序。
  3. **对于读请求：**
     - 如果没有比自己序号小的子节点，或是所有比自己序号小的子节点都是读请求，那么表明自己已经成功获取到了共享锁，同时开始执行读取逻辑。如果自己比序号小的子节点中有写请求，那么需要就进入等待。
  4. **对于写请求:**
     - 如果自己不是序号最小的子节点，那么需要就进入等待。
  5. 接收到Watcher通知后，重复步骤1。
- **释放锁：**同独占锁。

###### ZK 的羊群效应（共享锁的优化）

- 定义：如果同一时间有多个节点对应的客户端完成事务或是事务中断引节点起消失，ZooKeeper服务器就会在短时间内向其余客户端发送大量的事件通知；
- 在整个分布式锁的竞争过程中，大量的“Watcher通知”和“子节点列表获取”两个操作重复运行，并且绝大多数运行的结果都判断出自己并非是序号最小的节点，从而继续等待下一通知。这个看起来显然不怎么科学。监听的客户多时，导致ZK的性能急剧下降，并且客户端收到过多的和自己不相关的通知，。
- **优化点：**每个锁竟争者，只需要关注 /shared_lock 节点下序号比自己小的那个节点是否存在即可；
  1. 客户端调用 create() 方法创建一个类似于 shared_lock/192.768.0.7-R-0000000001 的临时顺序节点。
  2. 客户端调用 getChildren() 接口来获取所有已经创建的子节点列表，注意，这里不注册任何Watcher。
  3. 如果无法获取共享锁，那么就**调用 exist() 来对比自己小的那个节点注册Watcher**。
     - 读请求：向比自己序号小的最后一个写请求节点注册Watcher监听。
     - 写请求：向比自己序号小的最后一个节点注册Watcher监听。
  4. 等待Watcher通知，继续进入步骤2。

##### 08：分布式队列

- 分布式队列，简单讲分为两大类
  1. 常规的先人先出队列；
  2. 要等到队列元集聚之后才统一安排执行的Barrier模型；

###### 基于 ZK 实现FIFO：先入先出

- 所有客户端都会到 /queue_fifo 这个节点下面创建一个临时顺序节点，例如：/queue_fifo - hostname1- 0000000007
- 执行顺序
  1. 通过调用 getChildren() 接口来获取 /queue_fifo 节点下所有的子节点，即获取队列中所有的元素。
  2. 确定自己的节点序号在所有子节点中的顺序。
  3. 如果自己不是序号最小的子节点，那么就需要进入等待，同时向比自己序号小的最后一个节点注册Watcher监听。
  4. 接收到Watcher通知后，重复步骤1。

###### 基于 ZK 实现Barrier：分布式屏障

- Barrier原意是指屏障，而在分布式系统中，特指系统间之间的一个协调条件，规定了一个队列的元素必须都集聚后才能统一进行安排，否则一直等待。
  - 例如：分布式并行计算场景中，各个计算结果都汇总后，才进行下一步。
- 实现方案：/queue_barrier 节点是一个已经存在的默认节点，并且将其节点的数据内容赋值为一个数字n 来代表Barrier值，例如：n=10 表示只有当 /queue_barrier 节点下的子节点个数达到10后，才会打开Barrier。之后，所有的客户端都会到 /queue_barrier 节点下创建一个临时节点，例如 /queue_barrier/127.168.0.1。











