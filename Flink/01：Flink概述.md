### Flink 概述

------

[TOC]

------

##### 01：流处理

- 数据的产生原本就是流式的，因此分析数据时，可以围绕 有界流（bounded）或 无界流（unbounded）两种模型来组织处理数据。
- **批处理：**是有界数据流处理的范例。在这种模式下，你可以选择在计算结果输出之前输入整个数据集，这也就意味着你可以对**整个数据集的数据**进行排序、统计或汇总计算后再输出结果。
- **流处理：**正相反，其涉及无界数据流。至少理论上来说，它的**数据输入永远不会结束**，因此程序必须持续不断地对到达的数据进行处理。

- 在 Flink 中，应用程序由用户自定义**算子**转换而来的**流式 dataflows** 所组成。这些流式 dataflows 形成了有向图，以一个或多个**源**（source）开始，并以一个或多个**汇**（sink）结束。
- 通常，程序代码中的 **transformation 和 dataflow 中的算子（operator）之间是一一对应的**。但有时也会出现一个 transformation 包含多个算子的情况，Flink 应用程序可以消费来自**消息队列或分布式日志**这类流式数据源的实时数据，也可以从各种的数据源中消费有界的历史数据。同样，Flink 应用程序生成的结果流也可以发送到各种数据汇中。
- ![Flink_DataStream](/Users/likang/Code/Git/Middleware/Flink/photos/Flink_DataStream.jpg)

##### 02：DataFlows

- Flink 程序本质上是分布式并行程序。
- 在程序执行期间，一个流有**一个或多个流分区**（Stream Partition），每个算子**有一个或多个算子子任务**（Operator Subtask）。每个子任务彼此独立，并在不同的线程中运行，或在不同的计算机或容器中运行,算子子任务数就是其对应**算子的并行度**。
- ![Flink_Parallelism](/Users/likang/Code/Git/Middleware/Flink/photos/Flink_Parallelism.jpg)
- Flink 算子之间可以通过**一对一（直传）模式或重新分发模式传输数据**
  - **一对一模式：**（例如上图中的 *Source* 和 *map()* 算子之间）可以保留元素的分区和顺序信息。这意味着 *map()* 算子的 subtask[1] 输入的数据以及其顺序与 *Source* 算子的 subtask[1] 输出的数据和顺序完全相同，即**同一分区的数据只会进入到下游算子的同一分区**。
  - **重新分发模式：**（例如上图中的 *map()* 和 *keyBy/window* 之间，以及 *keyBy/window* 和 *Sink* 之间）则会更改数据所在的流分区。当你在程序中选择使用不同的 *transformation*，每个*算子子任务*也会根据不同的 transformation 将数据发送到不同的目标子任务。例如：*keyBy()*（通过散列键重新分区）、*broadcast()*（广播）或 *rebalance()*（随机重新分发）。

##### 03：有状态流处理

- Flink 中的算子可以是**有状态的**，并且Flink 应用程序可以在分布式群集上并行运行，其中每个算子的各个并行实例会在单独的线程中独立运行，并且通常情况下是会在不同的机器上运行。
- 有状态算子的并行实例组在存储其对应状态时通常是**按照键（key）进行分片存储的**。每个并行实例算子负责处理一组特定键的事件数据，并且这组键对应的状态会保存在本地。
- Flink 应用程序的状态访问都在本地进行，因为这有助于其提高吞吐量和降低延迟。通常情况下 Flink 应用程序都是将**状态存储在 JVM 堆上**，但如果状态太大，我们也可以选择将其**以结构化数据格式存储在高速磁盘中**。

##### 04：通过状态快照实现的容错

- 通过状态快照和流重放两种方式的组合，Flink 能够提供可容错的，精确一次计算的语义。
- 这些状态快照在执行时**会获取并存储分布式 pipeline 中整体的状态**，它会将数据源中消费数据的**偏移量记录**下来，并将整个 job graph 中算子获取到该数据（**记录的偏移量对应的数据**）时的状态记录并存储下来。当发生故障时，**Flink 作业会恢复上次存储的状态**，重置数据源从状态中记录的上次消费的偏移量开始重新进行消费处理。而且**状态快照在执行时会异步获取状态并存储，并不会阻塞正在进行的数据处理逻辑**。

