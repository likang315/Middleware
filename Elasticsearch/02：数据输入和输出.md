### 数据的输入和输出

------

##### 01：文档

- 它特指**最顶层结构**或者**根对象(root object)**序列化成的JSON数据（以唯一ID标识并存储于Elasticsearch中）
- 对象和文档还是有稍微区别的；

##### 02：文档的元数据(metadata)

| 节点     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| `_index` | 文档存储的地方【索引】，全部小写                             |
| `_type`  | **文档代表的对象的类**，相同类型的type的文档表示相同的"事物"，他们**数据结构相同** |
| `_id`    | 文档的唯一标识，**当与_index、_type 和 _id 联合使用时，就可以定位ES中唯一的文档** |

##### 03：索引文档

1. 使用自定义的ID 索引文档；

   - 在 ES 中每个文档都有一个版本号。当每次对文档进行修改时（包括删除）， `_version` 的值会递增，确保你的应用程序中的一部分修改不会覆盖另一部分所做的修改。

   ```sh
   PUT /{index}/{type}/{id}
   {
     "field": "value",
     ...
   }
   
   {
      "_index":    "website",
      "_type":     "blog",
      "_id":       "123",
      "_version":  1,
      "created":   true
   }
   ```

2. Autogenerating IDs

   - 自动生成的 ID 是 URL-safe、 基于 Base64 编码且长度为20个字符的 GUID 字符串；

   ```sh
   POST /website/blog/
   {
     "title": "My second blog entry",
     "text":  "Still trying this out...",
     "date":  "2014/01/01"
   }
   # 除了 _id 是 Elasticsearch 自动生成的，响应的其他部分和前面的类似
   {
      "_index":    "website",
      "_type":     "blog",
      "_id":       "AVFgSgVHUP18jI2wRx0w",
      "_version":  1,
      "created":   true
   }
   ```

##### 04：检索文档

- ```sh
  GET /website/blog/123/pretty
  ```

- **pretty**：返回美化的的_source值，便于阅读；

- **{"found": true}** ：用于判断有没有找到返回的值；

  ```sh
  {
    "_index" :   "website",
    "_type" :    "blog",
    "_id" :      "123",
    "_version" : 1,
    "found" :    true,
    "_source" :  {
        "title": "My first blog entry",
        "text":  "Just trying this out...",
        "date":  "2014/01/01"
    }
  }
  ```

- **-i**：curl 加 -i 参数会返回响应头，用于检查文档是否存在；

  ```sh
  curl -i -XGET http://localhost:9200/website/blog/124?pretty
  
  HTTP/1.1 404 Not Found
  Content-Type: application/json; charset=UTF-8
  Content-Length: 83
  
  {
    "_index" : "website",
    "_type" :  "blog",
    "_id" :    "124",
    "found" :  false
  }
  ```

- **_source**：当我们只需要返回指定字段时，使用此参数，多个字段用逗号分隔；

  ```sql
  GET /website/blog/123?_source=title,text
  # 只返回 _source 的值，不需要其他元数据
  ```
  
  - 如果你只想得到 `_source` 字段，不需要任何元数据，你能使用 `_source` 端点
  
  - ```
    GET /website/blog/123/_source
    ```

##### 05：更新整个文档

- 在 ES 中文档是不可改变的，不能修改它们。 相反，如果想要更新现有的文档，需要重建索引或者进行替换， 我们可以使用相同的index API 进行实现；
- 在内部，Elasticsearch 已将旧文档标记为已删除，并增加一个全新的文档。 尽管你不能再对旧版本的文档进行访问，但它并不会立即消失。当继续索引更多的数据，Elasticsearch 会在后台清理这些已删除文档。

```sql
PUT /website/blog/123
{
  "title": "My first blog entry",
  "text":  "I am starting to get the hang of this...",
  "date":  "2014/01/02"
}

{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "123",
  "_version" : 2,
  "created":   false
}
```

##### 06：创建新的文档

- `_index`、`_type`、`_id` 三者唯一确定一个文档；

- 使用 POST 方法让 ES 自动生成唯一ID;

  ```sql
  POST /website/blog/
  { ... }
  ```

- 如果已经有自己的 `_id` ，那么我们必须告诉 Elasticsearch ，只有在相同的 `_index` 、 `_type` 和 `_id` 不存在时才接受我们的索引请求。

  - 第一种方法使用 `op_type` 查询 -字符串参数：
  
    ```js
    PUT /website/blog/123?op_type=create
    { ... }
    ```
  
  - 第二种方法是在 URL 末端使用 `/_create` :
  
    ```js
    PUT /website/blog/123/_create
    { ... }
    ```
  
  - 若是创建新文档，则返回201，反之返回 409 Conflict;

##### 07：删除文档

- 查看返回结果，版本号已经增加
- 如果没有找到文档将返回`404 Not Found` 的响应码；
- 即使文档不存在（ `Found` 是 `false` ）， **`_version` 值仍然会增加**。这是 Elasticsearch 内部记录本的一部分，用来**确保这些改变在跨多节点时以正确的顺序执行**。
- 类似更新整个文档中提到的，删除文档不会立即将文档从磁盘中删除，只是**将文档标记为已删除状态**。随着你不断的索引更多的数据，Elasticsearch **将会在后台清理标记为已删除的文档。**

```sql
DELETE /website/blog/123
```

##### 08：处理冲突

- ES并发写
  - 当我们使用 `index` API 更新文档 ，可以一次性读取原始文档，做我们的修改，然后**重新索引 *整个文档* 。 最近的索引请求将获胜**：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。
  - 悲观锁
  - 乐观锁
- Elasticsearch 是**分布式的**，当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是**异步和并发的**，这意味着**这些复制请求被并行发送，并且到达目的地时可能顺序是乱的。** 
- 每个文档都有一个 `_version` （版本）号，当文档被修改时版本号递增。 **ES 通过这个 `_version` 号来确保变更以正确顺序得到执行**。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。

###### 通过外部系统使用版本控制

- 一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索， 这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，可能存在问题；

- 如果你的主数据库已经有了**版本号 或一个能作为版本号的字段值**比如 `timestamp` — 那么你就可以在 ES 中通过增加 `version_type=external` 查询字符串的方式重用这些相同的版本号， 版本号必须是大于零的整数， 且小于 `9.2E+18` 一个 Java 中 `long` 类型的正值。

- 外部版本号的处理方式是 **Elasticsearch 检查当前 `_version` 是否 *小于* 指定的版本号，小于则请求成功。 若请求成功，外部的版本号作为文档的新 `_version` 进行存储**。

- 例如，要创建一个新的具有外部版本号 `5` 的博客文章，我们可以按以下方法进行：

- 存在一个问题：旧文档先于新文档到达，并且版本号都是大于当前版本；

  ```js
  PUT /website/blog/2?version=5&version_type=external
  {
    "title": "My first external blog entry",
    "text":  "Starting to get the hang of this..."
  }
  ```

##### 09：文档的部分更新













