### 分布式文档存储

------

##### 01：路由文档到分片

- 发送请求给集群中任意一个节点。**每个节点都有能力处理任意请求。每个节点都知道任意文档所在的节点，所以也可以将请求转发到需要的节点。**

- 当你索引一个文档，它被存储在单独一个主分片上，ES 是根据一个算法来计算出文档属于哪个分片上

- ```java
  shard = hash(routing) % number_of_primary_shards
  ```

- routing 值是一个任意字符串，它默认是 _id，但也可以自定义。这个 routing 字符串通过哈希函数生成**一个数字，然后除以主切片的数量得到一个余数(取模)，余数的范围永远是 0 到 number_of_primary_shards - 1** ，这个数字就是特定文档所在的分片。

- 这也就是为什么主分片数只能在创建索引时定义且不能修改，**如果主分片的数量改变，所有先前的路由值就失效**了，文档也就永远找不到了。

##### 02：写操作流程

- 必须在主分片上成功完成才能复制到相关的复制分片上；
  - 以三个 node 为例，客户端给 Node 1 发送新建、索引或删除请求。
  - 节点使用文档的 _id 确定文档属于分片 0 。它转发请求到 Node 3 ，分片 0 位于这个节点上。
  -  Node 3 在主分片上执行请求，如果成功，它转发请求到相应的位于 Node 1 和 Node 2 的复制节点上。当所有的复制节点报告成功， Node 3 报告成功到请求的节点，请求的节点再报告给客户端。
- 请求参数【牺牲安全性提升性能】
  - **replication**
    - 复制的默认的值是 sync 。这将**导致主分片得到复制分片的成功响应后才返回**。如果你设置 replication 为 async ，请求在主分片上被执行后就会返回给客户端。它依旧会转发请求给复制节点，但你将不知道复制节点成功与否。
  - **consistency**
    - 默认主分片在尝试**写入时需要规定数量(quorum)或过半的分片可用**；
    - consistency 允许的值为 one （只有一个主分片）， all （所有主分片和复制分片）或者默认的 quorum 或过半分片。
  - **timeout**
    - 当分片副本不足时会怎样？Elasticsearch会等待更多的分片出现。**默认等待一分钟**。如果需要，你可以设置 timeout 参数让它终止的更早：100 表示100毫秒， 30s 表示30秒。

##### 03：检索文档流程

- 客户端给 Node 1 发送get请求。
- 节点使用文档的 _id 确定文档属于分片 0 。分片 0 对应的复制分片在三个节点上都有。此时，它转发请求到 Node 2 。
- Node 2 返回endangered给 Node 1 然后返回给客户端。
- 注意：
  - 为了负载均衡，请求节点会为每个请求选择不同的分片，它会循环所有分片副本；
  - 一个被索引的文档**已经存在于主分片上却还没来得及同步到复制分片上**。这时复制分片会报告文档未找到，主分片会成功返回文档。一旦索引请求成功返回给用户，文档则在主分片和复制分片都是可用的。

##### 04：局部更新文档

- 客户端给 Node 1 发送更新请求。
- 它转发请求到主分片所在节点 Node 3 。
- Node 3 从主分片检索出文档，修改 _source 字段的JSON，然后在主分片上重建索引。如果有其他进程修改了文档，它以 retry_on_conflict 设置的次数重复步骤3，都未成功则放弃。
- 如果 Node 3 成功更新文档，它同时转发文档的新版本到 Node 1 和 Node 2 上的复制节点以重建索引。当所有复制节点报告成功， Node 3 返回成功给请求节点，然后返回给客户端。
- 注意：
  - **当主分片转发更改给复制分片时，并不是转发更新请求，而是转发整个文档的新版本**；

##### 05：多文档模式

- 











